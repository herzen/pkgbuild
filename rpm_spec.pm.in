@WARNING_MESSAGE_L1@
@WARNING_MESSAGE_L2@
@WARNING_MESSAGE_L3@
@WARNING_MESSAGE_L4@
@WARNING_MESSAGE_L5@
@WARNING_MESSAGE_L6@
@WARNING_MESSAGE_L7@

#use strict;

use warnings;
use rpm_package;
use rpm_file;
use packagebase;

package rpm_spec;

sub get_name ($);

use overload ('""' => \&get_name);	  

my %arch;
my $os;
my $os_rel;
	      
my $_default_topdir = "@TOPDIR@";
my $_pkgbuild_libdir = "@PKGBUILD_LIBDIR@";

my $all_script_names = "pre|post|preun|postun|verifyscript|triggerin|triggerun|triggerpostun";
my $all_block_names = "prep|build|install|clean|changelog|$all_script_names";
my $all_keywords = "$all_block_names|define|patch|setup|files|description|package|iclass|rclass|use";

sub init () {
    my $arch0 = `uname -p`;
    chomp ($arch0);
    if ($arch0 eq "unknown") {
	$arch0 = `uname -m`;
	chomp ($arch0);
	if ($arch0 eq 'i585') {
	    $arch0 = 'i386';
	} elsif ($arch0 eq 'i686') {
	    $arch0 = 'i386';
	}
    }
    $arch{$arch0} = 1;

    $os = `uname -s`;
    chomp ($os);
    $os = lc ($os);
    $os_rel = `uname -r`;
    chomp ($os_rel);
    if ($os eq 'sunos') {
	if ($os_rel =~ /^5\./) {
	    $os = 'solaris';
	}
    }

    if ($os eq "linux") {
	$_default_topdir = `rpm -ba $_pkgbuild_libdir/get_rpm_topdir 2>&1 | grep '^TOPDIR=' | cut -f2 -d=`;
	chomp ($_default_topdir);
    } elsif ($os eq "solaris") {
	my $isainfo = `/usr/bin/isainfo`;
	chomp ($isainfo);
	my @isas = split / /, $isainfo;
	foreach my $isa (@isas) {
	    next if not defined $isa;
	    $arch{$isa} = 1;
	}
    }
}

# Create a new rpm_spec object.
# Return undef if the spec_file is not found
sub new ($;$$) {
    my $class = shift;
    my $spec_file = shift;
    my $predef_ref = shift;
    my $parent_spec = shift;
    my $self = {};
    
    if (! -r $spec_file) {
	return (undef);
    }
    
    if ((not defined ($predef_ref) or not @$predef_ref) and
	not defined $parent_spec) {
	my $packagebase = new packagebase ();
	my $spec = $packagebase->find_spec_by_file_name ($spec_file);
	if (defined ($spec)) {
	    return ($spec);
	}
    }

    $self->{_file_name} = $spec_file;
    my $base_file_name = $spec_file;
    $base_file_name =~ s/^.*\/([^\/]*)$/$1/;
    $self->{_base_file_name} = $base_file_name;
    $self->{_loaded} = 0;
    $self->{_being_loaded} = 0;
    $self->{_defines} = {};
    $self->{_specs_used} = {};
    $self->{_blocks} = {};
    $self->{_classes} = {};
    $self->{_in_conditional} = 0;
    $self->{_parent_spec} = $parent_spec;
    my @inc;
    $self->{_includes} = \@inc;

    if (defined ($parent_spec)) {
	my $parent_def_ref = $parent_spec->{_defines};
	$self->{_defines} = {%$parent_def_ref};
	delete ($self->{_defines}->{_build_src_dir_name});
    } else {
	$self->{_defines}->{_pkgbuild} = "pkgbuild";
	$self->{_defines}->{_pkgbuild_version} = "@PKGBUILD_VERSION@";
	$self->{_defines}->{_target} = "i386";
	$self->{_defines}->{_sysconfdir} = "/etc";
	$self->{_defines}->{_initrddir} = "%{_sysconfdir}/rc.d/init.d";
	$self->{_defines}->{_prefix} = "/usr";
	$self->{_defines}->{_exec_prefix} = "%{_prefix}";
	$self->{_defines}->{_bindir} = "%{_exec_prefix}/bin";
	$self->{_defines}->{_lib} = "lib";
	$self->{_defines}->{_libdir} = "%{_exec_prefix}/%{_lib}";
	$self->{_defines}->{_libexecdir} = "%{_exec_prefix}/libexec";
	$self->{_defines}->{_sbindir} = "%{_exec_prefix}/sbin";
	$self->{_defines}->{_sharedstatedir} = "%{_prefix}/com";
	$self->{_defines}->{_datadir} = "%{_prefix}/share";
	$self->{_defines}->{_includedir} = "%{_prefix}/include";
	$self->{_defines}->{_oldincludedir} = "/usr/include";
	$self->{_defines}->{_infodir} = "/usr/share/info";
	$self->{_defines}->{_mandir} = "/usr/share/man";
	$self->{_defines}->{_localstatedir} = "/var";
	$self->{_defines}->{_defaultdocdir} = "%_prefix/doc";
	$self->{_defines}->{_docdir} = "%_datadir/doc";
	$self->{_defines}->{__libtoolize} = "libtoolize";
    
	$self->{_defines}->{_global_cflags} = "-O2 -g -pipe";
	$self->{_defines}->{optflags} = "%{_global_cflags}";
	$self->{_defines}->{_var} = "/var";
	$self->{_defines}->{_tmppath} = "%{_var}/tmp";
	$self->{_defines}->{_usr} = "/usr";
	$self->{_defines}->{_usrsrc} = "%{_usr}/src";

	$self->{_defines}->{_topdir} = $_default_topdir;
	$self->{_defines}->{_builddir} = "%{_topdir}/BUILD";
	$self->{_defines}->{_rpmdir} = "%{_topdir}/RPMS";
	$self->{_defines}->{_sourcedir} = "%{_topdir}/SOURCES";
	$self->{_defines}->{_specdir} = "%{_topdir}/SPECS";
	$self->{_defines}->{_srcrpmdir} = "%{_topdir}/SRPMS";

	$self->{_defines}->{makeinstall} = "make \\\n" .
	    "    prefix=%{?buildroot:%{buildroot}}%{_prefix} \\\n" .
	    "    exec_prefix=%{?buildroot:%{buildroot}}%{_exec_prefix} \\\n" .
	    "    bindir=%{?buildroot:%{buildroot}}%{_bindir} \\\n" .
            "    sbindir=%{?buildroot:%{buildroot}}%{_sbindir} \\\n" .
            "    sysconfdir=%{?buildroot:%{buildroot}}%{_sysconfdir} \\\n" .
            "    datadir=%{?buildroot:%{buildroot}}%{_datadir} \\\n" .
            "    includedir=%{?buildroot:%{buildroot}}%{_includedir} \\\n" .
            "    libdir=%{?buildroot:%{buildroot}}%{_libdir} \\\n" .
            "    libexecdir=%{?buildroot:%{buildroot}}%{_libexecdir} \\\n" .
            "    localstatedir=%{?buildroot:%{buildroot}}%{_localstatedir} \\\n" .
            "    sharedstatedir=%{?buildroot:%{buildroot}}%{_sharedstatedir} \\\n" .
            "    mandir=%{?buildroot:%{buildroot}}%{_mandir} \\\n" .
            "    infodir=%{?buildroot:%{buildroot}}%{_infodir} \\\n" .
            "        install";
	$self->{_defines}->{pkgbuild_postprocess} = "${_pkgbuild_libdir}/pkgbuild-postprocess";
	$self->{_defines}->{nil} = "";
	$self->{_defines}->{find_lang} = "echo WARNING: find_lang not implemented"

    }

    if (defined ($predef_ref)) {
	foreach my $predef (@$predef_ref) {
	    next if not defined $predef;
	    if ($predef =~ /^\s*([a-zA-Z0-9_]*)\s+(.*\S)\s*$/) {
		$self->{_defines}->{$1} = $2;
	    } else {
		$self->{error} = "invalid definition $predef";
		return undef;
	    }
	}
    }
    
    bless ($self, $class);
    my $main_package = rpm_package->new (\$self);
    my @packages = ($main_package);
    $self->{_packages} = \@packages;

    if ((not defined ($predef_ref) or not @$predef_ref) and
	not defined $parent_spec) {
	my $packagebase = new packagebase ();
	$packagebase->add_package ($main_package);
	$packagebase->add_spec ($self);
    }

    return $self;
}

sub eval ($$) {
    my $self = shift;
    my $str = shift;

    my $def;
    my $val;
    my $name;

    if (not defined ($str)) {
	return undef;
    }

    if ($str =~ /^#/) {
	return $str;
    }

    if (index ($str, "%") == -1) {
	return $str;
    }

    @chrs = split //, $str;
    return $self->_do_eval (0, "", @chrs);
}

sub _pre_eval ($$) {
    my $self = shift;
    my $str = shift;

    my $def;
    my $val;
    my $name;

    if (not defined ($str)) {
	return undef;
    }

    if ($str =~ /^#/) {
	return $str;
    }

    if (index ($str, "%") == -1) {
	return $str;
    }

    @chrs = split //, $str;
    return $self->_do_eval (1, "", @chrs);
}

sub _do_eval ($$$@) {
    my $self = shift;
    my $preeval = shift;
    my $str = shift;
    my @chrs = @_;

    if (not @chrs) {
	return $str;
    }

    my $chr = shift (@chrs);
    if (not @chrs) {
	return "$str$chr";
    }
    while ($chr ne "%") {
	$str = "$str$chr";
	$chr = shift (@chrs);
	if (not @chrs) {
	    return "$str$chr";
	}
    }
    if ($chr eq "%") {
	$chr = shift (@chrs);
	if ($chr eq "%") {  # %%
	    if ($preeval) {
		return $self->_do_eval ($preeval, "$str%%", @chrs);
	    } else {
		return $self->_do_eval ($preeval, "$str%", @chrs);
	    }
	} elsif ($chr eq "(") {  # %(command)
	    return $self->_do_eval_command ($preeval, $str, @chrs);
	} elsif ($chr eq "{") {  # %{....
	    if (not @chrs) {
		$self->_set_error ("Unterminated {: $str%{");
		return $str;
	    }
	    $chr = shift (@chrs);
	    if (not @chrs) {
		if ($chr eq "}") {  # %{}
		    if ($preeval) {
			return "$str%{}";
		    } else {
			return "$str%";
		    }
		}
		$self->_set_error ("Unterminated {: $str%{$chr");
		return $str;
	    }
	    if ($chr =~ /([SP])/ and ($chrs[0] eq ":")) {  # %{S:n} or %{P:n}
		shift (@chrs);
		return $self->_do_eval_sp ($preeval, $str, $1, @chrs);
	    } elsif ($chr eq "?") {  # %{?
		return $self->_do_eval_cond ($preeval, $str, "{", @chrs);
	    } elsif ($chr =~ /[a-zA-Z_]/) {
		return $self->_do_eval_var ($preeval, $str, "{", "$chr", @chrs);
	    } elsif ($chr eq "}") {
		if ($preeval) {
		    return $self->_do_eval ($preeval, "$str%{}", @chrs);
		} else {
		    return $self->_do_eval ($preeval, "$str%", @chrs);
		}
	    } else {
		return $self->_do_eval ($preeval, "$str%{$chr", @chrs);
	    }
	} else {  # %var
	    if ($chr =~ /[a-zA-Z_]/) {
		return $self->_do_eval_var ($preeval, $str, undef, "$chr", @chrs);
	    }
	    return $self->_do_eval ($preeval, "$str$chr", @chrs);
	}
    } else {
	print "WARNING: assertion failed: _do_eval()\n";
	return $self->_do_eval ($preeval, "$str$chr", @chrs);
    }
}

sub _do_eval_var ($$$$$@) {  # %var or %{var}
    my $self = shift;
    my $preeval = shift;
    my $str = shift;
    my $delimiter = shift;
    my $varname = shift;
    my @chrs = @_;

    my $chr = "";
    while (@chrs) {
	$chr = shift (@chrs);
	if ($chr =~ /[a-zA-Z0-9_]/) {
	    $varname = "$varname$chr";
	    next;
	}
	if ($chr eq ".") {
	    return $self->_do_eval_spec_var ($preeval, $str, $delimiter,
					     $varname, @chrs);
	}
	if (($chr eq "}") and defined ($delimiter)) {
	    last;
	}
	if (not defined ($delimiter)) {
	    unshift (@chrs, $chr);
	    last;
	}
	$varname = "$varname$chr";
    }
    if (not @chrs and defined ($delimiter) and ($chr ne "}")) {
	$self->_set_error ("Unterminated {: $str%{$varname");
	return $str;
    }

    my $val = $self->get_value_of ($varname);
    if (defined ($val) and not $preeval) {
	$val = $self->eval ($val);
	return $self->_do_eval ($preeval, "$str$val", @chrs);
    } else {
	if (defined ($delimiter)) {
	    return $self->_do_eval ($preeval, "$str%{$varname}", @chrs);
	} else {
	    return $self->_do_eval ($preeval, "$str%$varname", @chrs);
	}
    }
}

sub _do_eval_spec_var ($$$$$@) { # %spec.var or %{spec.var}
    my $self = shift;
    my $preeval = shift;
    my $str = shift;
    my $delimiter = shift;
    my $specname = shift;
    my @chrs = @_;

    my $varname = "";
    my $chr = "";
    while (@chrs) {
	$chr = shift (@chrs);
	if ($chr =~ /[a-zA-Z0-9_]/) {
	    $varname = "$varname$chr";
	    next;
	}
	if ($chr eq ".") {
	    if ($varname ne "") {
		return $self->_do_eval_spec_pkg_var ($preeval,
						     $str, $delimiter,
						     $specname, $varname,
						     @chrs);
	    } else {
		if (defined ($delimiter)) {
		    $varname = ".";
		    next;
		} else {
		    my $val = $self->get_value_of ($specname);
		    if (defined ($val) and not $preeval) {
			$val = $self->eval ($val);
			return $self->_do_eval ($preeval, "$str$val..", @chrs);
		    } else {
			return $self->_do_eval ($preeval, "$str%$specname..", @chrs);
		    }
		}
	    }
	}
	if (($chr eq "}") and defined ($delimiter)) {
	    last;
	}
	if (not defined ($delimiter)) {
	    unshift (@chrs, $chr);
	    last;
	}
	$varname = "$varname$chr";
    }
    if (not @chrs and defined ($delimiter) and ($chr ne "}")) {
	$self->_set_error ("Unterminated {: $str%{$specname.$varname");
	return $str;
    }

    my $spec_used = $self->{_specs_used}->{$specname};
    if (not defined $spec_used) {
	if (defined ($delimiter)) {
	    return $self->_do_eval ($preeval, "$str%{$specname.$varname}", @chrs);
	}
	my $val = $self->get_value_of ($specname);
	if (not defined $val or $preeval) {
	    return $self->_do_eval ($preeval, "$str%$specname.$varname", @chrs);
	} else {
	    $val = $self->eval ($val);
	    return $self->_do_eval ($preeval, "$str$val.$varname", @chrs);
	}
    }
    my $val = $$spec_used->get_value_of ($varname);
    if (defined ($val) and not $preeval) {
	$val = $self->eval ($val);
	return $self->_do_eval ($preeval, "$str$val", @chrs);
    } else {
	if (defined ($delimiter)) {
	    return $self->_do_eval ($preeval, "$str%{$specname.$varname}", @chrs);
	} else {
	    return $self->_do_eval ($preeval, "$str%$specname.$varname", @chrs);
	}
    }
}

sub _do_eval_spec_pkg_var ($$$$$@) { # %spec.pkg.var or %{spec.pkg.var}
    my $self = shift;
    my $preeval = shift;
    my $str = shift;
    my $delimiter = shift;
    my $specname = shift;
    my $pkgname = shift;
    my @chrs = @_;

    my $varname = "";
    my $chr = "";
    while (@chrs) {
	$chr = shift (@chrs);
	if ($chr =~ /[a-zA-Z0-9_]/) {
	    $varname = "$varname$chr";
	    next;
	}
	if (($chr eq "}") and defined ($delimiter)) {
	    last;
	}
	if (not defined ($delimiter)) {
	    unshift (@chrs, $chr);
	    last;
	}
	$varname = "$varname$chr";
    }
    if (not @chrs and defined ($delimiter) and ($chr ne "}")) {
	$self->_set_error ("Unterminated {: $str%{$specname.$pkgname.$varname");
	return $str;
    }

    my $spec_used = $self->{_specs_used}->{$specname};
    if (not defined $spec_used) {
	if (defined ($delimiter)) {
	    return $self->_do_eval ($preeval, "$str%{$specname.$pkgname.$varname}", @chrs);
	}
	my $val = $self->get_value_of ($specname);
	if (not defined $val or $preeval) {
	    return $self->_do_eval ($preeval, "$str%$specname.$pkgname.$varname", @chrs);
	} else {
	    $val = $self->eval ($val);
	    return $self->_do_eval ($preeval, "$str$val.$pkgname.$varname", @chrs);
	}
    }
    my $pkg_ref = $$spec_used->find_package_by_name ($pkg);
    if (not defined $pkg_ref) {
	if (defined ($delimiter)) {
	    return $self->_do_eval ($preeval, "$str%{$specname.$pkgname.$varname}", @chrs);
	}
	my $val = $$spec_used->get_value_of ($pkgname);
	if (not defined $val or $preeval) {
	    return $self->_do_eval ($preeval, "$str%$specname.$pkgname.$varname", @chrs);
	} else {
	    $val = $self->eval ($val);
	    return $self->_do_eval ($preeval, "$str$val.$varname", @chrs);
	}
    }
    my $val = $$pkg_ref->get_tag ($varname);
    if (defined ($val) and not $preeval) {
	return $self->_do_eval ($preeval, "$str$val", @chrs);
    } else {
	if (defined ($delimiter)) {
	    return $self->_do_eval ($preeval, "$str%{$specname.$pkgname.$varname}", @chrs);
	} else {
	    return $self->_do_eval ($preeval, "$str%$specname.$pkgname.$varname", @chrs);
	}
    }
}

sub _do_eval_command ($$$@) {  # %(command)
    my $self = shift;
    my $preeval = shift;
    my $str = shift;
    my @chrs = @_;

    my $command = "";
    my $chr = "";
    my $depth = 0;
    while (@chrs) {
	$chr = shift (@chrs);
	if ($chr eq "%") {
	    if (@chrs and ($chrs[0] eq "(")) {
		++$depth;
	    }
	}

	if (($chr eq "\\") and @chrs and ($chrs[0] eq ")")) {
	    $command="$command\\)";
	    shift (@chrs);
	    next;
	}

	if ($chr eq ")") {
	    if ($depth > 0) {
		--$depth;
	    } else {
		last;
	    }
	}
	$command = "$command$chr";
    }
    if (not @chrs and (($depth > 0) or ($chr ne ")"))) {
	$self->_set_error ("Unterminated %(: $str%($command");
	return $str;
    }

    if ($preeval) {
	return $self->_do_eval ($preeval, "$str%($command)", @chrs);
    } else {
	$command = $self->eval ($command);
	if (defined $self->{error}) {
	    return $str;
	}
	my $command_out = `$command`;
	chomp ($command_out);
	return $self->_do_eval ($preeval, "$str$command_out", @chrs);
    }
}

sub _do_eval_sp ($$$$@) {  # %{S:n} or %{P:n}
    my $self = shift;
    my $preeval = shift;
    my $str = shift;
    my $sp = shift;
    my @chrs = @_;

    my $chr = "";
    my $num = "";
    while (@chrs) {
	$chr = shift (@chrs);
	if ($chr eq "}") {
	    last;
	}
	$num = "$num$chr";
    }
    if (not @chrs and ($chr ne "}")) {
	$self->_set_error ("Unterminated {: $str%{$sp:$num");
	return $str;
    }

    if (not _is_number ($num) or $preeval) {
	return $self->_do_eval ($preeval, "$str%{$sp:$num}", @chrs);
    }
    my $val;
    if ($sp eq "S") {
	$val = $self->get_value_of ("SOURCE$num");
    } else {
	$val = $self->get_value_of ("PATCH$num");
    }
    if (defined ($val)) {
	$val = $self->eval ($val);
	return $self->_do_eval ($preeval, "$str$val", @chrs);
    } else {
	return $self->_do_eval ($preeval, "$str%{$sp:$num}", @chrs);
    }
}

sub _do_eval_cond ($$$$@) {  # %?foo or %{?foo} or %{?foo:bar}
    my $self = shift;
    my $preeval = shift;
    my $str = shift;
    my $delimiter = shift;
    my @chrs = @_;

    my $varname = "";
    my $chr = "";
    while (@chrs) {
	$chr = shift (@chrs);
	if ($chr =~ /[a-zA-Z0-9_]/) {
	    $varname = "$varname$chr";
	    next;
	}
	if (($chr eq ":") and defined $delimiter) {
	    return $self->_do_eval_cond_val ($preeval, $str, $varname, @chrs);
	}
	if (($chr eq "}") and defined ($delimiter)) {
	    last;
	}
	if (not defined ($delimiter)) {
	    unshift (@chrs, $chr);
	    last;
	}
	$varname = "$varname$chr";
    }
    if (not @chrs and defined ($delimiter) and ($chr ne "}")) {
	$self->_set_error ("Unterminated {: $str%{?$varname");
	return $str;
    }

    my $val = $self->get_value_of ($varname);
    if (defined ($val)) {
	if (not $preeval) {
	    $val = $self->eval ($val);
	} else {
	    $val = $self->_pre_eval ($val);
	}
	return $self->_do_eval ($preeval, "$str$val", @chrs);
    } else {
	return $self->_do_eval ($preeval, "$str", @chrs);
    }
}

sub _do_eval_cond_val ($$$$@) {  #  %{?foo:bar}
    my $self = shift;
    my $preeval = shift;
    my $str = shift;
    my $varname = shift;
    my @chrs = @_;

    my $defval = "";
    my $chr = "";
    my $depth = 0;
    while (@chrs) {
	$chr = shift (@chrs);
	if ($chr eq "%") {
	    if (@chrs and ($chrs[0] eq "{")) {
		++$depth;
	    }
	}

	if (($chr eq "\\") and @chrs and ($chrs[0] eq "}")) {
	    $defval="$defval\\}";
	    shift (@chrs);
	    next;
	}

	if ($chr eq "}") {
	    if ($depth > 0) {
		--$depth;
	    } else {
		last;
	    }
	}
	$defval = "$defval$chr";
    }
    if (not @chrs and (($depth > 0) or ($chr ne "}"))) {
	$self->_set_error ("Unterminated {?: $str%{?$varname:$defval");
	return $str;
    }

    my $val = $self->get_value_of ($varname);
    if (defined ($val)) {
	if ($preeval) {
	    $val = $self->_pre_eval ($defval);
	    $str = $self->_do_eval ($preeval, "$str$val", @chrs);
	} else {
	    $val = $self->eval ($defval);
	    $str = $self->_do_eval ($preeval, "$str$val", @chrs);
	}
	return $str;
    } else {
	return $self->_do_eval ($preeval, "$str", @chrs);
    }
}

my %_line_numbers;
my %_file_names;
my $last_fhandle;

sub _set_error ($$;$) {
    my $self = shift;
    my $msg = shift;
    my $fhandle = shift;

    $fhandle = $last_fhandle if not defined ($fhandle);

    my $fname = $_file_names{$fhandle};
    $fname = "" if not defined $fname;
    my $lineno;
    if (defined ($_line_numbers{$fhandle})) {
	$lineno = "($_line_numbers{$fhandle}): ";
    } else {
	$lineno = "";
	if ($fname ne "") {
	    $lineno = ": ";
	}
    }

    $self->{error} = "$fname$lineno$msg";
}

sub _eat_lines ($$) {
    my $self = shift;
    my $fhandle = shift;
    my $line;

    my $depth = 1;

    if (not defined ($_line_numbers{$fhandle})) {
	$_line_numbers{$fhandle} = 0;
    }
    $last_fhandle = $fhandle;

    while (1) {
	$line = <$fhandle>;
	$_line_numbers{$fhandle}++;
	if (not defined $line) {
	    last;
	}
	if ($line =~ /^\s*%if(arch|os)/) {
	    $depth++;
	} elsif ($line =~ /^\s*%else/) {
	    $depth--;
	    if ($depth == 0) {
		return "%else";
	    }
	} elsif ($line =~ /^\s*%endif/) {
	    $depth--;
	    if ($depth == 0) {
		return "%endif";
	    }
	}
    }
    return undef;
}

sub _match_arch ($) {
    my $str = shift;

    chomp ($str);
    my @archs = split /[\s,]+/, $str;
    foreach my $a (@archs) {
	next if not defined $a;
	if (defined ($arch{$a})) {
	    return 1;
	}
    }
    return 0;
}

sub _match_os ($) {
    my $str = shift;

    chomp ($str);
    my @oss = split /[\s,]+/, $str;
    foreach my $o (@oss) {
	next if not defined $o;
	if (lc ($o) eq $os) {
	    return 1;
	}
    }
    return 0;
}

sub _get_next_line ($$) {
    my $self = shift;
    my $fhandle = shift;

    if (not defined ($_line_numbers{$fhandle})) {
	$_line_numbers{$fhandle} = 0;
    }

    my $line = <$fhandle>;
    $_line_numbers{$fhandle}++;
    $last_fhandle = $fhandle;
    if (not defined $line) {
	return undef;
    }

    if ($line =~ /^%if(arch|os|narch|nos)/) {
	my $cond = 0;
	
	if ($line =~ /^%ifarch\s+(\S.*)/) {
	    $cond = _match_arch ("$1");
	} elsif ($line =~ /^%ifnarch\s+(\S.*)/) {
	    $cond = not _match_arch ("$1");
	} elsif ($line =~ /^%ifos\s+(\S.*)/) {
	    $cond = _match_os ("$1");
	} elsif ($line =~ /^%ifnos\s+(\S.*)/) {
	    $cond = not _match_os ("$1");
	}

	++$self->{_in_conditional};

	if ($cond) {
	    $line = $self->_get_next_line ($fhandle);
	    if (not defined($line)) {
		$self->_set_error ("Unclosed %if", $fhandle);
		return undef;
	    }
	    return $line;
	}

	my $lastline = $self->_eat_lines ($fhandle);

	if (not defined $lastline) {
	    return undef;
	}
	if ($lastline eq "%endif") {
	    --$self->{_in_conditional};
	}
	$line = $self->_get_next_line ($fhandle);
	return $line;

    } elsif ($line =~ /^\s*%else/) {
	if ($self->{_in_conditional} == 0) {
	    $self->_set_error ("Got a %else with no if", $fhandle);
	    return undef;
	}
	my $lastline = $self->_eat_lines ($fhandle);
	if (not defined $lastline) {
	    return undef;
	}
	if ($lastline eq "%else") {
	    $self->_set_error ("%endif expected, %else found", $fhandle);
	    $line = undef;
	}
	if ($lastline eq "%endif") {
	    --$self->{_in_conditional};
	    $line = $self->_get_next_line ($fhandle);
	}
	return $line;
    } elsif ($line =~ /^\s*%endif/) {
	if ($self->{_in_conditional} == 0) {
	    $self->_set_error ("$fhandle: Got a %endif with no if", $fhandle);
	    return undef;
	}
	--$self->{_in_conditional};
	$line = $self->_get_next_line ($fhandle);
	return $line;
    }

    return $line;
}

sub _process_use ($$$) {
    my $self = shift;
    my $fhandle = shift;
    my $line = shift;

    my $name;
    my $fname;
    if ($line =~ /\s*%use\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*=\s*(.*\S)\s*$/) {
	$name = $1;
	$fname = $2;
    } else {
	$self->_set_error ("syntax error in %use directive", $fhandle);
	return 0;
    }

    if ($fname =~ /^"(.*)"$/) {
	$fname = $1;
    }

    my $specdir = $self->get_value_of ("_specdir");
    my $spec = new rpm_spec ("$specdir/$fname", undef, $self);
    if (not defined ($spec)) {
	$self->_set_error ("Could not open file $specdir/$fname", $fhandle);
	return 0;
    }

    $spec->get_value_of ("name");
    if (defined ($spec->{error})) {
	$self->_set_error ($spec->{error}, $fhandle);
	return 0;
    }

    $spec = new rpm_spec ("$specdir/$fname", undef, $self);

    $self->{_specs_used}->{$name} = \$spec;

    return 1;
}

# Global file id to make recursion possible
my $file_id = 1;

sub _process_include ($$$$@) {
    my $self = shift;
    my $fhandle = shift;
    my $line = shift;
    my $callback = shift;
    my @cbargs = @_;

    my $specdir = $self->get_value_of ("_specdir");
    my $fname = $line;
    $fname =~ s/\s*%include\s+(\S+)\s*/$1/ or
	$self->_set_error ("Invalid %include command: $line", $fhandle),
	return (0);
    if ($fname =~ /^"(.*)"$/) {
	$fname = $1;
    }

    my $inc_fhandle = "SPEC_FILE" . $file_id++;
    open $inc_fhandle, "<$specdir/$fname" or
	$self->_set_error ("Could not open %include file $specdir/$fname for reading", $fhandle), 
	return (0);
    $_file_names{$inc_fhandle} = "$fname";
    my $incref = $self->{_includes};
    push(@$incref, $fname);

    if (not $self->$callback ($inc_fhandle, undef, @cbargs)) {
	return (0);
    }

    close $inc_fhandle;

    if (defined $self->{error}) {
	return 0;
    }

    return (1);
}

sub _process_tag ($$$) {
    my $self = shift;
    my $fhandle = shift;
    my $line = shift;

    my @unique_tags = ("name", "version", "release",
		       "epoch", "buildroot",
		       "copyright", "license",
		       "distribution", "icon",
		       "url", "group",
		       "packager", "autoreqprov",
		       "serial", "nosource", "nopatch",
		       "sunw_basedir", "sunw_pkg",
		       "sunw_prodname", "sunw_prodvers",
		       "sunw_category", "sunw_hotline", 
		       "sunw_maxinst", "vendor", "sunw_rev",
		       "sunw_copyright", "sourcepackage",
		       "buildarchitectures", "buildarch",
		       "excludearch", "exclusivearch",
		       "excludeos", "exclusiveos", "prefix",
		       "summary", "version", "sunw_basedir",
		       "sunw_prodname", "sunw_prodvers",
		       "sunw_category", "sunw_hotline",
		       "sunw_maxinst", "vendor", "docdir",
		       "sunw_pkglist", "sunw_loc",
		       "sunw_copyright");
    my @multi_tags = ("buildrequires", "requires", "obsoletes", "conflicts",
		      "buildconflicts", "prereq", "provides", "buildprereq");
    my @ord_tags = ( "source", "patch" );
    my @localised_tags = ("summary");
    my $lcline = lc($line);
    chomp ($line);
    $lcline =~ s/^\s*//;
    my $tagname;
    my $value;
    my $package_ref = $self->{_current_package};

    foreach my $tag (@unique_tags) {
	if ($lcline =~ /^$tag\s*:\s*/) {
	    $line =~ /^\s*[a-zA-Z0-9_-]*\s*:\s*(.*\S)\s*$/;
	    $value = $1;
	    $tagname = $tag;
	    $tagname =~ s/^([a-z_]*).*$/$1/;
	    $package_ref->set_tag ($tagname, $value);
	    return 1;
	}
    }

    foreach my $tag (@multi_tags) {
	if ($lcline =~ /^$tag\s*:\s*/) {
	    $line =~ /^\s*[a-zA-Z0-9_-]*\s*:\s*(.*\S)\s*$/;
	    $value = $1;
	    $tagname = $tag;
	    $tagname =~ s/^([a-z_]*).*$/$1/;
	    $package_ref->push_tag ($tagname, $value);
	    return 1;
	}
    }

    foreach my $tag (@ord_tags) {
	if ($lcline =~ /^$tag([0-9]*)\s*:\s*/) {
	    my $num = $1;
	    $line =~ /^\s*[a-zA-Z0-9_-]*\s*:\s*(.*\S)\s*$/;
	    $value = $1;
	    $tagname = $tag;
	    $tagname =~ s/^([a-z_]*).*$/$1/;
	    $package_ref->set_ord_tag ($tagname, $num, $value);
	    return 1;
	}
    }

    foreach my $tag (@localised_tags) {
	if ($lcline =~ /^$tag\(([^)]*)\)\s*:\s*/) {
	    my $locale = $1;
	    $line =~ /^\s*[a-zA-Z0-9()@_-]*\s*:\s*(.*\S)\s*$/;
	    $value = $1;
	    $tagname = $tag;
	    $tagname =~ s/^([a-z_]*).*$/$1/;
	    $package_ref->set_tag ("$tagname::$locale", $value);
	    return 1;
	}
    }

    $self->_set_error ("Unknown tag: $line", $fhandle);
    return 0;
}

sub _process_define ($$$) {
    my $self = shift;
    my $fhandle = shift;
    my $line = shift;

    if ($line =~ /\s*%define\s+([a-zA-Z0-9_]*)\s+(.*)$/) {
	my $val = $2;
	my $mname = $1;
	$val =~ s/\s*$//;
	$self->{_defines}->{$mname} = $val;
	return 1;
    } else {
	my $mname = "";
	if ($line =~ /\s*%define\s+(\S*)/) {
	    $mname = $1;
	}
	print "WARNING: Macro %$mname has illegal name (%define)\n";
	return 1;
    }
}

sub _process_package ($$$) {
    my $self = shift;
    my $fhandle = shift;
    my $line = shift;

    my $mainpkg_ref = \$self->{_packages}[0];
    my $package_name;

    if ($line =~ /\s*%[pP][aA][cC][kK][aA][gG][eE]\s+-n\s+(\S+)\s*$/) {
	$package_name = $1;
    } elsif ($line =~ /\s*%[pP][aA][cC][kK][aA][gG][eE]\s+(\S+)\s*$/) {
	$package_name = $$mainpkg_ref->get_tag ("name") . "-" . $1;
    } else {
	$self->_set_error ("invalid %package directive: $line", $fhandle);
	return 0;
    }

    my $pkg = $self->find_package_by_name ($package_name);
    if (defined ($pkg)) {
	$self->_set_error ("Package already exists: $package_name", $fhandle);
	return 0;
    }

    if ($os eq "solaris") {
	my $src_pkg_name = $self->get_value_of ("sourcepackage");
	if (not defined $src_pkg_name) {
	    $src_pkg_name = $$mainpkg_ref->get_tag ("name") . "-src";
	}
	if ($src_pkg_name eq $package_name) {
	    $self->_set_error ("Package name $package_name clashes with the source package name, use the SourcePackage tag to define a different source package name", $fhandle);
	    return 0;
	}
	if (length ($package_name) > 32) {
	    $self->_set_error ("Package name $package_name is too long (>32 chars)", $fhandle);
	    return 0;
	}
    }

    my $new_package = rpm_package->new_subpackage (\$self, $package_name);
    my $ref = $self->{_packages};
    push (@$ref, $new_package);
    my $packagebase = new packagebase;
    $packagebase->add_package ($new_package);
    $self->{_current_package} = $new_package;

    $line = $self->_get_next_line ($fhandle);
    if (defined ($line)) {
	return $self->_process_top_level ($fhandle, $line);
    }

    if (defined $self->{error}) {
	return 0;
    }

    return 1;
}

sub _preprocess_line ($$) {
    my $self = shift;
    my $line = shift;

    chomp ($line);
    $line =~ s/^\s*//;
    $line = $self->eval ($line);

    return ($line);
}

sub _get_unpack_commands ($$) {
    my $srcname = shift;
    my $opt_q = shift;
    my $unpack;
    my $uncompress;

    if (not defined $opt_q) {
	$unpack = " | /bin/tar xvf -";
    } else {
	$unpack = " | /bin/tar xf -";
    }
    if ($srcname =~ /(\.tar\.bz2|\.tbz|\.tbz2)$/) {
	$uncompress = "/usr/bin/bzip2 -dc";
    } elsif ($srcname =~ /(\.tar\.gz|\.tgz)$/) {
	$uncompress = "/usr/bin/gzip -dc";
    } elsif ($srcname =~ /(\.tar)$/) {
	$uncompress = "/bin/cat";
    } elsif ($srcname =~ /(\.zip)$/) {
	if (not defined $opt_q) {
	    $uncompress = "unzip";
	} else {
	    $uncompress = "unzip -q";
	}
	$unpack = "";
    } elsif ($srcname =~ /(\.jar)$/) {
	$uncompress = "/bin/cat";
	if (not defined $opt_q) {
	    $unpack = " | jar xvf -";
	} else {
	    $unpack = " | jar xf -";
	}
    } else {
## TODO: add CVS checkout
	$uncompress = "/bin/cat";
    }

    return ($uncompress, $unpack);
}

sub find_package_by_name ($) {
    my $self = shift;
    my $name = shift;

    my $ref = $self->{_packages};
    foreach my $package (@$ref) {
	if ($package->get_tag ("name") eq $name) {
	    return $package;
	}
    }
    return undef;
}

sub _split_opts ($) {
    my $line = shift;
    my @tokens = ();

    $line =~ s/^\s*//;
    $line =~ s/\s*$//;
    while ($line ne "") {
	my $tok = "";
	while ($line =~ /^\S/) {
	    if ($line =~ /^"((\\"|[^"])*)"/) {
		$tok = "$tok$1";
		$line =~ s/^"((\\"|[^"])*)"//;
	    } elsif ($line =~ /^((\\"|[^\s"])+)/) {
		$tok = "$tok$1";
		$line =~ s/^((\\"|[^\s"])+)//;
	    } else {
		$self->_set_error ("ERROR: assertion failed: _split_opts ($line)");
	    }
	}
	$tok =~ s/\\"/"/g;
	@tokens = (@tokens, $tok);
	$line =~ s/^\s*//;
    }

    return @tokens;
}

sub _is_number($) {
    my $number = shift;

    if( $number =~ /\D/ ) {
        return 0;
    } else {
        return 1;
    }
}

# <opt def> ::=  ! <defs> | <defs>
# <defs> ::= <def> <defs> | <def>
# <def> ::= <char> | <char>: | <char>; | <char># | <char>@
# !
#   extra arguments not allowed; no ! means extra arguments are
#   saved in %macro_opts{argv<n>}  <n>=0..<argc-1>
# <char>:
#   argument required after option -<char>
# <char>;
#   argument optional after option -<char>
# <char>#
#   requires a numeric argument
# <char>@
#   option can be used multiple times, values will be separated by \n's
sub _process_macro_opts ($$$$;$$) {
    my $self = shift;
    my $opt_def = shift;
    my $line = shift;
    my $macro = shift;
    my $name = shift;
    my $package = shift;

    my %macro_opts;
    my $opt_line = $line;
    if (defined ($name)) {
	if (defined ($package)) {
	    $opt_line =~ s/\s*%$name.$package.$macro(\s*)/$1/;
	    $opt_line =~ s/\s*%{$name.$package.$macro}(\s*)/$1/;
	} else {
	    $opt_line =~ s/\s*%$name.$macro(\s*)/$1/;
	    $opt_line =~ s/\s*%{$name.$macro}(\s*)/$1/;
	}
    } else {
	$opt_line =~ s/\s*%$macro(\s*)/$1/;
	$opt_line =~ s/\s*%{$macro}(\s*)/$1/;
    }
    $macro_opts{argc} = 0;
    my @tokens = _split_opts ($opt_line);
    my $opt_name;
    while (@tokens) {
	my $token = shift (@tokens);
	if ($token =~ /^-([A-Za-z])(.*)$/) {
	    my $opt = $1;
	    my $arg0 = $2;
	    if ($opt_def =~ /$opt:/) {
		if ($arg0 ne "") {
		    $macro_opts{$opt} = $arg0;
		} else {
		    my $arg = shift (@tokens);
		    if (not defined ($arg)) {
			$self->_set_error ("need arg to %$macro $token");
			return %macro_opts;
		    }
		    $macro_opts{$opt} = $arg;
		}
	    } elsif ($opt_def =~ /$opt;/) {
		if ($arg0 ne "") {
		    $macro_opts{$opt} = $arg0;
		} else {
		    $macro_opts{$opt} = '';
		    if (defined ($tokens[0]) and
			not $tokens[0] =~ /^-\S$/) {
			my $arg = shift (@tokens);
			$macro_opts{$opt} = $arg;
		    }
		}
	    } elsif ($opt_def =~ /$opt\#/) {
		my $arg;
		if ($arg0 ne "") {
		    $arg = $arg0;
		} else {
		    $arg = shift (@tokens);
		}
		if (not defined ($arg)) {
		    $self->_set_error ("need arg to %$macro $token");
		    return %macro_opts;
		}
		if (! _is_number ($arg)) {
		    $self->_set_error ("Bad arg to %$macro $token: $arg");
		    return %macro_opts;
		}
		$macro_opts{$opt} = $arg;
	    } elsif ($opt_def =~ /$opt@/) {
		if ($arg0 ne "") {
		    $macro_opts{$opt} = $arg0;
		} else {
		    my $arg = shift (@tokens);
		    if (not defined ($arg)) {
			$self->_set_error ("need arg to %$macro $token");
			return %macro_opts;
		    }
		    if (not defined ($macro_opts{$opt})) {
			$macro_opts{$opt} = $arg;
		    } else {
			$macro_opts{$opt} .= "\n" . $arg;
		    }
		}
	    } elsif ($opt_def =~ /$opt/) {
		if ($arg0 ne "") {
		    $self->_set_error ("Bad arg to %$macro -$opt: $arg0");
		}
		$macro_opts{$opt} = '';
	    } else {
		chomp($line);
		$self->_set_error ("Bad option $token: $line");
		return %macro_opts;
	    }
	} else {
	    if (not $opt_def =~ /^!/) {
		my $argc = $macro_opts{argc}++;
		$macro_opts{"argv$argc"} = $token;
	    } else {
		$self->_set_error ("Bad arg to %$macro: $token");
		return %macro_opts;
	    }
	}
    }

    return %macro_opts
}

sub _check_class ($$) {
    my $self = shift;
    my $class_name = shift;

    if (defined ($self->{_classes}->{$class_name}->{iclass}) or
	defined ($self->{_classes}->{$class_name}->{iclass_file}) or
	defined ($self->{_classes}->{$class_name}->{rclass}) or
	defined ($self->{_classes}->{$class_name}->{rclass_file})) {
	return 1;
    }

    return 0;
}

sub _is_system_class ($) {
    my $class_name = shift;

    if ( -f "/usr/sadm/install/scripts/i.$class_name" or
	 -f "/usr/sadm/install/scripts/r.$class_name" ) {
	return 1;
    }

    return 0;
}

sub get_class_script ($$$) {
    my $self = shift;
    my $class_name = shift;
    my $script_name = shift;

    if (! $self->{_loaded} and ! $self->{_being_loaded}) {
	if (not $self->_read_spec ()) {
	    return undef;
	}
    }

    if (defined ($self->{_classes}->{$class_name})) {
	if (defined ($self->{_classes}->{$class_name}->{$script_name})) {
	    return ($self->{_classes}->{$class_name}->{$script_name});
	}
	if (defined ($self->{_classes}->{$class_name}->{"${script_name}_file"})) {
	    my $script_file = $self->eval ("%_sourcedir");
	    $script_file .= "/" . 
		$self->{_classes}->{$class_name}->{"${script_name}_file"};
	    open SCRIPT_FILE, "<$script_file" or
		$self->_set_error ("Could not open class action script file $script_file for reading"),
		return undef;
	    my @lines = <SCRIPT_FILE>;
	    close SCRIPT_FILE;
	    my $script = "";
	    map $script .= $_, @lines;
	    return $script;
	}
    }

    return undef;
}

sub _process_class_action ($$$;$$) {
    my $self = shift;
    my $fhandle = shift;
    my $line = shift;
    my $class_name = shift;
    my $macro = shift;

    if (not defined $class_name) {
	$line =~ /^%([ir]class)/;
	$macro = $1;
	my %macro_opts = $self->_process_macro_opts ('f:', $line,
						     $macro);
	if (defined ($self->{error})) {
	    return 0;
	}

	if ($macro_opts{argc} != 1) {
	    $self->_set_error ("Class name required after %$macro");
	    return 0;
	}

	$class_name = $macro_opts{argv0};

	if (not defined ($self->{_classes}->{$class_name})) {
	    $self->{_classes}->{$class_name} = {};
	} else {
	    if (defined ($self->{_classes}->{$class_name}->{$macro}) or
		defined ($self->{_classes}->{$class_name}->{"${macro}_file"})) {
		$self->_set_error ("%$macro for class $class_name multiply defined");
		return 0;
	    }
	}

	if (defined ($macro_opts{'f'})) {
	    $self->{_classes}->{$class_name}->{"${macro}_file"} = $macro_opts{'f'};
	    return 1;
	}
    }

    my $eline;
    while (1) {
	$line = $self->_get_next_line ($fhandle);
	if (not defined($line)) {
	    last;
	}
	my $eline = $self->eval ($line);
	chomp ($eline);

	if ($eline =~ /^\s*%define/) {
	    if (not $self->_process_define ($fhandle, $self->_pre_eval ($line))) {
		return (0);
	    }
	} elsif ($eline =~ /^\s*%include/) {
	    if (not $self->_process_include ($fhandle, $line, 
					     \&_process_class_action, 
					     ($class_name, $macro))) {
		return (0);
	    }
	} elsif ($eline =~ /^\s*%([a-zA-Z_][a-zA-Z0-9_]*)\.([a-zA-Z_][a-zA-Z0-9_-]*)\.(${all_block_names})/) {
	    if (defined ($self->{_specs_used}->{$1})) {
		$self->_process_macro ($1, $2, $3, $macro, $line);
	    } else {
		print "WARNING: undefined macro $line\n";
	    }
	} elsif (not $line =~ /^%(${all_keywords}|%{?)/) {
	    if (defined ($self->{_classes}->{$class_name}->{$macro})) {
		$self->{_classes}->{$class_name}->{$macro} .= "\n" . $eline;
	    } else {
		$self->{_classes}->{$class_name}->{$macro} = $eline;
	    }
	} else {
	    return $self->_process_top_level ($fhandle, $line);
	}
    }
	
    if (defined $self->{error}) {
        return 0;
    }

    return 1;
}

sub _process_macro ($$$$$$) {
    my $self = shift;
    my $name = shift;
    my $package = shift;
    my $macro = shift;
    my $block_name = shift;
    my $line = shift;

    my $macro_expansion = '';

    if (defined ($name)) {
	my $spec_used = $self->{_specs_used}->{$name};
	if (not defined $spec_used) {
	    $self->_set_error ("name $name not found. Missing %use?");
	    return 0;
	}
	my $scriptlet;

	if ($macro =~ /^(${all_script_names})$/) {
	    $pkg_ref = $$spec_used->find_package_by_name ($package);
	    if (not defined($pkg_ref)) {
		print "WARNING: subpackage not found: $name.$package\n";
	    } else {
		$scriptlet = $pkg_ref->get_block ($macro);
	    }
	} else {
	    $scriptlet = $$spec_used->get_block ($macro);
	}
	if (not defined ($scriptlet)) {
	    $scriptlet = "";
	}
	my %macro_opts = $self->_process_macro_opts ('!d:', $line,
						     $macro, $name, $package);
	if (defined ($self->{error})) {
	    return 0;
	}
	if (defined ($macro_opts{'d'})) {
	    $scriptlet = $self->eval ("cd %{_builddir}/$macro_opts{'d'}\n") .
		"${scriptlet}\ncd ..";
	}
	if ($macro eq "prep") {
	    $scriptlet = $self->eval ("cd %{_builddir}") .
		"\n$scriptlet\n";
	}
	$macro_expansion = $scriptlet;
    } else {
	if ($macro =~ /setup([0-9]*)/) {
	    my $num = $1;
	    if ($num eq "") {
		$num = 0;
	    }
	    
	    my %macro_opts = $self->_process_macro_opts ('!n:DcTqb@a@',
							 $self->eval ($line),
							 $macro, $name, $package);
	    if (defined ($self->{error})) {
		return 0;
	    }
	    my $dirname = $self->eval ("%name-%version");
	    if (defined ($macro_opts{'n'})) {
		$dirname = $macro_opts{'n'};
	    }
	    if (not defined ($self->{_defines}->{_build_src_dir_name})) {
		$self->{_defines}->{_build_src_dir_name} = $dirname;
	    }
	    $macro_expansion = "";
	    
	    if (not defined ($macro_opts{'D'})) {
		$macro_expansion = $macro_expansion . "rm -rf $dirname\n";
	    }
	    if (defined ($macro_opts{'c'})) {
		$macro_expansion = $macro_expansion . "mkdir -p $dirname\n" .
		    "cd $dirname\n";
	    } else {
		if (not defined ($macro_opts{'T'})) {
		    my $srcname = $self->eval("%SOURCE$num");
		    my $uncompress;
		    my $unpack;
		    ($uncompress, $unpack) = 
			_get_unpack_commands ($srcname, $macro_opts{'q'});
		    $macro_expansion = $macro_expansion .
			"$uncompress $srcname$unpack\n";
		    $macro_expansion = $macro_expansion .
			"STATUS=\$?\n" .
			"if [ \$STATUS -ne 0 ]; then\n" .
			"  exit \$STATUS\n" .
			"fi\n";
		}
	    }

	    if (defined $macro_opts{'b'}) {
		my @sourcenums = split /\n/, $macro_opts{'b'};
		foreach my $srcnum (@sourcenums) {
		    next if not defined $srcnum;
		    if (not _is_number ($srcnum)) {
			$self->_set_error ("Bad arg to %setup: number expected after -b");
			return 0;
		    }
		    my $srcname = $self->eval("%SOURCE$srcnum");
		    my $uncompress;
		    my $unpack;
		    ($uncompress, $unpack) = 
			_get_unpack_commands ($srcname, $macro_opts{'q'});
		    $macro_expansion = $macro_expansion .
			"$uncompress $srcname$unpack\n";
		    $macro_expansion = $macro_expansion .
			"STATUS=\$?\n" .
			"if [ \$STATUS -ne 0 ]; then\n" .
			"  exit \$STATUS\n" .
			"fi\n";
		}
	    }

	    if (not defined ($macro_opts{'c'})) {
		$macro_expansion = $macro_expansion . "cd $dirname\n";
	    } else {
		if (not defined ($macro_opts{'T'})) {
		    my $srcname = $self->eval ("%SOURCE$num");
		    my $uncompress;
		    my $unpack;
		    ($uncompress, $unpack) = 
			_get_unpack_commands ($srcname, $macro_opts{'q'});
		    $macro_expansion = $macro_expansion .
			"$uncompress $srcname$unpack\n";
		    $macro_expansion = $macro_expansion .
			"STATUS=\$?\n" .
			"if [ \$STATUS -ne 0 ]; then\n" .
			"  exit \$STATUS\n" .
			"fi\n";
		}
	    }

	    if (defined $macro_opts{'a'}) {
		@sourcenums = split /\n/, $macro_opts{'a'};
		foreach my $srcnum (@sourcenums) {
		    next if not defined $srcnum;
		    if (not _is_number ($srcnum)) {
			$self->_set_error ("Bad arg to %setup: number expected after -a");
			return 0;
		    }
		    my $srcname = $self->eval("%SOURCE$srcnum");
		    my $uncompress;
		    my $unpack;
		    ($uncompress, $unpack) = 
			_get_unpack_commands ($srcname, $macro_opts{'q'});
		    $macro_expansion = $macro_expansion .
			"$uncompress $srcname$unpack\n";
		    $macro_expansion = $macro_expansion .
			"STATUS=\$?\n" .
			"if [ \$STATUS -ne 0 ]; then\n" .
			"  exit \$STATUS\n" .
			"fi\n";
		}
	    }
	    if ($os eq "solaris") {
		$macro_expansion = $macro_expansion . 
		    "[ `/usr/xpg4/bin/id -u` = 0 ] && /bin/chown -Rhf root .\n";
		$macro_expansion = $macro_expansion .
		    "[ `/usr/xpg4/bin/id -u` = 0 ] && /bin/chgrp -Rhf other .\n";
	    } else {
		$macro_expansion = $macro_expansion . 
		    "[ `/usr/bin/id -u` = 0 ] && /bin/chown -Rhf root .\n";
		$macro_expansion = $macro_expansion .
		    "[ `/usr/bin/id -u` = 0 ] && /bin/chgrp -Rhf root .\n";
	    }
	    $macro_expansion = $macro_expansion .
		"/bin/chmod -Rf a+rX,g-w,o-w .\n";
	} elsif ($macro =~ /^patch([0-9]*)/) {
	    my $pnum = $1;
	    my %macro_opts = $self->_process_macro_opts ('!P#p#Eb:', $line,
							 $macro, $name, $package);
	    if (defined ($self->{error})) {
		return 0;
	    }
	    my $num = $macro_opts{'P'};
	    if (not defined($num) or $num eq "") {
		if (not defined ($pnum)) {
		    $num = 0;
		} else {
		    $num = $pnum;
		}
	    }
	    if ($num eq "") {
		$num = 0;
	    }
	    my $package_ref = $self->{_packages}[0];
	    my @values = $package_ref->get_array ('patch');

	    my $val = $values[$num];
	    if (not defined ($val)) {
		$self->_set_error ("ERROR: no such patch: Patch$num");
		return 0;
	    }
	    $val =~ s/^.*\/([^\/]*)/$1/;

	    my $uncompress;
	    if ($val =~ /\.bz2$/) {
		$uncompress = "bzip2 -d < $val";
	    } elsif ($val =~ /\.(gz|zip)$/) {
		$uncompress = "gzip -d < $val";
	    }
	    
	    my $patch_opts = '';
	    if (defined ($macro_opts{'p'})) {
		$patch_opts = $patch_opts . " -p $macro_opts{'p'}";
	    } else {
		$patch_opts = $patch_opts . " -p 0";
	    }
	    if (defined ($macro_opts{'E'})) {
		$patch_opts = $patch_opts . " -E";
	    }
	    if (defined ($macro_opts{'b'})) {
		$patch_opts = $patch_opts . " -b -z $macro_opts{'b'}";
	    }
	    $macro_expansion = "echo 'Patch #$num ($val):'\n";
	    if (not defined ($uncompress)) {
		    $macro_expansion .= $self->eval(
			"patch $patch_opts < %{_sourcedir}/$val");
	    } else {
		    $macro_expansion .= 
			"$uncompress | patch $patch_opts";
	    }

	    $macro_expansion = $self->eval ("$macro_expansion");
	}
    }

    $self->_append_to_block($block_name, $macro_expansion);
}

sub _process_block ($$$;$$) {
    my $self = shift;
    my $fhandle = shift;
    my $line = shift;
    my $block_name = shift;
    my $package_name = shift;

    my $package_ref = $self->{_packages}[0];
    if (not defined ($block_name) or not defined($package_name)) {
	
	$line =~ /^\s*%([a-z]*)/;
	$block_name = $1;

	if ($line =~ /^\s*%$block_name\s+-n\s+(\S+)\s*$/) {
	    $package_name = $1;
	} elsif ($line =~ /^\s*%$block_name\s+(\S+)\s*$/) {
	    $package_name = $package_ref->get_name() . "-" . $1;
	} else {
	    $package_name = $package_ref->get_name();
	}
    }

    if (not $block_name =~ /(changelog|[ir]class|prep|build|install|clean)/) {
	$package_ref = undef;
	my $all_packages = $self->{_packages};
	foreach $package (@$all_packages) {
	    my $pkgname = $package->get_name ();
	    if (defined $pkgname and $pkgname eq $package_name) {
		$package_ref = $package;
	    }
	}
	
	if (not defined ($package_ref)) {
	    $self->_set_error ("Package $package_name not defined in $line");
	    return 0;
	}
    }

    if (not defined $self->{_blocks}->{$block_name}) {
	if ($block_name =~ /(build|install|clean)/) {
	    my $dirname = $self->eval ("%{_build_src_dir_name}");
	    if ($dirname eq "%{_build_src_dir_name}") {
		$dirname = $self->eval ("%name-%version");
	    }
	    $self->{_blocks}->{$block_name} = "cd $dirname\n";
	} else {
	    $self->{_blocks}->{$block_name} = "";
	}
    }

    my $eline;

    while (1) {
	$line = $self->_get_next_line ($fhandle);
	if (not defined($line)) {
	    last;
	}
	my $eline = $self->eval ($line);
	chomp ($eline);

	if ($eline =~ /^\s*%define/) {
	    if (not $self->_process_define ($fhandle, $self->_pre_eval ($line))) {
		return (0);
	    }
	} elsif ($eline =~ /^\s*%include/) {
	    if (not $self->_process_include ($fhandle, $line, 
					     \&_process_block, 
					     ($block_name, $package_name))) {
		return (0);
	    }
	} elsif ($eline =~ /^\s*%(setup[0-9]*)/) {
	    $self->_process_macro (undef, undef, $1, $block_name, $line);
	} elsif ($eline =~ /^\s*%(patch[0-9]*)/) {
	    $self->_process_macro (undef, undef, $1, $block_name, $line);
	} elsif ($eline =~ /^\s*%([a-zA-Z_][a-zA-Z0-9_]*)\.(${all_block_names})/) {
	    if (defined ($self->{_specs_used}->{$1})) {
		$self->_process_macro ($1, undef, $2, $block_name, $line);
	    } else {
		print "WARNING: undefined macro $line\n";
	    }
	} elsif ($eline =~ /^\s*%([a-zA-Z_][a-zA-Z0-9_]*)\.([a-zA-Z_][a-zA-Z0-9_-]*)\.(${all_block_names})/) {
	    if (defined ($self->{_specs_used}->{$1})) {
		$self->_process_macro ($1, $2, $3, $block_name, $line);
	    } else {
		print "WARNING: undefined macro $line\n";
	    }
	} elsif (not $line =~ /^%(${all_keywords}|%{?)/) {
	    if ($block_name =~ /(prep|build|install|clean|changelog)/) {
		$self->_append_to_block ($block_name, $eline);
	    } else {
		$package_ref->append_to_block ($block_name, $eline);
	    }
	} else {
	    return $self->_process_top_level ($fhandle, $line);
	}
    }

    if (defined $self->{error}) {
	return 0;
    }

    return 1;
}

sub load_metafile ($$$) {
    my $self = shift;
    my $fname = shift;
    my $package_name = shift;
    
    my $mf_fhandle = "SPEC_FILE" . $file_id++;
    my $builddir = $self->eval ("%{_builddir}");
    my $dirname = $self->eval ("%{_build_src_dir_name}");
    if ($dirname eq "%{_build_src_dir_name}") {
	$dirname = $self->eval ("%name-%version");
    }
    open $mf_fhandle, "<$builddir/$dirname/$fname" or
	$self->{error} = "Could not open %files file $builddir/$dirname/$fname for reading",
	return (0);
    $_file_names{$mf_fhandle} = "$fname";
    return $self->_process_files ($mf_fhandle, undef, $package_name);
}

sub _process_files ($$$;$) {
    my $self = shift;
    my $fhandle = shift;
    my $line = shift;
    my $package_name = shift;

    my $package_ref;

    if (defined $line) {
	my %macro_opts = $self->_process_macro_opts ('n:f@', $line, "files");
	if (defined ($self->{error})) {
	    return 0;
	}
	if (($macro_opts{'argc'} > 1) or
	    (defined ($macro_opts{'n'}) and ($macro_opts{'argc'} > 0))) {
	    $self->_set_error ("Too many names: $line", $fhandle);
	    return 0;
	}
	$package_ref = $self->{_packages}[0];
	if (not defined($package_name)) {
	    if (defined ($macro_opts{'n'})) {
		$package_name = $macro_opts{'n'};
	    } elsif (defined ($macro_opts{'argv0'})) {
		$package_name = $package_ref->get_name() . "-" . 
		    $macro_opts{'argv0'};
	    } else {
		$package_name = $package_ref->get_name();
	    }
	}
	$package_ref = undef;
	$package_ref = $self->find_package_by_name ($package_name);
	if (defined ($macro_opts{"f"}) and defined ($package_ref)) {
	    my @metafiles = split /\n/, $macro_opts{"f"};
	    foreach my $mf (@metafiles) {
		$package_ref->add_metafile ($mf);
	    }
	}
    } else {
	if (not defined ($package_name)) {
	    $self->_set_error ("assertion failed: _process_files: \$line or \$package_name must be defined");
	    return 0;
	}
	$package_ref = $self->find_package_by_name ($package_name);
    }

    if (not defined ($package_ref)) {
	$self->_set_error ("Undefined package $package_name", $fhandle);
	return 0;
    }

    $package_ref->add_file (undef);  # initialise so that an empty pkg
	                             # is created even if no files in %files
    my @defattr = $package_ref->get_defattr ();
    my @all_verify = rpm_file->get_all_verify ();

    my @this_attr = (@defattr);
    my $is_doc = 0;
    my $is_config = 0;
    my @this_verify = (@all_verify);
    my $is_dir = 0;
    my $class_name = "none";

    $line = $self->_get_next_line ($fhandle);
    if (not defined($line)) {
	if (defined $self->{error}) {
	    return 0;
	}

	return 1;
    }
    my $eline = $self->_preprocess_line ($line);
 
    while (1) {
	if ($eline =~ /^$/) {
	    # ignore empty lines
	} elsif ($eline =~ /^#/) {
	    # comment, skip to next line
	} elsif ($eline =~ /^\s*%define/) {
	    if (not $self->_process_define ($fhandle, $self->_pre_eval ($line))) {
		return (0);
	    }
	} elsif ($eline =~ /^\s*%include/) {
	    $self->_set_error ("%include not allowed within %files", $fhandle);
	} elsif ($eline =~ /^\s*%defattr/) {
	    if ($eline =~ /^%defattr\s*\(\s*(-|\?|[0-9]+)\s*,\s*(-|\?|[a-zA-Z0-9][a-zA-Z0-9_-]*)\s*,\s*(-|\?|[a-zA-Z0-9][a-zA-Z0-9_-]*)\s*\)\s*$/) {
		my $mod = $1;
		my $usr = $2;
		my $grp = $3;
		if (_is_number ($usr) or _is_number ($grp)) {
		    $self->_set_error ("%defattr: user and group must be symbolic, not numeric", $fhandle);
		    return (0);
		}
		@defattr = ($mod, $usr, $grp);
		$package_ref->set_defattr ($mod, $usr, $grp);
	    } else {
		$self->_set_error ("syntax error: $line", $fhandle);
		return (0);
	    }
	} elsif ($eline =~ /^\s*%doc/) {
	    $is_doc = 1;
	    $eline =~ s/^\s*%doc\s*//;
# FIXME: should process %doc stuff properly...
#	    next;
	} elsif ($eline =~ /^\s*%ghost/) {
# FIXME: what shall we do with ghosts on Solaris??
#
	    $eline =~ s/^\s*%ghost\s*//;
	} elsif ($eline =~ /^\s*%config/) {
	    $is_config = 1;
	    $eline =~ s/^\s*%config\s*\([^)]*\)\s*// or
		$eline =~ s/^\s*%config\s*//;
	    next;	    
	} elsif ($eline =~ /^\s*%attr\s*\(\s*(-|\?|[0-9]+)\s*,\s*(-|\?|[a-zA-Z][a-zA-Z0-9_-]*)\s*,\s*(-|\?|[a-zA-Z][a-zA-Z0-9_-]*)\s*\)\s*/) {
	    @this_attr = ($1, $2, $3);
	    $eline =~ s/^\s*%attr\s*\([^\)]*\)\s*//;
	    next;
	} elsif ($eline =~ /^\s*%verify\s*\(([^\)]*)\)/) {
	    @this_verify = split /\s+/, $1;
	    $eline =~ s/^\s*%verify\s*\([^\)]*\)//;
	    next;
	} elsif ($eline =~ /^\s*%class\s*\(([^\)]*)\)/) {
	    $class_name = $1;
	    if (not $self->_check_class ($class_name)) {
		if (_is_system_class ($class_name)) {
		    $self->_use_system_class ($class_name);
		} else {
		    $self->_set_error ("Undefined class $class_name: $class_name",
				       $fhandle);
		    return 0;
		}
	    }
	    $eline =~ s/^\s*%class\s*\([^\)]*\)//;
	    next;
	} elsif ($eline =~ /^\s*%docdir/) {
	    $is_doc = 1;
	    $is_dir = 1;
	    $eline =~ s/^\s*%docdir\s*//;
	    next;
	} elsif ($eline =~ /^\s*%dir/) {
	    $is_dir = 1;
	    $eline =~ s/^\s*%dir\s*//;
	    next;
	} elsif ($eline =~ /^\s*(\/.*\S)\s*$/) {
	    my $file = rpm_file->new ($1, \@this_attr, \@this_verify,
				     not ($is_dir), $is_doc,
				     $is_config, $class_name);
	    $package_ref->add_file ($file);
	} elsif ($eline =~ /^\s*([A-Za-z0-9]\S*)/) {
	    $self->_set_error ("File must begin with \"/\": $1", $fhandle);
	    return 0;
	} else {
	    return $self->_process_top_level ($fhandle, $line);
	}

	@this_attr = (@defattr);
	$is_doc = 0;
	$is_config = 0;
	@this_verify = (@all_verify);
	$is_dir = 0;
        $class_name = "none";

	$line = $self->_get_next_line ($fhandle);
	if (not defined($line)) {
	    last;
	}
	$eline = $self->_preprocess_line ($line);
    }

    if (defined $self->{error}) {
	return 0;
    }

    return 1;
}

sub _process_top_level ($$$) {
    my $self = shift;
    my $fhandle = shift;
    my $line = shift;

    $line = $self->_get_next_line ($fhandle) if not defined ($line);
    
    while (1) {
	my $eline = $self->eval ($line);

	if ($eline =~ /^\s*#/) {
	    # comment, nothing to do.
	} elsif ($eline =~ /^\s*$/) {
	    # whitespace only
	} elsif ($eline =~ /^%use/) {
	    $self->_process_use ($fhandle, $line) or return 0;
	} elsif ($eline =~ /^%include/) {
	    $self->_process_include ($fhandle, $line, \&_process_top_level, ())
		or return 0;
	} elsif ($eline =~ /^%package/) {
	    $self->_process_package ($fhandle, $line) or return 0;
	} elsif ($eline =~ /^%[ir]class/) {
	    $self->_process_class_action ($fhandle, $line) or return 0;
	} elsif ($eline =~ /^%(description|${all_block_names})/) {
	    $self->_process_block ($fhandle, $line) or return 0;
	} elsif ($eline =~ /^%files/) {
	    $self->_process_files ($fhandle, $line) or return 0;
	} elsif ($eline =~ /^\s*%define/) {
	    $self->_process_define ($fhandle, $self->_pre_eval ($line))
		or return 0;
	} elsif ($eline =~ /^\s*\S+\s*:\s*\S+/) {
	    $self->_process_tag ($fhandle, $eline) or return 0;
	} else {
	    $self -> _set_error ("syntax error", $fhandle);
	    return 0;
	}
	if (defined $self->{error}) {
	    return 0;
	}
	$line = $self->_get_next_line ($fhandle);
	return(1) if not $line;
    }
    $self->_set_error ("assertion failed in _process_top_level()", $fhandle);
    return (0);
}

sub _read_spec ($) {
    my $self = shift;

    my $fhandle = "SPEC_FILE" . $file_id++;
    my $fname = $self->{_file_name};

    open $fhandle, "<$fname" or 
	$self->{error} = "Could not open file $fname for reading",
	return (0);
    $_file_names{$fhandle} = $self->{_base_file_name};

    my $line;

    $self->{_being_loaded} = 1;
    $self->{_current_package} = $self->{_packages}[0];

    while (1) {
	$line = $self->_get_next_line ($fhandle);
	if (not defined ($line)) {
	    last;
	}
	if (not $self->_process_top_level ($fhandle, $line)) {
	    $self->{_being_loaded} = 0;
	    $self->{_loaded} = 1;
	    return (0);
	}
    }

    close $fhandle;

    $self->{_current_package} = $self->{_packages}[0];
    $self->{_being_loaded} = 0;
    $self->{_loaded} = 1;

    if (defined $self->{error}) {
	return 0;
    }

    if ($self->{_in_conditional} > 0) {
	$self->{error} = "Unclosed %if";
	return 0;
    }

    if ($os eq "solaris") {
	my $pkg_name = $self->get_value_of ("sunw_pkg");
	$pkg_name = $self->get_name () unless defined $pkg_name;
	if (length($pkg_name) > 32) {
	    $self->{error} = "Package name $src_pkg_name is too long (>32 chars)";
	    return 0;
	}

	my $src_pkg_name = $self->get_value_of ("sourcepackage");
	$src_pkg_name = "${pkg_name}-src" if not defined $src_pkg_name;
	if (length($src_pkg_name) > 32) {
	    $self->{error} = "Source package name $src_pkg_name is too long (>32 chars), use the SourcePackage tag to define a different source package name";
	    return 0;
	}	
    }

    return (1);
}

sub get_name ($) {
    my $self = shift;

    if (! $self->{_loaded} and ! $self->{_being_loaded}) {
	if (not $self->_read_spec ()) {
	    return undef;
	}
    }

    my $package = $self->{_packages}[0];
    my $name = $package->get_tag ("name");
    if (not defined ($name)) {
	return $self->{_base_file_name};
    }
    return $name;
}

sub get_packages ($) {
    my $self = shift;

    if (! ($self->{_loaded} or $self->{_being_loaded})) {
	if (not $self->_read_spec ()) {
	    return ();
	}
    }

    my $ref = $self->{_packages};
    return @$ref;
}

sub block_is_defined ($$) {
    my $self = shift;
    my $block_name = shift;

    if (! $self->{_loaded} and ! $self->{_being_loaded}) {
	if (not $self->_read_spec ()) {
	    return undef;
	}
    }

    return defined ($self->{_blocks}->{$block_name});
}

sub _append_to_block ($$$) {
    my $self = shift;
    my $block_name = shift;
    my $text_to_append = shift;

    if (defined ($self->{_blocks}->{$block_name})) {
	$self->{_blocks}->{$block_name} = 
	    $self->{_blocks}->{$block_name} . "\n" . $text_to_append;
    } else {
	$self->{_blocks}->{$block_name} = $text_to_append;
    }
}

sub get_block ($$) {
    my $self = shift;
    my $block_name = shift;

    if (! $self->{_loaded} and ! $self->{_being_loaded}) {
	if (not $self->_read_spec ()) {
	    return undef;
	}
    }

    return $self->{_blocks}->{$block_name};
}

sub get_file_name ($) {
    my $self = shift;

    return $self->{_file_name};
}

sub get_base_file_name ($) {
    my $self = shift;
    
    return $self->{_base_file_name};
}

sub get_rpms ($) {
    my $self = shift;

    my @packages = $self->get_packages ();
    return if defined $self->{error};
    my @rpms = ();
    foreach my $pkg (@packages) {
	next if not $pkg->has_files ();
	my $pkg_arch = $pkg->get_tag ("buildarch");
	if (not defined ($pkg_arch)) {
	    $pkg_arch = $pkg->get_tag ("buildarchitectures");
	}
	push (@rpms, $pkg->get_name() . "-" . $pkg->get_tag ("version") . 
	      "-" . $pkg->get_tag ("release") . "." .
	      $pkg_arch . ".rpm");
    }

    return @rpms;
}

sub get_rpm_paths ($) {
    my $self = shift;

    my @packages = $self->get_packages ();
    return if defined $self->{error};
    my @rpms = ();
    foreach my $pkg (@packages) {
	next if not $pkg->has_files ();
	my $pkg_arch = $pkg->get_tag ("buildarch");
	if (not defined ($pkg_arch)) {
	    $pkg_arch = $pkg->get_tag ("buildarchitectures");
	}
	push (@rpms, $self->get_value_of ("_rpmdir") . "/" . 
	      $pkg_arch . "/" .
	      $pkg->get_name() . "-" . $pkg->get_tag ("version") . 
	      "-" . $pkg->get_tag ("release") . "." .
	      $pkg_arch . ".rpm");
    }

    return @rpms;
}

sub get_pkgs ($) {
    my $self = shift;

    my @packages = $self->get_packages ();
    return if defined $self->{error};
    my @pkgs = ();
    foreach my $pkg (@packages) {
	next if not $pkg->has_files ();
	my $sunw_pkg = $pkg->get_tag ('sunw_pkg');
	if (defined ($sunw_pkg)) {
	    push (@pkgs, $sunw_pkg);
	} else {
	    push (@pkgs, $pkg->get_name());
	}
    }

    return @pkgs;
}

sub get_package_names ($) {
    my $self = shift;
    return $self->get_pkgs ();
}

sub get_value_of ($$) {
    my $self = shift;
    my $name = shift;

    if ($name =~ /^(${all_keywords}|)$/) {
	return undef;
    }
    if (! $self->{_loaded} and ! $self->{_being_loaded}) {
	if (not $self->_read_spec ()) {
	    return undef;
	}
    }

    if ($name eq "buildroot") {
	my $parent = $self->{_parent_spec};
	if (defined $parent) {
	    my $br = $parent->get_value_of ("buildroot");
	    if (defined $br) {
		return $br;
	    }
	}
    }

    my $package_ref = $self->{_packages}[0];
    if (defined ($package_ref) and $package_ref->tag_is_defined ($name)) {
	return $package_ref->get_tag ($name);
    } elsif ($name =~ /^(SOURCE|PATCH)([0-9]*)$/) {
	my $num = $2;
	my $source_or_patch = lc($1);
	if (not defined ($num) or ($num eq "")) {
	    $num = 0;
	}
	my @values = $package_ref->get_array ($source_or_patch);
	my $val = $values[$num];
	return undef unless defined $val;
	$val =~ s/^.*\/([^\/]*)/$1/;
	return "%{_sourcedir}/$val";
    } else {
	return $self->eval ($self->{_defines}->{$name});
    }
}

sub get_def ($$) {
    my $self = shift;
    my $name = shift;
    my $lcname = lc ($name);

    if (! $self->{_loaded} and ! $self->{_being_loaded}) {
	if (not $self->_read_spec ()) {
	    return undef;
	}
    }

    return $self->{_defines}->{$name};
}

sub get_sources ($) {
    my $self = shift;

    if (! $self->{_loaded} and ! $self->{_being_loaded}) {
	if (not $self->_read_spec ()) {
	    return undef;
	}
    }

    my $package_ref = $self->{_packages}[0];
    my @values = $package_ref->get_array ('source');
    my $specs_used = $self->{_specs_used};
    my @spec_names_used = keys %$specs_used;
    foreach my $spec_name_used (@spec_names_used) {
	my $spec_used = $self->{_specs_used}->{$spec_name_used};
	my @sources_used = $$spec_used->get_sources ();
	push (@values, @sources_used);
    }
    return _uniq (@values);
}

sub get_public_sources ($) {
    my $self = shift;

    if (! $self->{_loaded} and ! $self->{_being_loaded}) {
	if (not $self->_read_spec ()) {
	    return undef;
	}
    }

    my $package_ref = $self->{_packages}[0];
    my @values = ($package_ref->get_array ('source'));
    my $nosrc = $package_ref->get_tag ("nosource");
    if (defined $nosrc) {
	my @nosrcs = split /[,\s]*/, $nosrc;
	foreach my $nosrcid (@nosrcs) {
	    next if not defined $nosrcid;
	    $values[$nosrcid] = undef;
	}
    }
    my $specs_used = $self->{_specs_used};
    my @spec_names_used = keys %$specs_used;
    foreach my $spec_name_used (@spec_names_used) {
	my $spec_used = $self->{_specs_used}->{$spec_name_used};
	my @sources_used = $$spec_used->get_public_sources ();
	push (@values, @sources_used);
    }
    return _uniq (@values);
}

sub get_patches ($) {
    my $self = shift;

    if (! $self->{_loaded} and ! $self->{_being_loaded}) {
	if (not $self->_read_spec ()) {
	    return undef;
	}
    }

    my $package_ref = $self->{_packages}[0];
    my @values = $package_ref->get_array ('patch');
    my $specs_used = $self->{_specs_used};
    my @spec_names_used = keys %$specs_used;
    foreach my $spec_name_used (@spec_names_used) {
	my $spec_used = $self->{_specs_used}->{$spec_name_used};
	my @patches_used = $$spec_used->get_patches ();
	push (@values, @patches_used);
    }
    return _uniq (@values);
}

sub get_public_patches ($) {
    my $self = shift;

    if (! $self->{_loaded} and ! $self->{_being_loaded}) {
	if (not $self->_read_spec ()) {
	    return undef;
	}
    }

    my $package_ref = $self->{_packages}[0];
    my @values = ($package_ref->get_array ('patch'));
    my $noptch = $package_ref->get_tag ("nopatch");
    if (defined $noptch) {
	my @noptchs = split /[,\s]*/, $noptch;
	foreach my $noptchid (@noptchs) {
	    next if not defined $noptchid;
	    $values[$noptchid] = undef;
	}
    }
    my $specs_used = $self->{_specs_used};
    my @spec_names_used = keys %$specs_used;
    foreach my $spec_name_used (@spec_names_used) {
	my $spec_used = $self->{_specs_used}->{$spec_name_used};
	my @patches_used = $$spec_used->get_public_patches ();
	push (@values, @patches_used);
    }
    return _uniq (@values);
}

sub get_classes ($) {
    my $self = shift;
    if (! $self->{_loaded} and ! $self->{_being_loaded}) {
	if (not $self->_read_spec ()) {
	    return undef;
	}
    }

    my @classes = keys %{$self->{_classes}};
    return @classes;
}

sub _use_system_class ($$) {
    my $self = shift;
    my $class_name = shift;

    if ( -f "/usr/sadm/install/scripts/i.$class_name" or
	 -f "/usr/sadm/install/scripts/r.$class_name" ) {
	$self->{_classes}->{$class_name} = "system";
    } else {
	$self->_set_error ("Unknown system class: $class_name");
    }
}

sub get_class_script_names ($) {
    my $self= shift;
    my @scripts;

    if (! $self->{_loaded} and ! $self->{_being_loaded}) {
	if (not $self->_read_spec ()) {
	    return undef;
	}
    }

    foreach my $class_name (keys %{$self->{_classes}}) {
	if (defined ($self->{_classes}->{$class_name}->{iclass_file})) {
	    push (@scripts, 
		  $self->{_classes}->{$class_name}->{iclass_file});
	}
	if (defined ($self->{_classes}->{$class_name}->{rclass_file})) {
	    push (@scripts, 
		  $self->{_classes}->{$class_name}->{rclass_file});
	}
    }

    return @scripts;
}

sub _uniq (@) {
    my @arr = @_;

    my %h;

    foreach my $elem (@arr) {
	next if not defined $elem;
	$h{$elem} = 1;
    }
    return keys %h;
}

sub get_included_files ($) {
    my $self = shift;
    my $incref=$self->{_includes};
    my @includes = @$incref;

    if (! $self->{_loaded} and ! $self->{_being_loaded}) {
	if (not $self->_read_spec ()) {
	    return undef;
	}
    }

    foreach $used_spec_name (keys %{$self->{_specs_used}}) {
	next if not defined $used_spec_name;
	my $used_spec = $self->{_specs_used}->{$used_spec_name};
	my @more_includes = $$used_spec->get_included_files ();
	if (@more_includes) {
	    push (@includes, @more_includes);
	}
    }
    return _uniq (@includes);
}

sub get_used_spec_files ($) {
    my $self = shift;

    if (! $self->{_loaded} and ! $self->{_being_loaded}) {
	if (not $self->_read_spec ()) {
	    return undef;
	}
    }

    my @used_specs;
    foreach $used_spec_name (keys %{$self->{_specs_used}}) {
	next if not defined $used_spec_name;
	my $used_spec = $self->{_specs_used}->{$used_spec_name};
	push (@used_specs, $$used_spec->get_file_name ());
	my @more_used_specs = $$used_spec->get_used_spec_files ();
	if (@more_used_specs) {
	    push (@used_specs, @more_used_specs);
	}
    }
    return _uniq (@used_specs);
}

sub get_default_topdir () {
    return $_default_topdir;
}

sub get_error ($) {
    my $self = shift;

    if (defined $self->{error}) {
	return $self->{error};
    } else {
	return "No error.";
    }
}

init();
1;
