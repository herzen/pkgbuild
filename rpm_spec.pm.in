@WARNING_MESSAGE_L1@
@WARNING_MESSAGE_L2@
@WARNING_MESSAGE_L3@
@WARNING_MESSAGE_L4@
@WARNING_MESSAGE_L5@
@WARNING_MESSAGE_L6@
@WARNING_MESSAGE_L7@

#
#  The pkgbuild build engine
#
#  Copyright (c) 2004, 2010, Oracle and/or its affiliates. All rights reserved.
#
#  pkgbuild is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License 
#  version 2 published by the Free Software Foundation.
#
#  pkgbuild is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#  General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
#  As a special exception to the GNU General Public License, if you
#  distribute this file as part of a program that contains a
#  configuration script generated by Autoconf, you may include it under
#  the same distribution terms that you use for the rest of that program.
#
#  Authors:  Laszlo Peter  <laca@sun.com>
#

#use strict;

use warnings;
use rpm_package;
use rpm_file;
use packagebase;

package rpm_spec;

sub get_name ($);

use overload ('""' => \&get_name);	  

my %all_archs;
my $arch;
my $os;
my $os_rel;
my $logname = $ENV{USER} || $ENV{LOGNAME} || `logname`;
chomp ($logname);
my %default_macros;

my $_homedir = $ENV{HOME};
my $_default_topdir = "${_homedir}/packages";
my $_topdir = $_default_topdir;
my $_pkgbuild_libdir = "@PKGBUILD_LIBDIR@";

# items in this list should not be prefixes of items later in the same list
# i.e. pre|preun wrong,  preun|pre good.
my $all_script_names = "preun|postun|pre|post|verifyscript|triggerin|triggerun|triggerpostun|check";
my $all_block_names = "prep|build|install|clean|check|changelog|$all_script_names";
my $all_keywords = "$all_block_names|define|patch|setup|files|description|package|iclass|rclass|use|actions";

sub get_version () {
    my $version = "@PKGBUILD_VERSION@";
    return $version;
}

sub set_target($) {
    my $target = shift;
    %all_archs = ( $target, 1 );
    $arch = $target;
}

sub _init () {
    $arch = `uname -p`;
    chomp ($arch);
    if ($arch eq "unknown") {
	$arch = `uname -m`;
	chomp ($arch);
	if ($arch eq 'i586') {
	    $arch = 'i386';
	} elsif ($arch eq 'i686') {
	    $arch = 'i386';
	}
    }
    $all_archs{$arch} = 1;

    $os = `uname -s`;
    chomp ($os);
    $os = lc ($os);
    $os_rel = `uname -r`;
    chomp ($os_rel);
    if ($os eq 'sunos') {
	if ($os_rel =~ /^5\./) {
	    $os = 'solaris';
	}
    }

    # get list of supported architectures, used for %ifarch
    if ($os eq "solaris") {
	my $isainfo = `/usr/bin/isainfo`;
	chomp ($isainfo);
	my @isas = split / /, $isainfo;
	foreach my $isa (@isas) {
	    next if not defined $isa;
	    $all_archs{$isa} = 1;
	}
    }

    my $uid;
    if (-x "/usr/xpg4/bin/id") {
	$uid = `/usr/xpg4/bin/id -u`;
	chomp ($uid);
    } else {
	$uid = `LC_ALL=C /usr/bin/id`;
	chomp ($uid);
	$uid =~ s/^[^=]+=([0-9]+)\(.*$/$1/;
    }

    if ($uid eq (getpwnam($logname))[2]) {
	$_homedir = (getpwnam($logname))[7];
    } else {
	# logname is incorrect, look up the uid
	$logname = (getpwuid($uid))[0];
	$_homedir = (getpwuid($uid))[7];
    }

    _read_macros ('@PKGBUILD_LIBDIR@/macros');
    if (-f "${_homedir}/.pkgbuildmacros") {
	_read_macros ("${_homedir}/.pkgbuildmacros");
    }

    # FIXME: should really be mkdir_p %{tmppath}
    `mkdir -p /var/tmp/pkgbuild-${logname}`;
}

# Create a new rpm_spec object.
# Return undef if the spec_file is not found
# args:
#   spec_file:   name of the spec file to read
#   predef_ref:  reference to a list of 'name value' strings
#                which are macros defined outside the spec file
#                (typically on the command line)
#   parent_spec: reference to an rpm_spec object; used when spec_file
#                is %use'd by the parent_spec
sub new ($;$$) {
    my $class = shift;
    my $spec_file = shift;
    my $predef_ref = shift;
    my $parent_spec = shift;
    my $self = {};
    
    if (! -r $spec_file) {
	return (undef);
    }
    
    if (not $spec_file =~ /^\//) {
	my $current_dir=`pwd`;
	chomp ($current_dir);
	$spec_file = "$current_dir/$spec_file";
    }

    if ((not defined ($predef_ref) or not @$predef_ref) and
	not defined $parent_spec) {
	# the packagebase is a singleton object that represents all
	# rpm_spec objects created by the running script
	my $packagebase = new packagebase ();
	my $spec = $packagebase->find_spec_by_file_name ($spec_file);
	if (defined ($spec)) {
	    return ($spec);
	}
    }

    $self->{_file_name} = $spec_file;
    my $base_file_name = $spec_file;
    $base_file_name =~ s/^.*\/([^\/]*)$/$1/;
    $self->{_base_file_name} = $base_file_name;
    # _loaded set to 1 when the spec file is fully loaded
    $self->{_loaded} = 0;
    # _being_loaded set to 1 while being loaded to avoid infinite recursion
    $self->{_being_loaded} = 0;
    # _defines is an associative array of name value pairs
    $self->{_defines} = {};
    # _specs_used is an associative array of names of %use'd spec files
    # and references to the corresponding rpm_spec objects.
    # note: the parent_spec of those rpm_spec objects will be this rpm_spec
    $self->{_specs_used} = {};
    # blocks are multiple line sections of a spec file, e.g. %description,
    # %prep, %build, %install, %pre, %post, %changelog...
    $self->{_blocks} = {};
    # _classes assignes i/r class actions scripts to  pkgmap object classes
    # names
    $self->{_classes} = {};
    # spec file processing is inside a %if*... %endif conditional
    $self->{_in_conditional} = 0;
    # parent rpm_spec, if this rpm_spec is %use'd
    $self->{_parent_spec} = $parent_spec;
    # ref to a list of files %include'd (needed for source packages, etc)
    my @inc;
    $self->{_includes} = \@inc;

    if (defined ($parent_spec)) {
        # if this is a %use'd rpm_spec inherit the macros from the parent
	my $parent_def_ref = $parent_spec->{_defines};
	$self->{_defines} = {%$parent_def_ref};
	delete ($self->{_defines}->{_build_src_dir_name});
    } else {
	# fill with values read from the macros file in _read_macros()
	$self->{_defines} = {%default_macros};
    }

    # process predefined macros (those defined on the command line
    # with --define or --with-foo, etc...)
    if (defined ($predef_ref)) {
	foreach my $predef (@$predef_ref) {
	    next if not defined $predef;
	    if ($predef =~ /^\s*([a-zA-Z0-9_]*)\s+(.*\S)\s*$/) {
		$self->{_defines}->{$1} = $2;
	    } else {
		$self->{error} = "invalid definition $predef";
	    }
	}
    }
    
    bless ($self, $class);
    my $main_package = rpm_package->new (\$self);
    my @packages = ($main_package);
    $self->{_packages} = \@packages;

    # rpm_spec's that are not child specs and don't have predefines
    # are added to the packagebase for reuse.
    if ((not defined ($predef_ref) or not @$predef_ref) and
	not defined $parent_spec) {
	my $packagebase = new packagebase ();
	$packagebase->add_package ($main_package);
	$packagebase->add_spec ($self);
    }

    return $self;
}

# read defaults from the macros file
sub _read_macros ($) {
    my $fname = shift;

    $default_macros{__logname} = $logname;
    $default_macros{__homedir} = ${_homedir};
    $default_macros{__pkgbuild_libdir} = '@PKGBUILD_LIBDIR@';
    if (not open MACROS, "<$fname") {
	print "WARNING: Could not open macros file $fname for reading.\nWill use hardcoded defaults.\n";
	# fallback default macros
	$default_macros{_pkgbuild} = 'pkgbuild';
	$default_macros{_is_pkgbuild} = '1';
	$default_macros{_pkgbuild_version} = '@PKGBUILD_VERSION@';
	$default_macros{buildroot} = "/";
	$default_macros{_target} = "$arch";
	$default_macros{_sysconfdir} = "/etc";
	$default_macros{_initrddir} = "%{_sysconfdir}/rc.d/init.d";
	$default_macros{_prefix} = "/usr";
	$default_macros{_exec_prefix} = "%{_prefix}";
	$default_macros{_bindir} = "%{_exec_prefix}/bin";
	$default_macros{_lib} = "lib";
	$default_macros{_libdir} = "%{_exec_prefix}/%{_lib}";
	$default_macros{_libexecdir} = "%{_exec_prefix}/libexec";
	$default_macros{_sbindir} = "%{_exec_prefix}/sbin";
	$default_macros{_sharedstatedir} = "%{_prefix}/com";
	$default_macros{_datadir} = "%{_prefix}/share";
	$default_macros{_includedir} = "%{_prefix}/include";
	$default_macros{_oldincludedir} = "%{_prefix}/include";
	$default_macros{_infodir} = "%{_datadir}/info";
	$default_macros{_mandir} = "%{_datadir}/man";
	$default_macros{_localstatedir} = "%{_prefix}/var";
	$default_macros{_defaultdocdir} = "%_prefix/doc";
	$default_macros{_docdir} = "%{_datadir}/doc";
	$default_macros{_pkg_docdir} = "%{_docdir}/%{_name}";
	$default_macros{__libtoolize} = "libtoolize";
    
	$default_macros{_global_cflags} = "-O2 -g -pipe";
	$default_macros{optflags} = "%{_global_cflags}";
	$default_macros{_var} = "/var";
	$default_macros{_tmppath} = "%{_var}/tmp/pkgbuild-${logname}";
	$default_macros{_usr} = "/usr";
	$default_macros{_usrsrc} = "%{_usr}/src";

	$default_macros{_topdir} = $_topdir;
	$default_macros{_builddir} = "%{_topdir}/BUILD";
	$default_macros{_rpmdir} = "%{_topdir}/RPMS";
	$default_macros{_pkgdir} = "%{_topdir}/PKGS";
	$default_macros{_sourcedir} = "%{_topdir}/SOURCES";
	$default_macros{_specdir} = "%{_topdir}/SPECS";
	$default_macros{_srcrpmdir} = "%{_topdir}/SRPMS";
	$default_macros{_srcpkgdir} = "%{_topdir}/SPKGS";
	$default_macros{_pkgmapdir} = "%{_topdir}/PKGMAPS";

	$default_macros{makeinstall} = "make \\\n" .
	    "    prefix=%{?buildroot:%{buildroot}}%{_prefix} \\\n" .
	    "    exec_prefix=%{?buildroot:%{buildroot}}%{_exec_prefix} \\\n" .
	    "    bindir=%{?buildroot:%{buildroot}}%{_bindir} \\\n" .
            "    sbindir=%{?buildroot:%{buildroot}}%{_sbindir} \\\n" .
            "    sysconfdir=%{?buildroot:%{buildroot}}%{_sysconfdir} \\\n" .
            "    datadir=%{?buildroot:%{buildroot}}%{_datadir} \\\n" .
            "    includedir=%{?buildroot:%{buildroot}}%{_includedir} \\\n" .
            "    libdir=%{?buildroot:%{buildroot}}%{_libdir} \\\n" .
            "    libexecdir=%{?buildroot:%{buildroot}}%{_libexecdir} \\\n" .
            "    localstatedir=%{?buildroot:%{buildroot}}%{_localstatedir} \\\n" .
            "    sharedstatedir=%{?buildroot:%{buildroot}}%{_sharedstatedir} \\\n" .
            "    mandir=%{?buildroot:%{buildroot}}%{_mandir} \\\n" .
            "    infodir=%{?buildroot:%{buildroot}}%{_infodir} \\\n" .
            "        install";
	$default_macros{pkgbuild_postprocess} = "${_pkgbuild_libdir}/pkgbuild-postprocess";
	$default_macros{nil} = "";
	$default_macros{find_lang} = "echo WARNING: find_lang not implemented";
	$default_macros{_unpackaged_files_terminate_build} = 1;
	$default_macros{_duplicate_files_terminate_build} = 0;
	$default_macros{_invalid_patches_terminate_build} = 1;
    } else {
	my $line;
	my $lineno = 0;
	while ($line = <MACROS>) {
	    ++$lineno;
	    chomp ($line);
	    next if $line =~ /^\s*#/;
	    next if $line =~ /^\s*$/;
	    $line =~ s/\\\\/\\/g;
	    if ($line =~ /^\s*%(\S+)\s*(.*)$/) {
		my $macro_name = $1;
		my $macro_def = $2;
		while ($macro_def =~ /\\$/) {
		    $line = <MACROS>;
		    chomp ($line);
		    ++$lineno;
		    if (not defined ($line)) {
			print "WARNING: $fname ($lineno): unexpected end of file\n";
		    }
		    $macro_def =~ s/\\$//;
		    $line =~ s/\\\\/\\/g;
		    $macro_def = $macro_def . "\n" . $line;
		}
		$macro_def =~ s/\s*$//;
		$default_macros{$macro_name} = "$macro_def";
	    } else {
		print "WARNING: $fname ($lineno): syntax error\n";
	    }
	}
    }
}

# evaluate/expand macros in the given string
# (safe to use while loading the spec file)
sub eval ($$) {
    my $self = shift;
    my $str = shift;

    if (! $self->{_loaded} and ! $self->{_being_loaded}) {
	if (not $self->_read_spec ()) {
	    return $str;
	}
    }

    if (not defined ($str)) {
	return undef;
    }

    # spec file comments are ignored
    if ($str =~ /^#/) {
	return $str;
    }

    # no % in the string means nothing to do
    if (index ($str, "%") == -1) {
	return $str;
    }

    # find all "%keyword"s in $str; if they contain uppercase chars
    # convert to lowercase for ease of use later on
    foreach my $found_keyword ($str =~ /%($all_keywords)/gi) {
      my $lc_keyword = lc($found_keyword);
      $str =~ s/%$found_keyword/%$lc_keyword/;
    }
 
    # split to a list of chars for easier parsing
    @chrs = split //, $str;
    return $self->_do_eval (0, "", @chrs);
}

# same as eval, but not everything is evaluated,
# for example in an expression like this:
#    %{!?_prefix:#}%define mylibdir %{_prefix}/lib
# if _prefix is defined, this should be expanded to
#    %define mylibdir %{_prefix}/lib
# (note that the macro definition was NOT expanded, but the conditional
# %? thingie was)
# if _prefix is not defined, this should evaluate to
#    #%define mylibdir %{_prefix}/lib
# In the rest of the _do_eval_foo subroutines $preeval means that
# we're doing this 'pre-evaluation' of the string
sub _pre_eval ($$) {
    my $self = shift;
    my $str = shift;

    if (not defined ($str)) {
	return undef;
    }

    # spec file comments are ignored
    if ($str =~ /^#/) {
	return $str;
    }

    # no % in the string means nothing to do
    if (index ($str, "%") == -1) {
	return $str;
    }

    # split to a list of chars for easier parsing
    @chrs = split //, $str;
    return $self->_do_eval (1, "", @chrs);
}

# used for recording which macros are being evaluated, to avoid
# infinite loops in recursive definitions
my %loop_catcher;

# the result string is built in $str (parts of the original string
# that have been parsed) and @chrs is the list of chars to be parsed
sub _do_eval ($$$@) {
    my $self = shift;
    my $preeval = shift;
    my $str = shift;
    my @chrs = @_;

    if (not @chrs) {
	return $str;
    }

    my $chr = shift (@chrs);
    if (not @chrs) {
	return "$str$chr";
    }
    while ($chr ne "%") {
	$str = "$str$chr";
	$chr = shift (@chrs);
	if (not @chrs) {
	    return "$str$chr";
	}
    }
    if ($chr eq "%") {
	$chr = shift (@chrs);
	if ($chr eq "%") {  # %%
	    if ($preeval) {
		return $self->_do_eval ($preeval, "$str%%", @chrs);
	    } else {
		return $self->_do_eval ($preeval, "$str%", @chrs);
	    }
	} elsif ($chr eq "@") {  # %@ (files list)
	    # pass through, needs to be evaluated in pkgbuild
	    # when the %files list is expanded
	    return $self->_do_eval ($preeval, "$str%@", @chrs);
	} elsif ($chr eq "(") {  # %(command)
	    return $self->_do_eval_command ($preeval, $str, @chrs);
	} elsif ($chr eq "{") {  # %{....
	    if (not @chrs) {
		$self->_set_error ("Unterminated {: $str%{");
		return $str;
	    }
	    $chr = shift (@chrs);
	    if (not @chrs) {
		if ($chr eq "}") {  # %{}
		    if ($preeval) {
			return "$str%{}";
		    } else {
			return "$str%";
		    }
		}
		$self->_set_error ("Unterminated {: $str%{$chr");
		return $str;
	    }
	    if ($chr =~ /([SP])/ and ($chrs[0] eq ":")) {  # %{S:n} or %{P:n}
		shift (@chrs);
		return $self->_do_eval_sp ($preeval, $str, $1, @chrs);
	    } elsif ($chr eq "?") {  # %{?
		return $self->_do_eval_cond ($preeval, $str, "{", 0, @chrs);
	    } elsif ($chr eq "!") {  # %{!
		return $self->_do_eval_cond ($preeval, $str, "{", 1, @chrs);
	    } elsif ($chr eq "@") {
		$chr = shift (@chrs);
		if (not @chrs) {
		    if ($chr eq "}") {  # %{@}
			return "$str%{@}";
		    }
		}
		if ($chr ne "}") {
		    $self->_set_error ("Unterminated {: $str%{@$chr");
		    return $str;
		}
		return $self->_do_eval ($preeval, "$str%{@}", @chrs);
	    } elsif ($chr =~ /[a-zA-Z_]/) {
		return $self->_do_eval_var ($preeval, $str, "{", "$chr", @chrs);
	    } elsif ($chr eq "}") {
		if ($preeval) {
		    return $self->_do_eval ($preeval, "$str%{}", @chrs);
		} else {
		    return $self->_do_eval ($preeval, "$str%", @chrs);
		}
	    } else {
		return $self->_do_eval ($preeval, "$str%{$chr", @chrs);
	    }
	} else {  # %var
	    if ($chr =~ /[a-zA-Z_]/) {
		return $self->_do_eval_var ($preeval, $str, undef, "$chr", @chrs);
	    }
	    return $self->_do_eval ($preeval, "$str$chr", @chrs);
	}
    } else {
	print "WARNING: assertion failed: _do_eval()\n";
	return $self->_do_eval ($preeval, "$str$chr", @chrs);
    }
}

sub _do_eval_var ($$$$$@) {  # %var or %{var}
    my $self = shift;
    my $preeval = shift;
    my $str = shift;
    my $delimiter = shift;
    my $varname = shift;
    my @chrs = @_;

    my $chr = "";
    while (@chrs) {
	$chr = shift (@chrs);
	if ($chr =~ /[a-zA-Z0-9_]/) {
	    $varname = "$varname$chr";
	    next;
	}
	if ($chr eq ":" and defined ($delimiter)) {
	    # %{macrocmd: args}
	    return $self->_do_eval_macro_cmd ($preeval, $str, $varname, @chrs);
	}
	if ($chr eq " " and defined ($delimiter) and
	    $varname =~ /^(with|without|defined|undefined)$/) {
	    # %{with foo} or %{without foo}
	    return $self->_do_eval_with_foo ($preeval, $str, $varname, @chrs);
	}
	if ($chr eq ".") {
	    if ($varname =~ /(PATCH|SOURCE)[0-9]*/) {
		# %{SOURCEn.url}
		$varname = "$varname$chr";
		next;
	    }
	    return $self->_do_eval_spec_var ($preeval, $str, $delimiter,
					     $varname, @chrs);
	}
	if (($chr eq "}") and defined ($delimiter)) {
	    last;
	}
	if (not defined ($delimiter)) {
	    unshift (@chrs, $chr);
	    last;
	}
	$varname = "$varname$chr";
    }
    if (not @chrs and defined ($delimiter) and ($chr ne "}")) {
	$self->_set_error ("Unterminated {: $str%{$varname");
	return $str;
    }

    # first look for the macro, to avoid infinite recursion
    my $val = $self->{_defines}->{$varname};
    # if there is no such macro then it's safe to look for tags etc
    if (not defined($val)) {
	$val = $self->get_value_of($varname);
    }
    if (defined ($loop_catcher{$varname})) {
	print "WARNING: infinite loop detected in the definition of \"$varname\"\n";
	$val = undef;
    }
    if (defined ($val) and not $preeval) {
	$loop_catcher{$varname} = 1;
	$val = $self->eval ($val);
	$loop_catcher{$varname} = undef;
	return $self->_do_eval ($preeval, "$str$val", @chrs);
    } else {
	if (defined ($delimiter)) {
	    return $self->_do_eval ($preeval, "$str%{$varname}", @chrs);
	} else {
	    return $self->_do_eval ($preeval, "$str%$varname", @chrs);
	}
    }
}

sub _do_eval_macro_cmd ($$$$@) { # %{macrocmd: args}
    my $self = shift;
    my $preeval = shift;
    my $str = shift;
    my $macrocmd = shift;
    my @chrs = @_;

    my $argstr = "";
    my $chr = "";
    while (@chrs and $chrs[0] eq " ") {
	shift (@chrs);
    }
    my @delimstack = "}";
    while (@chrs) {
	$chr = shift (@chrs);
	if ($delimstack[0] eq $chr) {
	    shift (@delimstack);
	    if (not (@delimstack)) {
		last;
	    }
	    $argstr .= $chr;
	    next;
	}
	if ($chr eq "{") {
	    unshift (@delimstack, "}");
	} elsif ($chr eq "\\" and not $delimstack[0] =~ /['"]/) {
	    $chr = shift (@chrs);
	} elsif ($chr eq '"' and $delimstack[0] ne "'") {
	    unshift (@delimstack, '"');
	} elsif ($chr eq "'" and $delimstack[0] ne '"') {
	    unshift (@delimstack, "'");
	}
	$argstr .= $chr;
    }

    if (not @chrs and @delimstack) {
	$self->_set_error ("Unterminated expression ($delimstack[0] expected): $str%{$macrocmd:$argstr");
	return $str;
    }

    # the expression to process is %{$macrocmd:$argstr}
    my $val;

    if ($macrocmd eq "eval" or $macrocmd eq "expand") {
	$val = $self->eval ($argstr);
    } elsif ($macrocmd eq "echo") {
	$val = $self->eval ($argstr);
	print $val . "\n";
	return "";
    } elsif ($macrocmd eq "warn") {
	$val = $self->eval ($argstr);
	print STDERR $val . "\n";
	return "";
    } elsif ($macrocmd eq "error") {
	$val = $self->eval ($argstr);
	print STDERR $val . "\n";
	$self->_set_error ($val);
	return "";
    } elsif ($macrocmd eq "basename") { # usable in %files list only
	# pass it through, will have to be evaluated after the %files
	# list is expanded
	return $self->_do_eval ($preeval, "$str%{basename:$argstr}", @chrs);
    }

    if (defined ($val) and (not $preeval or $macrocmd =~ /(eval|expand)/)) {
	$val = $self->eval ($val);
	return $self->_do_eval ($preeval, "$str$val", @chrs);
    } else {
	return $self->_do_eval ($preeval, "$str%{$macrocmd:$argstr}", @chrs);
    }
}

sub _do_eval_with_foo ($$$$@) { # %{with[out] foo} or %{[un]defined foo}
    my $self = shift;
    my $preeval = shift;
    my $str = shift;
    my $cond = shift;
    my @chrs = @_;

    my $optname = "";
    my $chr = "";
    while (@chrs and $chrs[0] eq " ") {
	shift (@chrs);
    }
    my @delimstack = "}";
    while (@chrs) {
	$chr = shift (@chrs);
	if ($delimstack[0] eq $chr) {
	    shift (@delimstack);
	    if (not (@delimstack)) {
		last;
	    }
	    $optname .= $chr;
	    next;
	}
	if ($chr eq "{") {
	    unshift (@delimstack, "}");
	} elsif ($chr eq "\\" and not $delimstack[0] =~ /['"]/) {
	    $chr = shift (@chrs);
	} elsif ($chr eq '"' and $delimstack[0] ne "'") {
	    unshift (@delimstack, '"');
	} elsif ($chr eq "'" and $delimstack[0] ne '"') {
	    unshift (@delimstack, "'");
	}
	$optname .= $chr;
    }

    if (not @chrs and @delimstack) {
	$self->_set_error ("Unterminated expression ($delimstack[0] expected): $str%{$cond $optname");
	return $str;
    }

    # the expression to process is %{$macrocmd:$argstr}
    my $val = $self->eval ($optname);
    if (defined ($val) and not $preeval) {
	if ($cond eq "defined") {
	    return defined($self->{_defines}->{$val});
	} elsif ($cond eq "undefined") {
	    return (!defined($self->{_defines}->{$val}));
	}
	if (defined ($self->{_defines}->{"_with_$val"})) {
	    return (($cond eq "with") or 0);
	} else {
	    return (($cond eq "without") or 0);
	}
    } else {
	return $self->_do_eval ($preeval, "$str%{$w_or_wo $optname}", @chrs);	
    }
}

sub _do_eval_spec_var ($$$$$@) { # %spec.var or %{spec.var}
    my $self = shift;
    my $preeval = shift;
    my $str = shift;
    my $delimiter = shift;
    my $specname = shift;
    my @chrs = @_;

    my $varname = "";
    my $chr = "";
    while (@chrs) {
	$chr = shift (@chrs);
	if ($chr =~ /[a-zA-Z0-9_]/) {
	    $varname = "$varname$chr";
	    next;
	}
	if ($chr eq ".") {
	    if ($varname =~ /(PATCH|SOURCE)[0-9]*/) {
		# %{spec.SOURCEn.url}
		$varname = "$varname$chr";
		next;
	    } elsif ($varname ne "") {
		return $self->_do_eval_spec_pkg_var ($preeval,
						     $str, $delimiter,
						     $specname, $varname,
						     @chrs);
	    } else {
		if (defined ($delimiter)) {
		    $varname = ".";
		    next;
		} else {
		    my $val = $self->get_value_of ($specname);
		    if (defined ($val) and not $preeval) {
			$val = $self->eval ($val);
			return $self->_do_eval ($preeval, "$str$val..", @chrs);
		    } else {
			return $self->_do_eval ($preeval, "$str%$specname..", @chrs);
		    }
		}
	    }
	}
	if (($chr eq "}") and defined ($delimiter)) {
	    last;
	}
	if (not defined ($delimiter)) {
	    unshift (@chrs, $chr);
	    last;
	}
	$varname = "$varname$chr";
    }
    if (not @chrs and defined ($delimiter) and ($chr ne "}")) {
	$self->_set_error ("Unterminated {: $str%{$specname.$varname");
	return $str;
    }

    my $spec_used = $self->{_specs_used}->{$specname};
    if (not defined $spec_used) {
	if (defined ($delimiter)) {
	    return $self->_do_eval ($preeval, "$str%{$specname.$varname}", @chrs);
	}
	my $val = $self->get_value_of ($specname);
	if (not defined $val or $preeval) {
	    return $self->_do_eval ($preeval, "$str%$specname.$varname", @chrs);
	} else {
	    $val = $self->eval ($val);
	    return $self->_do_eval ($preeval, "$str$val.$varname", @chrs);
	}
    }
    my $val = $$spec_used->get_value_of ($varname);
    if (defined ($val) and not $preeval) {
	$val = $self->eval ($val);
	return $self->_do_eval ($preeval, "$str$val", @chrs);
    } else {
	if (defined ($delimiter)) {
	    return $self->_do_eval ($preeval, "$str%{$specname.$varname}", @chrs);
	} else {
	    return $self->_do_eval ($preeval, "$str%$specname.$varname", @chrs);
	}
    }
}

sub _do_eval_spec_pkg_var ($$$$$@) { # %spec.pkg.var or %{spec.pkg.var}
    my $self = shift;
    my $preeval = shift;
    my $str = shift;
    my $delimiter = shift;
    my $specname = shift;
    my $pkgname = shift;
    my @chrs = @_;

    my $varname = "";
    my $chr = "";
    while (@chrs) {
	$chr = shift (@chrs);
	if ($chr =~ /[a-zA-Z0-9_]/) {
	    $varname = "$varname$chr";
	    next;
	}
	if (($chr eq "}") and defined ($delimiter)) {
	    last;
	}
	if (not defined ($delimiter)) {
	    unshift (@chrs, $chr);
	    last;
	}
	$varname = "$varname$chr";
    }
    if (not @chrs and defined ($delimiter) and ($chr ne "}")) {
	$self->_set_error ("Unterminated {: $str%{$specname.$pkgname.$varname");
	return $str;
    }

    my $spec_used = $self->{_specs_used}->{$specname};
    if (not defined $spec_used) {
	if (defined ($delimiter)) {
	    return $self->_do_eval ($preeval, "$str%{$specname.$pkgname.$varname}", @chrs);
	}
	my $val = $self->get_value_of ($specname);
	if (not defined $val or $preeval) {
	    return $self->_do_eval ($preeval, "$str%$specname.$pkgname.$varname", @chrs);
	} else {
	    $val = $self->eval ($val);
	    return $self->_do_eval ($preeval, "$str$val.$pkgname.$varname", @chrs);
	}
    }
    my $pkg_ref = $$spec_used->find_package_by_name ($pkg);
    if (not defined $pkg_ref) {
	if (defined ($delimiter)) {
	    return $self->_do_eval ($preeval, "$str%{$specname.$pkgname.$varname}", @chrs);
	}
	my $val = $$spec_used->get_value_of ($pkgname);
	if (not defined $val or $preeval) {
	    return $self->_do_eval ($preeval, "$str%$specname.$pkgname.$varname", @chrs);
	} else {
	    $val = $self->eval ($val);
	    return $self->_do_eval ($preeval, "$str$val.$varname", @chrs);
	}
    }
    my $val = $$pkg_ref->get_tag ($varname);
    if (defined ($val) and not $preeval) {
	return $self->_do_eval ($preeval, "$str$val", @chrs);
    } else {
	if (defined ($delimiter)) {
	    return $self->_do_eval ($preeval, "$str%{$specname.$pkgname.$varname}", @chrs);
	} else {
	    return $self->_do_eval ($preeval, "$str%$specname.$pkgname.$varname", @chrs);
	}
    }
}

sub _do_eval_command ($$$@) {  # %(command)
    my $self = shift;
    my $preeval = shift;
    my $str = shift;
    my @chrs = @_;

    my $command = "";
    my $chr = "";
    my @delimstack = ")";
    while (@chrs) {
	$chr = shift (@chrs);
	if ($delimstack[0] eq $chr) {
	    shift (@delimstack);
	    if (not (@delimstack)) {
		last;
	    }
	    $command .= $chr;
	    next;
	}
	if ($chr eq "{") {
	    unshift (@delimstack, "}");
	} elsif ($chr eq "(") {
	    unshift (@delimstack, ")");
	} elsif ($chr eq "\\" and not $delimstack[0] =~ /['"]/) {
	    $chr = shift (@chrs);
	} elsif ($chr eq '"' and $delimstack[0] ne "'") {
	    unshift (@delimstack, '"');
	} elsif ($chr eq "'" and $delimstack[0] ne '"') {
	    unshift (@delimstack, "'");
	}

	$command .= $chr;
    }

    if (not @chrs and @delimstack) {
	$self->_set_error ("Unterminated expression ($delimstack[0] expected): $str%($command");
	return $str;
    }

    if ($preeval) {
	return $self->_do_eval ($preeval, "$str%($command)", @chrs);
    } else {
	$command = $self->eval ($command);
	if (defined $self->{error}) {
	    return $str;
	}
	my $command_out = `$command`;
	chomp ($command_out);
	return $self->_do_eval ($preeval, "$str$command_out", @chrs);
    }
}

sub _do_eval_sp ($$$$@) {  # %{S:n} or %{P:n}
    my $self = shift;
    my $preeval = shift;
    my $str = shift;
    my $sp = shift;
    my @chrs = @_;

    my $chr = "";
    my $num = "";
    while (@chrs) {
	$chr = shift (@chrs);
	if ($chr eq "}") {
	    last;
	}
	$num = "$num$chr";
    }
    if (not @chrs and ($chr ne "}")) {
	$self->_set_error ("Unterminated {: $str%{$sp:$num");
	return $str;
    }

    if (not _is_number ($num) or $preeval) {
	return $self->_do_eval ($preeval, "$str%{$sp:$num}", @chrs);
    }
    my $val;
    if ($sp eq "S") {
	$val = $self->get_value_of ("SOURCE$num");
    } else {
	$val = $self->get_value_of ("PATCH$num");
    }
    if (defined ($val)) {
	$val = $self->eval ($val);
	return $self->_do_eval ($preeval, "$str$val", @chrs);
    } else {
	return $self->_do_eval ($preeval, "$str%{$sp:$num}", @chrs);
    }
}

sub _do_eval_cond ($$$$$@) {  # %?foo or %{?foo} or %{?foo:bar} or %{?!.*}
    my $self = shift;
    my $preeval = shift;
    my $str = shift;
    my $delimiter = shift;
    my $pre_negate = shift;
    my @chrs = @_;

    my $varname = "";
    my $chr = "";
    my $negate = $pre_negate;
    my $cond = '?';
    while (@chrs) {
	$chr = shift (@chrs);
	if ($chr =~ /[a-zA-Z0-9_]/) {
	    $varname = "$varname$chr";
	    next;
	}
	if ($pre_negate == 1) {
	    if ($chr ne '?') {
		$self->_set_error ("Syntax error after !: $str%{!$varname$chr");
		return $str;
	    }
	    $cond = '!?';
	    $pre_negate = 0;
	    next;
	}
	if ($chr eq '!') {
	    if ($negate == 1) {
		$self->_set_error ("Syntax error at ! in $str%{$cond$varname$chr");
		return $str;
	    }
	    $cond = '?!';
	    $negate = 1;
	    next;
	}
	if (($chr eq ":") and defined $delimiter) {
	    return $self->_do_eval_cond_val ($preeval, $str, 
					     $varname, $negate, @chrs);
	}
	if (($chr eq "}") and defined ($delimiter)) {
	    last;
	}
	if (not defined ($delimiter)) {
	    unshift (@chrs, $chr);
	    last;
	}
	$self->_set_error ("Invalid character \"$chr\" in $str%$delimiter$cond$varname$chr");
	return $str;
    }
    if (not @chrs and defined ($delimiter) and ($chr ne "}")) {
	$self->_set_error ("Unterminated {: $str%{?$varname");
	return $str;
    }

    # first look for the macro, to avoid infinite recursion
    my $val = $self->{_defines}->{$varname};
    # if there is no such macro then it's safe to look for tags etc
    if (not defined($val)) {
	$val = $self->get_value_of($varname);
    }
    if (not defined ($val) xor $negate) {
	return $self->_do_eval ($preeval, "$str", @chrs);
    } else {
	if (defined ($loop_catcher{$varname})) {
	    print "WARNING: infinite loop detected in the definition of \"$varname\"\n";
	    $val = undef;
	}
	if (not $preeval) {
	    $loop_catcher{$varname} = 1;
	    $val = $self->eval ($val);
	    $loop_catcher{$varname} = undef;
	} else {
	    $val = $self->_pre_eval ($val);
	}
	return $self->_do_eval ($preeval, "$str$val", @chrs);
    }
}

sub _do_eval_cond_val ($$$$$@) {  #  %{?foo:bar}  %{?!foo:bar}
    my $self = shift;
    my $preeval = shift;
    my $str = shift;
    my $varname = shift;
    my $negate = shift;
    my @chrs = @_;

    my $defval = "";
    my $chr = "";
    my $depth = 0;
    while (@chrs) {
	$chr = shift (@chrs);
	if ($chr eq "%") {
	    if (@chrs and ($chrs[0] eq "{")) {
		++$depth;
	    }
	}

	if (($chr eq "\\") and @chrs and ($chrs[0] eq "}")) {
	    $defval="$defval\\}";
	    shift (@chrs);
	    next;
	}

	if ($chr eq "}") {
	    if ($depth > 0) {
		--$depth;
	    } else {
		last;
	    }
	}
	$defval = "$defval$chr";
    }
    if (not @chrs and (($depth > 0) or ($chr ne "}"))) {
	$self->_set_error ("Unterminated {?: $str%{?$varname:$defval");
	return $str;
    }

    # first look for the macro, to avoid infinite recursion
    my $val = $self->{_defines}->{$varname};
    # if there is no such macro then it's safe to look for tags etc
    if (not defined($val)) {
	$val = $self->get_value_of ($varname);
    }
    if (defined ($val) xor $negate) {
	if ($preeval) {
	    $val = $self->_pre_eval ($defval);
	    $str = $self->_do_eval ($preeval, "$str$val", @chrs);
	} else {
	    # we are evaluating the default value, which is indepenent
	    # from the condition in %{?condition:defval}
	    my %save_loop_catcher = (%loop_catcher);
	    %loop_catcher = ();
	    $val = $self->eval ($defval);
	    %loop_catcher = (%save_loop_catcher);
	    $str = $self->_do_eval ($preeval, "$str$val", @chrs);
	}
	return $str;
    } else {
	return $self->_do_eval ($preeval, "$str", @chrs);
    }
}

my %_line_numbers;
my %_file_names;
my $last_fhandle;

sub _set_error ($$;$) {
    my $self = shift;
    my $msg = shift;
    my $fhandle = shift;

    $fhandle = $last_fhandle if not defined ($fhandle);

    my $fname = $_file_names{$fhandle};
    $fname = "" if not defined $fname;
    my $lineno;
    if (defined ($_line_numbers{$fhandle})) {
	$lineno = "($_line_numbers{$fhandle}): ";
    } else {
	$lineno = "";
	if ($fname ne "") {
	    $lineno = ": ";
	}
    }

    $self->{error} = "$fname$lineno$msg";
}

sub _eat_lines ($$) {
    my $self = shift;
    my $fhandle = shift;
    my $line;

    my $depth = 1;

    if (not defined ($_line_numbers{$fhandle})) {
	$_line_numbers{$fhandle} = 0;
    }
    $last_fhandle = $fhandle;

    while (1) {
	$line = <$fhandle>;
	$_line_numbers{$fhandle}++;
	if (not defined $line) {
	    last;
	}
	if ($line =~ /^\s*%if(arch|os|narch|nos\s)/) {
	    $depth++;
	} elsif ($line =~ /^\s*%if\s/) {
	    $depth++;
	} elsif ($line =~ /^\s*%else/) {
	    if ($depth == 1) {
		return "%else";
	    }
	} elsif ($line =~ /^\s*%endif/) {
	    $depth--;
	    if ($depth == 0) {
		return "%endif";
	    }
	}
    }
    return undef;
}

sub _match_arch ($) {
    my $str = shift;

    chomp ($str);
    my @archs = split /[\s,]+/, $str;
    foreach my $a (@archs) {
	next if not defined $a;
	if (defined ($all_archs{$a})) {
	    return 1;
	}
    }
    return 0;
}

sub _match_os ($) {
    my $str = shift;

    chomp ($str);
    my @oss = split /[\s,]+/, $str;
    foreach my $o (@oss) {
	next if not defined $o;
	if (lc ($o) eq $os) {
	    return 1;
	}
    }
    return 0;
}

my %_next_lines;

sub _unget_line ($$$) {
    my $self = shift;
    my $fhandle = shift;
    my $line = shift;

    if (defined ($_next_lines{$fhandle})) {
	my $ref = $_next_lines{$fhandle};
	unshift (@$ref, $line);
    } else {
	my @lines = ($line);
	$_next_lines{$fhandle} = \@lines;
    }
}

sub _get_next_line ($$) {
    my $self = shift;
    my $fhandle = shift;

    if (defined ($_next_lines{$fhandle})) {
	my $ref = $_next_lines{$fhandle};
	if (@$ref) {
	    my $line = shift (@$ref);
	    return $line;
	}
    }

    if (not defined ($_line_numbers{$fhandle})) {
	$_line_numbers{$fhandle} = 0;
    }

    my $line = <$fhandle>;
    $_line_numbers{$fhandle}++;
    $last_fhandle = $fhandle;
    if (not defined $line) {
	return undef;
    }

    if ($line =~ /^\s*%if(arch|os|narch|nos|\s)/) {
	my $cond = 0;
	
	if ($line =~ /^\s*%ifarch\s+(\S.*)/) {
	    $cond = _match_arch ("$1");
	} elsif ($line =~ /^\s*%ifnarch\s+(\S.*)/) {
	    $cond = not _match_arch ("$1");
	} elsif ($line =~ /^\s*%ifos\s+(\S.*)/) {
	    $cond = _match_os ("$1");
	} elsif ($line =~ /^\s*%ifnos\s+(\S.*)/) {
	    $cond = not _match_os ("$1");
	} elsif ($line =~ /^\s*%if\s+(\S.*)/) {
	    $cond = $self->eval ($1);
	    # evaluate string comparison (quoted strings)
	    while ($cond =~ /"([^"]*)"\s*([=!])=\s*"([^"]*)"/) {
		my $res = 0;
		if ($2 eq "=" and $1 eq $3) {
		    $res = 1;
		} elsif ($2 eq "!" and $1 ne $3) {
		    $res = 1;
		}
		$cond =~ s/"([^"]*)"\s*([=!])=\s*"([^"]*)"/ $res /;
	    }
	    # evaluate string comparison (unquoted strings)
	    # 1st case: the first string is not a number
	    while ($cond =~ /(\s|^)(\S*[a-zA-Z_]\S*)\s+([=!])=\s+([a-zA-Z0-9_]+)/) {
		my $res = 0;
		if ($3 eq "=" and $2 eq $4) {
		    $res = 1;
		} elsif ($3 eq "!" and $2 ne $4) {
		    $res = 1;
		}
		$cond =~ s/(\s|^)(\S*[a-zA-Z_]\S*)\s+([=!])=\s+([a-zA-Z0-9_]+)/ $res /;
	    }
	    # 2nd case: the 2nd string is not a number
	    while ($cond =~ /(\s|^)([a-zA-Z0-9_]+)\s+([=!])=\s+(\S*[a-zA-Z_]\S*)/) {
		my $res;
		if ($3 eq "=") {
		    $res = ($2 eq $4);
		} else {
		    $res = ($2 ne $4);
		}
		$cond =~ s/(\s|^)([a-zA-Z0-9_]+)\s+([=!])=\s+(\S*[a-zA-Z_]\S*)/ $res /;
	    }
	    if ($cond =~ /^[\d\|\(\)!&\s<=>]*\s*$/) {
		$cond =~ s/(^|\D)0*(\d)/$1$2/g;
		$cond = eval ($cond);
	    }
	    $cond =~ s/-(.*)/$1/;
	    if (not _is_number ($cond)) {
		$self->_set_error ("%if: invalid boolean expression: $cond", $fhandle);
		return undef;
	    }
	}

	++$self->{_in_conditional};

	if ($cond) {
	    $line = $self->_get_next_line ($fhandle);
	    if (not defined($line)) {
		$self->_set_error ("Unclosed %if", $fhandle);
		return undef;
	    }
	    return $line;
	}

	my $lastline = $self->_eat_lines ($fhandle);

	if (not defined $lastline) {
	    return undef;
	}
	if ($lastline eq "%endif") {
	    --$self->{_in_conditional};
	}
	$line = $self->_get_next_line ($fhandle);
	return $line;

    } elsif ($line =~ /^\s*%else/) {
	if ($self->{_in_conditional} == 0) {
	    $self->_set_error ("Got a %else with no if", $fhandle);
	    return undef;
	}
	my $lastline = $self->_eat_lines ($fhandle);
	if (not defined $lastline) {
	    return undef;
	}
	if ($lastline eq "%else") {
	    $self->_set_error ("%endif expected, %else found", $fhandle);
	    $line = undef;
	}
	if ($lastline eq "%endif") {
	    --$self->{_in_conditional};
	    $line = $self->_get_next_line ($fhandle);
	}
	return $line;
    } elsif ($line =~ /^\s*%endif/) {
	if ($self->{_in_conditional} == 0) {
	    $self->_set_error ("$fhandle: Got a %endif with no if", $fhandle);
	    return undef;
	}
	--$self->{_in_conditional};
	$line = $self->_get_next_line ($fhandle);
	return $line;
    }

    return $line;
}

sub _process_use ($$$) {
    my $self = shift;
    my $fhandle = shift;
    my $line = shift;

    my $name;
    my $fname;
    if ($line =~ /\s*%use\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*=\s*(.*\S)\s*$/) {
	$name = $1;
	$fname = $2;
    } else {
	$self->_set_error ("syntax error in %use directive", $fhandle);
	return 0;
    }

    if ($fname =~ /^"(.*)"$/) {
	$fname = $1;
    }

    my $specdir = $self->get_value_of ("_specdir");
    my $spec = new rpm_spec ("$specdir/$fname", undef, $self);
    if (not defined ($spec)) {
	my $specpath=$self->get_value_of ("__pkgbuild_spec_path");
	if (defined ($specpath)) {
	    my @specdirs = split /:+/, $specpath;
	    foreach my $altspecdir (@specdirs) {
		$spec = new rpm_spec ("$altspecdir/$fname", undef, $self);
		last if defined ($spec);
	    }
	}
    }
    if (not defined ($spec)) {
	$self->_set_error ("Could not open file $specdir/$fname", $fhandle);
	return 0;
    }

    $spec->get_value_of ("name");
    if (defined ($spec->{error})) {
	$self->_set_error ($spec->{error}, $fhandle);
	return 0;
    }

    $self->{_specs_used}->{$name} = \$spec;

    return 1;
}

# Global file id to make recursion possible
my $file_id = 1;

sub _process_include ($$$$@) {
    my $self = shift;
    my $fhandle = shift;
    my $line = shift;
    my $callback = shift;
    my @cbargs = @_;

    my $specdir = $self->get_value_of ("_specdir");
    my $fname = $line;
    $fname =~ s/\s*%include\s+(\S+)\s*/$1/ or
	$self->_set_error ("Invalid %include command: $line", $fhandle),
	return (0);
    if ($fname =~ /^"(.*)"$/) {
	$fname = $1;
    }
    $fname = $self->eval ($fname);
    my $fname0 = $fname;
    if (not $fname =~ /^\//) {
	if (-f "$specdir/$fname") {
	    $fname = "$specdir/$fname";
	} else {
	    my $specpath=$self->get_value_of ("__pkgbuild_spec_path");
	    if (defined ($specpath)) {
		my @specdirs = split /:+/, $specpath;
		foreach my $altspecdir (@specdirs) {
		    if (-f "$altspecdir/$fname") {
			$fname = "$altspecdir/$fname";
			last;
		    }
		}
	    }
	}
    }
    my $inc_fhandle = "SPEC_FILE" . $file_id++;
    open $inc_fhandle, "<$fname" or
	$self->_set_error ("Could not open %include file $fname for reading", $fhandle), 
	return (0);
    $_file_names{$inc_fhandle} = "$fname";
    my $incref = $self->{_includes};
    push(@$incref, $fname0);

    if (not $self->$callback ($inc_fhandle, undef, @cbargs)) {
	return (0);
    }

    close $inc_fhandle;

    if (defined $self->{error}) {
	return 0;
    }

    return (1);
}

sub _process_tag ($$$) {
    my $self = shift;
    my $fhandle = shift;
    my $line = shift;

    my @unique_tags = ("name", "version", "release",
		       "epoch", "buildroot",
		       "copyright", "license",
		       "distribution", "icon",
		       "url", "group",
		       "packager", "autoreqprov",
		       "serial", "nosource", "nopatch",
		       "sunw_pkg", "sunw_prodname", "sunw_prodvers",
		       "sunw_category", "sunw_hotline", "sunw_basedir",
		       "sunw_maxinst", "vendor", "sunw_rev",
		       "sunw_copyright", "sourcepackage",
		       "buildarchitectures", "buildarch",
		       "excludearch", "exclusivearch",
		       "excludeos", "exclusiveos", "prefix",
		       "summary", "version",
		       "sunw_prodname", "sunw_prodvers",
		       "sunw_category", "sunw_hotline",
		       "sunw_maxinst", "vendor", "docdir",
		       "sunw_pkglist", "sunw_loc",
		       "sunw_pkgtype", "sunw_desc",
		       "sunw_copyright",
		       "sunw_pkg_allzones", "sunw_pkg_hollow",
		       "sunw_pkg_thiszone",
		       "ips_legacy",
		       "pkgbuild_make_empty_package",
		       "ips_package_name",
		       "ips_sourcepackage",
	               "ips_component_version",
	               "ips_build_version",
	               "ips_vendor_version");
    my @multi_tags = ("buildrequires", "requires", "obsoletes", "conflicts",
		      "buildconflicts", "prereq", "provides", "buildprereq",
	              "renamed_to", "obsoleted_by");
    my @ord_tags = ( "source", "patch" );
    my @localised_tags = ("summary");
    my $lcline = lc($line);
    chomp ($line);
    $lcline =~ s/^\s*//;
    my $tagname;
    my $value;
    my $tag_opt;
    my $package_ref = $self->{_current_package};

    # meta(foo): bar
    if ($lcline =~ /^meta\s*\(\s*[^\s]+\s*\)\s*:(.*\S)\s*$/) {
	$line =~ /^\s*[mM][eE][tT][aA]\s*\(\s*(\S+)\s*\)\s*:\s*(.*\S)\s*$/;
	$value = $2;
	my $metaname = lc($1);
	$package_ref->set_meta ($metaname, $value);
	return 1;
    }

    foreach my $tag (@unique_tags) {
	if ($lcline =~ /^$tag(\([^\)]+\)|)\s*:\s*/) {
	    $line =~ /^\s*[a-zA-Z0-9_-]*(\([^\)]+\)|)\s*:\s*(.*\S)\s*$/;
	    $tag_opt = $1;
	    $value = $2;
	    $tagname = $tag;
	    $tagname =~ s/^([a-z_]*).*$/$1/;
	    if ($tagname eq "sunw_pkg" and not $self->{_main_package}) {
		# if there is an SVr4 package with the same name defined, then link them
		my @all_packages = $self->get_packages();
		foreach my $p (@all_packages) {
		    if ($p->get_svr4_name() eq $value) {
			# a pkg with the same SVr4 name exists already
			$package_ref->set_svr4_match($p);
			last;
		    }
		}
	    }
	    if ($tagname eq "ips_package_name") {
		# if there is an IPS_package_name defined for this %package
		# then it's not a subpkg, unless there's a %package with
		# the same IPS name already
		my @all_packages = $self->get_packages();
		my $is_subpkg = 0;
		if ($#all_packages > 0) {
		    foreach my $pkg (@all_packages) {
			# skip the current package
			next if $pkg->{_id} == $package_ref->{_id};
			if ($pkg->get_ips_name() eq $value) {
			    # a pkg with the same IPS name exists already
			    $is_subpkg = 1;
			    last;
			}
		    }
		    $package_ref->set_subpkg($is_subpkg);
		}
	    }
	    $package_ref->set_tag ($tagname, $value, $tag_opt);
	    return 1;
	}
    }

    foreach my $tag (@multi_tags) {
	if ($lcline =~ /^$tag(\([^\)]+\)|)\s*:\s*/) {
	    $line =~ /^\s*[a-zA-Z0-9_-]*(\([^\)]+\)|)\s*:\s*(.*\S)\s*$/;
	    $value = $2;
	    # ignoring the tag options for now
	    # things like Requires(pre) can be treated as Requires in
	    # SVr4 anyway, although maybe it should be ignored in IPS,
	    # since there is no scripting FIXME?
	    $tagname = $tag;
	    $tagname =~ s/^([a-z_]*).*$/$1/;
	    if ($tagname eq "obsoleted_by") {
		$tagname = "renamed_to";
		print "WARNING: please use Renamed_To instead of Obsoleted_By\n";
	    }
	    my @values = split /\s*,\s*/, $value;
	    foreach my $v (@values) {
		# split space-separated dependencies
		while ($v =~ /([^<>=]+\s*((<=|=<|<|=|>|>=|=>)\s*[^\s<>=]+|))\s+([^\s<>=]+)/) {
		    $package_ref->push_tag ($tagname, $1);
		    $v = $4;
		}
		if (defined ($v)) {
		    $package_ref->push_tag ($tagname, $v);
		}
	    }
	    return 1;
	}
    }

    foreach my $tag (@ord_tags) {
	if ($lcline =~ /^$tag([0-9]*)\s*:\s*/) {
	    my $num = $1;
	    $line =~ /^\s*[a-zA-Z0-9_-]*\s*:\s*(.*\S)\s*$/;
	    $value = $1;
	    $tagname = $tag;
	    $tagname =~ s/^([a-z_]*).*$/$1/;
	    $package_ref->set_ord_tag ($tagname, $num, $value);
	    return 1;
	}
    }

    foreach my $tag (@localised_tags) {
	if ($lcline =~ /^$tag\(([^)]*)\)\s*:\s*/) {
	    my $locale = $1;
	    $line =~ /^\s*[a-zA-Z0-9().@_-]*\s*:\s*(.*\S)\s*$/;
	    $value = $1;
	    $tagname = $tag;
	    $tagname =~ s/^([a-z_]*).*$/$1/;
	    $package_ref->set_tag ("${tagname}::${locale}", $value);
	    return 1;
	}
    }

    $self->_set_error ("Unknown tag: $line", $fhandle);
    return 0;
}

sub _process_define ($$$) {
    my $self = shift;
    my $fhandle = shift;
    my $line = shift;

    if ($line =~ /\s*%define\s+([a-zA-Z0-9_]*)\s+(.*)$/) {
	my $val = $2;
	my $mname = $1;
	$val =~ s/\s*$//;
	$self->{_defines}->{$mname} = $val;
	return 1;
    } else {
	my $mname = "";
	if ($line =~ /\s*%define\s+(\S*)/) {
	    $mname = $1;
	}
	print "WARNING: Macro %$mname has illegal name (%define)\n";
	return 1;
    }
}

sub _process_package ($$$) {
    my $self = shift;
    my $fhandle = shift;
    my $line = shift;

    my $mainpkg_ref = \$self->{_packages}[0];
    my $package_name;
    # devel, l10n etc.
    # basically the subpkg name in the svr4 world and a tag in the IPS world
    my $pkg_tag;
    # is it a standalone package or a subpackage?
    # subpackages are merged and tagged in IPS, standalone packages
    # are packaged separately.  Standalone packages are those
    # defined using %package -n <name>
    my $is_subpkg;
    my $svr4_pkg_name;

    if ($line =~ /\s*%package\s+-n\s+(\S+)\s*$/) {
	$package_name = $self->eval ($1);
	$is_subpkg = 0;
    } elsif ($line =~ /\s*%package\s+(\S+)\s*$/) {
	$pkg_tag = $self->eval ($1);
	$is_subpkg = 1;
	$svr4_pkg_name = $$mainpkg_ref->get_tag ("sunw_pkg");
	if (defined ($svr4_pkg_name)) {
	    $svr4_pkg_name = $svr4_pkg_name . "-" . $pkg_tag;
	}
	$package_name = $$mainpkg_ref->get_tag ("name") . "-" . $pkg_tag;
    } else {
	$self->_set_error ("invalid %package directive: $line", $fhandle);
	return 0;
    }

    my $pkg = $self->find_package_by_name ($package_name);
    if (defined ($pkg)) {
	$self->_set_error ("Package already exists: $package_name", $fhandle);
	return 0;
    }

    if ($os eq "solaris") {
	my $src_pkg_name = $self->get_value_of ("sourcepackage");
	if (not defined $src_pkg_name) {
	    $src_pkg_name = $$mainpkg_ref->get_tag ("name") . "-src";
	}
	if ($src_pkg_name eq $package_name) {
	    $self->_set_error ("Package name $package_name clashes with the source package name, use the SourcePackage tag to define a different source package name", $fhandle);
	    return 0;
	}
	if (length ($package_name) > 32) {
	    $self->_set_error ("Package name $package_name is too long (>32 chars)", $fhandle);
	    return 0;
	}
    }

    my $new_package = rpm_package->new_subpackage (\$self, $package_name, $pkg_tag, $is_subpkg);
    $self->{_current_package} = $new_package;
    $self->{_main_package} = undef;

    # if there is an SVr4 package with the same name defined, then link them
    my @all_packages = $self->get_packages();
    my $pname = $svr4_pkg_name;
    $pname = $package_name unless defined $pname;
    foreach my $p (@all_packages) {
	if ($p->get_svr4_name() eq $pname) {
	    # a pkg with the same SVr4 name exists already
	    $new_package->set_svr4_match($p);
	    last;
	}
    }
    $new_package->set_tag('sunw_pkg', $svr4_pkg_name);
    my $ref = $self->{_packages};
    push (@$ref, $new_package);
    my $packagebase = new packagebase;
    $packagebase->add_package ($new_package);

    if (defined $self->{error}) {
	return 0;
    }

    return 1;
}

sub _preprocess_line ($$) {
    my $self = shift;
    my $line = shift;

    chomp ($line);
    $line =~ s/^\s*//;
    $line = $self->eval ($line);

    return ($line);
}

sub _get_unpack_commands ($$) {
    my $srcname = shift;
    my $opt_q = shift;
    my $unpack;
    my $uncompress;

    if (not defined $opt_q) {
	$unpack = " | @TAR@ xvf -";
    } else {
	$unpack = " | @TAR@ xf -";
    }
    if ($srcname =~ /(\.tar\.bz2|\.tbz|\.tbz2)$/) {
	$uncompress = "/usr/bin/bzip2 -dc";
    } elsif ($srcname =~ /(\.tar\.gz|\.tgz)$/) {
	$uncompress = "/usr/bin/gzip -dc";
    } elsif ($srcname =~ /(\.tar\.xz|\.txz)$/) {
	$uncompress = "/usr/bin/xz -dc";
    } elsif ($srcname =~ /(\.tar\.Z)$/) {
       $uncompress = "/usr/bin/uncompress -c";
    } elsif ($srcname =~ /(\.tar)$/) {
	$uncompress = "/bin/cat";
    } elsif ($srcname =~ /(\.zip)$/) {
	if (not defined $opt_q) {
	    $uncompress = "unzip";
	} else {
	    $uncompress = "unzip -q";
	}
	$unpack = "";
    } elsif ($srcname =~ /(\.jar)$/) {
	$uncompress = "/bin/cat";
	if (not defined $opt_q) {
	    $unpack = " | jar xvf -";
	} else {
	    $unpack = " | jar xf -";
	}
    } else {
## TODO: add CVS checkout
	$uncompress = "/bin/cat";
    }

    return ($uncompress, $unpack);
}

sub find_package_by_name ($) {
    my $self = shift;
    my $name = shift;

    return if not defined ($name);

    my $ref = $self->{_packages};
    my $pkgname;
    foreach my $package (@$ref) {
	if ($package->get_name () eq $name) {
	    return $package;
	}
    }
    return undef;
}

sub find_package_by_svr4_name ($) {
    my $self = shift;
    my $name = shift;

    return if not defined ($name);

    my $ref = $self->{_packages};
    my $pkgname;
    foreach my $package (@$ref) {
	if ($package->get_svr4_name () eq $name) {
	    return $package;
	}
    }
    return undef;
}

sub find_package_by_ips_name ($) {
    my $self = shift;
    my $name = shift;

    return if not defined ($name);

    my $ref = $self->{_packages};
    my $pkgname;
    foreach my $package (@$ref) {
	if ($package->get_ips_name () eq $name) {
	    return $package;
	}
    }
    return undef;
}

sub find_package_by_pkg_name ($) {
    my $self = shift;
    my $name = shift;

    return if not defined ($name);

    my $ref = $self->{_packages};
    my $pkgname;
    foreach my $package (@$ref) {
	if ($package->get_svr4_name () eq $name) {
	    return $package;
	}
	if ($package->get_ips_name () eq $name) {
	    return $package;
	}
    }
    return undef;
}

sub _split_opts ($) {
    my $line = shift;
    my @tokens = ();

    $line =~ s/^\s*//;
    $line =~ s/\s*$//;
    while ($line ne "") {
	my $tok = "";
	while ($line =~ /^\S/) {
	    if ($line =~ /^"((\\"|[^"])*)"/) {
		$tok = "$tok$1";
		$line =~ s/^"((\\"|[^"])*)"//;
	    } elsif ($line =~ /^((\\"|[^\s"])+)/) {
		$tok = "$tok$1";
		$line =~ s/^((\\"|[^\s"])+)//;
	    } else {
		$self->_set_error ("ERROR: assertion failed: _split_opts ($line)");
	    }
	}
	$tok =~ s/\\"/"/g;
	@tokens = (@tokens, $tok);
	$line =~ s/^\s*//;
    }

    return @tokens;
}

sub _is_number($) {
    my $number = shift;

    if( $number =~ /\D/ ) {
        return 0;
    } else {
        return 1;
    }
}

# <opt def> ::=  ! <defs> | <defs>
# <defs> ::= <def> <defs> | <def>
# <def> ::= <char> | <char>: | <char>; | <char># | <char>@
# !
#   extra arguments not allowed; no ! means extra arguments are
#   saved in %macro_opts{argv<n>}  <n>=0..<argc-1>
# <char>:
#   argument required after option -<char>
# <char>;
#   argument optional after option -<char>
# <char>#
#   requires a numeric argument
# <char>@
#   option can be used multiple times, values will be separated by \n's
sub _process_macro_opts ($$$$;$$) {
    my $self = shift;
    my $opt_def = shift;
    my $line = shift;
    my $macro = shift;
    my $name = shift;
    my $package = shift;

    my %macro_opts;
    my $opt_line = $line;
    if (defined ($name)) {
	if (defined ($package)) {
	    $opt_line =~ s/\s*%$name.$package.$macro(\s*)/$1/;
	    $opt_line =~ s/\s*%{$name.$package.$macro}(\s*)/$1/;
	} else {
	    $opt_line =~ s/\s*%$name.$macro(\s*)/$1/;
	    $opt_line =~ s/\s*%{$name.$macro}(\s*)/$1/;
	}
    } else {
	$opt_line =~ s/\s*%$macro(\s*)/$1/;
	$opt_line =~ s/\s*%{$macro}(\s*)/$1/;
    }
    $macro_opts{argc} = 0;
    my @tokens = _split_opts ($opt_line);
    my $opt_name;
    while (@tokens) {
	my $token = shift (@tokens);
	if ($token =~ /^-([A-Za-z])(.*)$/) {
	    my $opt = $1;
	    my $arg0 = $2;
	    if ($opt_def =~ /$opt:/) {
		if ($arg0 ne "") {
		    $macro_opts{$opt} = $arg0;
		} else {
		    my $arg = shift (@tokens);
		    if (not defined ($arg)) {
			$self->_set_error ("need arg to %$macro $token");
			return %macro_opts;
		    }
		    $macro_opts{$opt} = $arg;
		}
	    } elsif ($opt_def =~ /$opt;/) {
		if ($arg0 ne "") {
		    $macro_opts{$opt} = $arg0;
		} else {
		    $macro_opts{$opt} = '';
		    if (defined ($tokens[0]) and
			not $tokens[0] =~ /^-\S$/) {
			my $arg = shift (@tokens);
			$macro_opts{$opt} = $arg;
		    }
		}
	    } elsif ($opt_def =~ /$opt\#/) {
		my $arg;
		if ($arg0 ne "") {
		    $arg = $arg0;
		} else {
		    $arg = shift (@tokens);
		}
		if (not defined ($arg)) {
		    $self->_set_error ("need arg to %$macro $token");
		    return %macro_opts;
		}
		if (! _is_number ($arg)) {
		    $self->_set_error ("Bad arg to %$macro $token: $arg");
		    return %macro_opts;
		}
		$macro_opts{$opt} = $arg;
	    } elsif ($opt_def =~ /$opt@/) {
		if ($arg0 ne "") {
		    $macro_opts{$opt} = $arg0;
		} else {
		    my $arg = shift (@tokens);
		    if (not defined ($arg)) {
			$self->_set_error ("need arg to %$macro $token");
			return %macro_opts;
		    }
		    if (not defined ($macro_opts{$opt})) {
			$macro_opts{$opt} = $arg;
		    } else {
			$macro_opts{$opt} .= "\n" . $arg;
		    }
		}
	    } elsif ($opt_def =~ /$opt/) {
		if ($arg0 ne "") {
		    $self->_set_error ("Bad arg to %$macro -$opt: $arg0");
		}
		$macro_opts{$opt} = '';
	    } else {
		chomp($line);
		$self->_set_error ("Bad option $token: $line");
		return %macro_opts;
	    }
	} else {
	    if (not $opt_def =~ /^!/) {
		my $argc = $macro_opts{argc}++;
		$macro_opts{"argv$argc"} = $token;
	    } else {
		$self->_set_error ("Bad arg to %$macro: $token");
		return %macro_opts;
	    }
	}
    }

    return %macro_opts
}

sub _check_class ($$) {
    my $self = shift;
    my $class_name = shift;

    if (defined ($self->{_classes}->{$class_name}->{iclass}) or
	defined ($self->{_classes}->{$class_name}->{iclass_file}) or
	defined ($self->{_classes}->{$class_name}->{rclass}) or
	defined ($self->{_classes}->{$class_name}->{rclass_file})) {
	return 1;
    }

    return 0;
}

sub _is_system_class ($) {
    my $class_name = shift;

    if ( -f "/usr/sadm/install/scripts/i.$class_name" or
	 -f "/usr/sadm/install/scripts/r.$class_name" ) {
	return 1;
    }

    return 0;
}

sub get_class_script ($$$) {
    my $self = shift;
    my $class_name = shift;
    my $script_name = shift;

    if (! $self->{_loaded} and ! $self->{_being_loaded}) {
	if (not $self->_read_spec ()) {
	    return undef;
	}
    }

    if (defined ($self->{_classes}->{$class_name})) {
	if (defined ($self->{_classes}->{$class_name}->{$script_name})) {
	    return ($self->{_classes}->{$class_name}->{$script_name});
	}
	if (defined ($self->{_classes}->{$class_name}->{"${script_name}_file"})) {
	    my $script_file = $self->eval ("%_sourcedir");
	    $script_file .= "/" . 
		$self->{_classes}->{$class_name}->{"${script_name}_file"};
	    open SCRIPT_FILE, "<$script_file" or
		$self->_set_error ("Could not open class action script file $script_file for reading"),
		return undef;
	    my @lines = <SCRIPT_FILE>;
	    close SCRIPT_FILE;
	    my $script = "";
	    map $script .= $_, @lines;
	    return $script;
	}
    }

    return undef;
}

sub _process_class_action ($$$;$$) {
    my $self = shift;
    my $fhandle = shift;
    my $line = shift;
    my $class_name = shift;
    my $macro = shift;

    if (not defined $class_name) {
	$line =~ /^%([ir]class)/;
	$macro = $1;
	my %macro_opts = $self->_process_macro_opts ('f:', $line,
						     $macro);
	if (defined ($self->{error})) {
	    return 0;
	}

	if ($macro_opts{argc} != 1) {
	    $self->_set_error ("Class name required after %$macro");
	    return 0;
	}

	$class_name = $macro_opts{argv0};

	if (not defined ($self->{_classes}->{$class_name})) {
	    $self->{_classes}->{$class_name} = {};
	} else {
	    if (defined ($self->{_classes}->{$class_name}->{$macro}) or
		defined ($self->{_classes}->{$class_name}->{"${macro}_file"})) {
		$self->_set_error ("%$macro for class $class_name multiply defined");
		return 0;
	    }
	}

	if (defined ($macro_opts{'f'})) {
	    $self->{_classes}->{$class_name}->{"${macro}_file"} = $macro_opts{'f'};
	    return 1;
	}
    }

    my $eline;
    while (1) {
	$line = $self->_get_next_line ($fhandle);
	if (not defined($line)) {
	    last;
	}
	my $eline = $self->eval ($line);
	chomp ($eline);

	if ($eline =~ /^\s*%define/) {
	    if (not $self->_process_define ($fhandle, $self->_pre_eval ($line))) {
		return (0);
	    }
	} elsif ($eline =~ /^\s*%include/) {
	    if (not $self->_process_include ($fhandle, $line, 
					     \&_process_class_action, 
					     ($class_name, $macro))) {
		return (0);
	    }
	} elsif ($eline =~ /^\s*%([a-zA-Z_][a-zA-Z0-9_]*)\.([a-zA-Z_][a-zA-Z0-9_-]*)\.(${all_block_names})/) {
	    if (defined ($self->{_specs_used}->{$1})) {
		$self->_process_macro ($1, $2, $3, $macro, $line);
	    } else {
		print "WARNING: undefined macro $line\n";
	    }
	} elsif (not $line =~ /^%(${all_keywords}|%{?)/) {
	    if (defined ($self->{_classes}->{$class_name}->{$macro})) {
		$self->{_classes}->{$class_name}->{$macro} .= "\n" . $eline;
	    } else {
		$self->{_classes}->{$class_name}->{$macro} = $eline;
	    }
	} else {
	    return $self->_process_top_level ($fhandle, $line);
	}
    }
	
    if (defined $self->{error}) {
        return 0;
    }

    return 1;
}

sub _process_macro ($$$$$$) {
    my $self = shift;
    my $name = shift;
    my $package = shift;
    my $macro = shift;
    my $block_name = shift;
    my $line = shift;

    my $macro_expansion = '';

    if (defined ($name)) {
	my $spec_used = $self->{_specs_used}->{$name};
	if (not defined $spec_used) {
	    $self->_set_error ("name $name not found. Missing %use?");
	    return 0;
	}
	my $scriptlet;

	my %macro_opts = $self->_process_macro_opts ('!d:', $line,
						     $macro, $name, $package);
	my $build_subdir = $macro_opts{'d'};

	if ($macro =~ /^(${all_script_names})$/) {
	    $pkg_ref = $$spec_used->find_package_by_name ($package);
	    if (not defined($pkg_ref)) {
		print "WARNING: subpackage not found: $name.$package\n";
	    } else {
		$scriptlet = $pkg_ref->_get_block_nochdir ($macro, $build_subdir);
	    }
	} else {
	    $scriptlet = $$spec_used->_get_block_nochdir ($macro, $build_subdir);
	}
	if (not defined ($scriptlet)) {
	    $scriptlet = "";
	}
	my $builddir = $self->eval ("%{_builddir}");
	if (defined ($$spec_used->{_defines}->{_build_src_dir_name})) {
	    $scriptlet = "$scriptlet\ncd $builddir%{setup:extradirs}\n";
	}
	if (defined ($self->{error})) {
	    return 0;
	}
	if (defined ($macro_opts{'d'})) {
	    $self->{_blocks}->{$block_name.chdir} = "cd $builddir";
	    $scriptlet = $self->eval ("cd $macro_opts{'d'};\n${scriptlet}\ncd $builddir%{setup:extradirs}");
	}
	if ($macro eq "prep") {
	    $self->{_blocks}->{$block_name.chdir} = "cd $builddir";
	}
	$macro_expansion = $scriptlet;
    } else {
	if ($macro =~ /setup([0-9]*)/) {
	    my $num = $1;
	    if ($num eq "") {
		$num = 0;
	    }
	    
	    my %macro_opts = $self->_process_macro_opts ('!n:DcTqb@a@',
							 $self->eval ($line),
							 $macro, $name, $package);
	    if (defined ($self->{error})) {
		return 0;
	    }
	    my $dirname = $self->eval ("%name-%version");
	    if (defined ($macro_opts{'n'})) {
		$dirname = $macro_opts{'n'};
	    }
	    if (not defined ($self->{_defines}->{_build_src_dir_name})) {
		$self->{_defines}->{_build_src_dir_name} = $dirname;
	    }
	    $macro_expansion = $self->eval ("cd %{_builddir}") . 
		"%{setup:extradirs}\n";

	    if (not defined ($macro_opts{'D'})) {
		$macro_expansion = $macro_expansion . "rm -rf $dirname\n";
	    }
	    if (defined ($macro_opts{'c'})) {
		$macro_expansion = $macro_expansion . "mkdir -p $dirname\n" .
		    "cd $dirname\n";
	    } else {
		if (not defined ($macro_opts{'T'})) {
		    my $srcname = $self->eval("%SOURCE$num");
		    my $uncompress;
		    my $unpack;
		    ($uncompress, $unpack) = 
			_get_unpack_commands ($srcname, $macro_opts{'q'});
		    $macro_expansion = $macro_expansion .
			"$uncompress $srcname$unpack\n";
		    $macro_expansion = $macro_expansion .
			"STATUS=\$?\n" .
			"if [ \$STATUS -ne 0 ]; then\n" .
			"  exit \$STATUS\n" .
			"fi\n";
		}
	    }

	    if (defined $macro_opts{'b'}) {
		my @sourcenums = split /\n/, $macro_opts{'b'};
		foreach my $srcnum (@sourcenums) {
		    next if not defined $srcnum;
		    if (not _is_number ($srcnum)) {
			$self->_set_error ("Bad arg to %setup: number expected after -b");
			return 0;
		    }
		    my $srcname = $self->eval("%SOURCE$srcnum");
		    my $uncompress;
		    my $unpack;
		    ($uncompress, $unpack) = 
			_get_unpack_commands ($srcname, $macro_opts{'q'});
		    $macro_expansion = $macro_expansion .
			"$uncompress $srcname$unpack\n";
		    $macro_expansion = $macro_expansion .
			"STATUS=\$?\n" .
			"if [ \$STATUS -ne 0 ]; then\n" .
			"  exit \$STATUS\n" .
			"fi\n";
		}
	    }

	    if (not defined ($macro_opts{'c'})) {
		$macro_expansion = $macro_expansion . "cd $dirname\n";
	    } else {
		if (not defined ($macro_opts{'T'})) {
		    my $srcname = $self->eval ("%SOURCE$num");
		    my $uncompress;
		    my $unpack;
		    ($uncompress, $unpack) = 
			_get_unpack_commands ($srcname, $macro_opts{'q'});
		    $macro_expansion = $macro_expansion .
			"$uncompress $srcname$unpack\n";
		    $macro_expansion = $macro_expansion .
			"STATUS=\$?\n" .
			"if [ \$STATUS -ne 0 ]; then\n" .
			"  exit \$STATUS\n" .
			"fi\n";
		}
	    }

	    if (defined $macro_opts{'a'}) {
		@sourcenums = split /\n/, $macro_opts{'a'};
		foreach my $srcnum (@sourcenums) {
		    next if not defined $srcnum;
		    if (not _is_number ($srcnum)) {
			$self->_set_error ("Bad arg to %setup: number expected after -a");
			return 0;
		    }
		    my $srcname = $self->eval("%SOURCE$srcnum");
		    my $uncompress;
		    my $unpack;
		    ($uncompress, $unpack) = 
			_get_unpack_commands ($srcname, $macro_opts{'q'});
		    $macro_expansion = $macro_expansion .
			"$uncompress $srcname$unpack\n";
		    $macro_expansion = $macro_expansion .
			"STATUS=\$?\n" .
			"if [ \$STATUS -ne 0 ]; then\n" .
			"  exit \$STATUS\n" .
			"fi\n";
		}
	    }
	    if ($os eq "solaris") {
		$macro_expansion = $macro_expansion . 
		    "[ `/usr/xpg4/bin/id -u` = 0 ] && /bin/chown -Rhf root .\n";
		$macro_expansion = $macro_expansion .
		    "[ `/usr/xpg4/bin/id -u` = 0 ] && /bin/chgrp -Rhf other .\n";
	    } else {
		$macro_expansion = $macro_expansion . 
		    "[ `/usr/bin/id -u` = 0 ] && /bin/chown -Rhf root .\n";
		$macro_expansion = $macro_expansion .
		    "[ `/usr/bin/id -u` = 0 ] && /bin/chgrp -Rhf root .\n";
	    }
	    $macro_expansion = $macro_expansion .
		"/bin/chmod -Rf a+rX,g-w,o-w .\n";
	} elsif ($macro =~ /^patch([0-9]*)/) {
	    my $pnum = $1;
	    my %macro_opts = $self->_process_macro_opts ('!P#p#Eb:', $line,
							 $macro, $name, $package);
	    if (defined ($self->{error})) {
		return 0;
	    }
	    my $num = $macro_opts{'P'};
	    if (not defined($num) or $num eq "") {
		if (not defined ($pnum)) {
		    $num = 0;
		} else {
		    $num = $pnum;
		}
	    }
	    if ($num eq "") {
		$num = 0;
	    }
	    my $package_ref = $self->{_packages}[0];
	    my @values = $package_ref->get_array ('patch');

	    my $val = $values[$num];
	    if (not defined ($val)) {
		$self->_set_error ("ERROR: no such patch: Patch$num");
		return 0;
	    }
	    $val =~ s/^.*\/([^\/]*)/$1/;

	    my $uncompress;
	    if ($val =~ /\.bz2$/) {
		$uncompress = "bzip2 -d < %{_sourcedir}/$val";
	    } elsif ($val =~ /\.(gz|zip)$/) {
		$uncompress = "gzip -d < %{_sourcedir}/$val";
	    }
	    
	    my $patch_opts = ' %{?_patch_options} ';
	    if (defined ($macro_opts{'p'})) {
		$patch_opts = $patch_opts . " -p $macro_opts{'p'}";
	    } else {
		$patch_opts = $patch_opts . " -p 0";
	    }
	    if (defined ($macro_opts{'E'})) {
		$patch_opts = $patch_opts . " -E";
	    }
	    if (defined ($macro_opts{'b'})) {
		$patch_opts = $patch_opts . " -b -z $macro_opts{'b'}";
	    }
	    $macro_expansion = "echo 'Patch #$num ($val):'\n";
	    if (not defined ($uncompress)) {
		    $macro_expansion .= $self->eval(
			"@PATCH@ $patch_opts < %{_sourcedir}/$val");
	    } else {
		    $macro_expansion .= 
			"$uncompress | @PATCH@ $patch_opts";
	    }
	    if ($self->eval ("%_invalid_patches_terminate_build") eq "0") {
		$macro_expansion = "$macro_expansion --dry-run && \\\n"  .
		    "$macro_expansion || \\\n" .
		    "echo 'WARNING: Patch #$num ($val) FAILED'\n";
		    $macro_expansion =~ s/echo 'Patch #/echo 'Testing patch #/;
	    }

	    $macro_expansion = $self->eval ("$macro_expansion");
	}
    }

    $self->_append_to_block($block_name, $macro_expansion);
}

sub _process_block ($$$;$$) {
    my $self = shift;
    my $fhandle = shift;
    my $line = shift;
    my $block_name = shift;
    my $package_name = shift;

    my $package_ref = $self->{_packages}[0];
    if (not defined ($block_name) or not defined($package_name)) {
	
	$line =~ /^\s*%([a-z]*)/;
	$block_name = $1;

# FIXME: use _process_macro_opts instead
# FIXME: implement %pre -p /path/to/shell

	if ($line =~ /^\s*%$block_name\s+-n\s+(\S+)\s*$/) {
	    $package_name = $1;
	} elsif ($line =~ /^\s*%$block_name\s+(\S+)\s*$/) {
	    $package_name = $package_ref->get_name() . "-" . $1;
	} else {
	    $package_name = $package_ref->get_name();
	}
    }

    if (not $block_name =~ /(changelog|[ir]class|prep|build|install|check|clean)/) {
	$package_ref = undef;
	my $all_packages = $self->{_packages};
	foreach $package (@$all_packages) {
	    my $pkgname = $package->get_name ();
	    if (defined $pkgname and $pkgname eq $package_name) {
		$package_ref = $package;
	    }
	}
	
	if (not defined ($package_ref)) {
	    $self->_set_error ("Package $package_name not defined in $line");
	    return 0;
	}
    }

    if (not defined $self->{_blocks}->{$block_name}) {
	if ($block_name =~ /(build|install|check|clean)/) {
	    my $dirname = $self->eval ("%{_build_src_dir_name}");
	    if ($dirname ne "%{_build_src_dir_name}") {
		$self->{_blocks}->{$block_name} = "cd $dirname\n";
	    }
	} elsif ($block_name =~ /$all_script_names/) {
	    # FIXME: value of -p comes here
	    $self->{_blocks}->{$block_name} = "#!/bin/sh\n\n"
	} else {
	    $self->{_blocks}->{$block_name} = "";
	}
    }

    my $eline;

    while (1) {
	$line = $self->_get_next_line ($fhandle);
	if (not defined($line)) {
	    last;
	}
	my $eline = $self->eval ($line);
	chomp ($eline);

	if ($eline =~ /^\s*%define/) {
	    if (not $self->_process_define ($fhandle, $self->_pre_eval ($line))) {
		return (0);
	    }
	} elsif ($eline =~ /^\s*%include/) {
	    if (not $self->_process_include ($fhandle, $line, 
					     \&_process_block, 
					     ($block_name, $package_name))) {
		return (0);
	    }
	} elsif ($eline =~ /^\s*%(setup[0-9]*)/) {
	    $self->_process_macro (undef, undef, $1, $block_name, $line);
	} elsif ($eline =~ /^\s*%(patch[0-9]*)/) {
	    $self->_process_macro (undef, undef, $1, $block_name, $line);
	} elsif ($eline =~ /^\s*%([a-zA-Z_][a-zA-Z0-9_]*)\.(${all_block_names})/) {
	    if (defined ($self->{_specs_used}->{$1})) {
		$self->_process_macro ($1, undef, $2, $block_name, $line);
	    } else {
		print "WARNING: undefined macro $line\n";
	    }
	} elsif ($eline =~ /^\s*%([a-zA-Z_][a-zA-Z0-9_]*)\.([a-zA-Z_][a-zA-Z0-9_-]*)\.(${all_block_names})/) {
	    if (defined ($self->{_specs_used}->{$1})) {
		$self->_process_macro ($1, $2, $3, $block_name, $line);
	    } else {
		print "WARNING: undefined macro $line\n";
	    }
	} elsif (not $line =~ /^%(${all_keywords}|%{?)/) {
	    if ($block_name =~ /(prep|build|install|check|clean|changelog)/) {
		$self->_append_to_block ($block_name, $eline);
	    } else {
		$package_ref->append_to_block ($block_name, $eline);
	    }
	} else {
	    $self->_unget_line($fhandle, $line);
	    last;
	}
    }

    if (defined $self->{error}) {
	return 0;
    }

    return 1;
}

sub load_metafile ($$$) {
    my $self = shift;
    my $fname = shift;
    my $package_name = shift;
    
    my $mf_fhandle = "SPEC_FILE" . $file_id++;
    my $builddir = $self->eval ("%{_builddir}");
    my $dirname = $self->eval ("%{_build_src_dir_name}");
    $fname = $self->eval($fname);

    if ($dirname eq "%{_build_src_dir_name}") {
	$dirname = $self->eval ("%name-%version");
    }
    open $mf_fhandle, "<$builddir/$dirname/$fname" or
	$self->{error} = "Could not open %files file $builddir/$dirname/$fname for reading",
	return (0);
    $_file_names{$mf_fhandle} = "$fname";
    return $self->_process_files ($mf_fhandle, undef, $package_name);
}

sub _process_files ($$$;$) {
    my $self = shift;
    my $fhandle = shift;
    my $line = shift;
    my $package_name = shift;

    my $package_ref;

    if (defined $line) {
	my %macro_opts = $self->_process_macro_opts ('n:f@', $line, "files");
	if (defined ($self->{error})) {
	    return 0;
	}
	if (($macro_opts{'argc'} > 1) or
	    (defined ($macro_opts{'n'}) and ($macro_opts{'argc'} > 0))) {
	    $self->_set_error ("Too many names: $line", $fhandle);
	    return 0;
	}
	$package_ref = $self->{_packages}[0];
	if (not defined($package_name)) {
	    if (defined ($macro_opts{'n'})) {
		$package_name = $self->eval ($macro_opts{'n'});
	    } elsif (defined ($macro_opts{'argv0'})) {
		$package_name = $package_ref->get_name() . "-" . 
		    $self->eval ($macro_opts{'argv0'});
	    } else {
		$package_name = $package_ref->get_name();
	    }
	}
	$package_ref = undef;
	$package_ref = $self->find_package_by_name ($package_name);
	if (defined ($macro_opts{"f"}) and defined ($package_ref)) {
	    my @metafiles = split /\n/, $macro_opts{"f"};
	    foreach my $mf (@metafiles) {
		$package_ref->add_metafile ($self->eval($mf));
	    }
	}
    } else {
	if (not defined ($package_name)) {
	    $self->_set_error ("assertion failed: _process_files: \$line or \$package_name must be defined");
	    return 0;
	}
	$package_ref = $self->find_package_by_name ($package_name);
    }

    if (not defined ($package_ref)) {
	$self->_set_error ("Undefined package $package_name", $fhandle);
	return 0;
    }

    $package_ref->add_file (undef);  # initialise so that an empty pkg
	                             # is created even if no files in %files
    my @defattr = $package_ref->get_defattr ();
    my @all_verify = rpm_file->get_all_verify ();

    my @this_attr = ();
    my $is_doc = 0;
    my $is_config = 0;
    my @ips_tags = ();
    my $is_ghost = 0;
    my $is_hardlink = 0;
    my @this_verify = (@all_verify);
    my $is_dir = 0;
    my $class_name = "none";
    my $exclude = 0;
    my $preserve;

    $line = $self->_get_next_line ($fhandle);
    if (not defined($line)) {
	if (defined $self->{error}) {
	    return 0;
	}

	return 1;
    }
    my $eline = $self->_preprocess_line ($line);

    while (1) {
	if ($eline =~ /^$/) {
	    # ignore empty lines
	} elsif ($eline =~ /^#/) {
	    # comment, skip to next line
	} elsif ($eline =~ /^\s*%define/) {
	    if (not $self->_process_define ($fhandle, $self->_pre_eval ($line))) {
		return (0);
	    }
	} elsif ($eline =~ /^\s*%include/) {
	    $self->_set_error ("%include not allowed within %files", $fhandle);
	} elsif ($eline =~ /^\s*%defattr/) {
	    if ($eline =~ /
                             ^%defattr
                             \s*\(
                             \s*(-|\?|[0-9]+)  # mode 
                             \s*,\s*(-|\?|[a-zA-Z0-9][a-zA-Z0-9_-]*) #,user
                             \s*,\s*(-|\?|[a-zA-Z0-9][a-zA-Z0-9_-]*) #,group
                             (?:\s*,\s*(-|\?|[0-9]+))? #optional ,dirmode
                             \s*\)\s*$
                         /x) {
		my $mod = $1;
		my $usr = $2;
		my $grp = $3;
		my $dmod = '-';
                $dmod = $4 if defined $4;
		if (_is_number ($usr) or _is_number ($grp)) {
		    $self->_set_error ("%defattr: user and group must be symbolic, not numeric", $fhandle);
		    return (0);
		}
		@defattr = ($mod, $usr, $grp, $dmod);
		$package_ref->set_defattr ($mod, $usr, $grp, $dmod);
	    } else {
		$self->_set_error ("syntax error: $line", $fhandle);
		return (0);
	    }
	} elsif ($eline =~ /^\s*%docdir/) {
	    $is_doc = 1;
	    $eline =~ s/^\s*%docdir\s*//;
	    next;
	} elsif ($eline =~ /^\s*%doc/) {
	    $is_doc = 1;
	    $eline =~ s/^\s*%doc\s*//;
	    # automatic compression: a pkgbuild extension
	    my $compression;
	    if ($eline =~ /^\((compress|gzip|bzip2)\)/) {
		$compression = $1;
		$eline =~ s/^\((compress|gzip|bzip2)\)\s*//;
	    }
	    # no special processing needed if it's a file with a full path name
	    next if $eline =~ /^\//;
	    # another pkgbuild extension: -d directory
	    my $subdir;
	    if ($eline =~ /^-d\s+(\S+)\s*/) {
		$subdir = $1;
		$eline =~ s/^-d\s+(\S+)\s*//;
	    }
	    # a whitespace-separated list of file names may follow %doc
	    my @doc_names = split /\s+/, $eline;
	    for my $doc_name (@doc_names) {
		my $file = rpm_file->new ($package_ref, $doc_name,
					  \@this_attr, \@defattr, \@this_verify,
					  not ($is_dir), $is_doc,
					  $is_config, \@ips_tags, $class_name,
					  $is_ghost, $is_hardlink);
		if ($exclude) {
		    $file->exclude();
		}
		$package_ref->add_file ($file);
		if (defined ($compression)) {
		    $file->set_compression ($compression);
		}
		if (defined ($subdir)) {
		    $file->set_doc_subdir ($subdir);
		}
	    }
	} elsif ($eline =~ /^\s*%config/) {
	    $is_config = 1;
	    if ($eline =~ /^\s*%config\s*\(([^)]*)\)\s*/) {
		my $config_opt = $1;
		if($config_opt =~ /preserve=(renamenew|renameold|true)/) {
		    $preserve = $1;
		} elsif ($config_opt eq "noreplace") {
		    $preserve = "renamenew";
		} else {
		    print "WARNING: unknown argument to %config: $config_opt\n";
		}
	    }
	    $eline =~ s/^\s*%config\s*\([^)]*\)\s*// or
		$eline =~ s/^\s*%config\s*//;
	    next;	    
	} elsif ($eline =~ /^\s*%exclude\s+/) {
	    $exclude = 1;
	    $eline =~ s/^\s*%exclude\s+//;
	    next;
	} elsif ($eline =~ s/^\s*%ips_tag\s*\(([^)]*)\)\s*//) {
	    push(@ips_tags, $1);
	    $eline =~ s/^\s*%ips_tag\s*\([^)]*\)\s*//;
	    next;
	} elsif ($eline =~ /^\s*%ghost/) {
	    $is_ghost = 1;
	    $eline =~ s/^\s*%ghost\s*\([^)]*\)\s*// or
		$eline =~ s/^\s*%ghost\s*//;
	    next;	    
	} elsif ($eline =~ /^\s*%hard/) {
	    $is_hardlink = 1;
	    $eline =~ s/^\s*%hard\s*\([^)]*\)\s*// or
		$eline =~ s/^\s*%hard\s*//;
	    next;	    
	} elsif ($eline =~ /^\s*%attr\s*\(\s*(-|\?|[0-9]+)\s*,\s*(-|\?|[a-zA-Z][a-zA-Z0-9_-]*)\s*,\s*(-|\?|[a-zA-Z][a-zA-Z0-9_-]*)\s*\)\s*/) {
	    @this_attr = ($1, $2, $3);
	    $eline =~ s/^\s*%attr\s*\([^\)]*\)\s*//;
	    next;
	} elsif ($eline =~ /^\s*%verify\s*\(([^\)]*)\)/) {
	    @this_verify = split /\s+/, $1;
	    $eline =~ s/^\s*%verify\s*\([^\)]*\)//;
	    next;
	} elsif ($eline =~ /^\s*%class\s*\(([^\)]*)\)/) {
	    $class_name = $1;
	    if (not $self->_check_class ($class_name)) {
		if (_is_system_class ($class_name)) {
		    $self->_use_system_class ($class_name);
		} else {
		    $self->_set_error ("Undefined class $class_name: $class_name",
				       $fhandle);
		    return 0;
		}
	    }
	    $eline =~ s/^\s*%class\s*\([^\)]*\)//;
	    next;
	} elsif ($eline =~ /^\s*%dir/) {
	    $is_dir = 1;
	    $eline =~ s/^\s*%dir\s*//;
	    next;
	} elsif ($eline =~ /^\s*(\/.*\S)\s*$/) {
	    my $file = rpm_file->new ($package_ref, $1,
				      \@this_attr, \@defattr, \@this_verify,
				      not ($is_dir), $is_doc,
				      $is_config, \@ips_tags, $class_name,
				      $is_ghost, $is_hardlink);
	    if ($exclude) {
		$file->exclude();
	    }
	    if (defined ($preserve)) {
		$file->set_preserve($preserve);
	    }
	    $package_ref->add_file ($file);
	} elsif ($eline =~ /^\s*([A-Za-z0-9]\S*)/) {
	    $self->_set_error ("File must begin with \"/\": $1", $fhandle);
	    return 0;
	} else {
	    $self->_unget_line($fhandle, $line);
	    last;
	}

	@this_attr = ();
	$is_doc = 0;
	$is_config = 0;
	@ips_tags = ();
        $is_ghost = 0;
        $is_hardlink = 0;
	@this_verify = (@all_verify);
	$is_dir = 0;
        $class_name = "none";
	$exclude = 0;
	$preserve = undef;

	$line = $self->_get_next_line ($fhandle);
	if (not defined($line)) {
	    last;
	}
	$eline = $self->_preprocess_line ($line);
    }

    if (defined $self->{error}) {
	return 0;
    }

    return 1;
}

# process that contents of an %actions section
sub _process_actions ($$$;$) {
    my $self = shift;
    my $fhandle = shift;
    my $line = shift;
    my $package_name = shift;

    my $package_ref;

    if (defined $line) {
       my %macro_opts = $self->_process_macro_opts ('n:f@', $line, "actions");
       if (defined ($self->{error})) {
           return 0;
       }
       if (($macro_opts{'argc'} > 1) or
           (defined ($macro_opts{'n'}) and ($macro_opts{'argc'} > 0))) {
           $self->_set_error ("Too many names: $line", $fhandle);
           return 0;
       }
       $package_ref = $self->{_packages}[0];
       if (not defined($package_name)) {
           if (defined ($macro_opts{'n'})) {
               $package_name = $self->eval ($macro_opts{'n'});
           } elsif (defined ($macro_opts{'argv0'})) {
               $package_name = $package_ref->get_name() . "-" . 
                   $self->eval ($macro_opts{'argv0'});
           } else {
               $package_name = $package_ref->get_name();
           }
       }
       $package_ref = undef;
       $package_ref = $self->find_package_by_name ($package_name);
       if (defined ($macro_opts{"f"}) and defined ($package_ref)) {
           my @metafiles = split /\n/, $macro_opts{"f"};
           foreach my $mf (@metafiles) {
                   $package_ref->add_metafile ($self->eval($mf));
           }
       }
    } else {
       if (not defined ($package_name)) {
           $self->_set_error ("assertion failed: _process_actions: \$line or \$package_name must be defined");
           return 0;
       }
       $package_ref = $self->find_package_by_name ($package_name);
    }

    if (not defined ($package_ref)) {
       $self->_set_error ("Undefined package $package_name", $fhandle);
       return 0;
    }

    $line = $self->_get_next_line ($fhandle);
    if (not defined($line)) {
       if (defined $self->{error}) {
           return 0;
       }
           return 1;
    }
    my $eline = $self->_preprocess_line ($line);

    while (1) {
       if ($eline =~ /^$/) {
           # ignore empty lines
       } elsif ($eline =~ /^#/) {
           # comment, skip to next line
       } elsif ($eline =~ /^\s*%define/) {
           if (not $self->_process_define ($fhandle, $self->_pre_eval ($line))) {
                   return (0);
           }
       } elsif ($eline =~ /^\s*([^%].*)$/) {
           $package_ref->add_action($1);
       } else {
	   $self->_unget_line($fhandle, $line);
	   last;
       }

       $line = $self->_get_next_line ($fhandle);
       if (not defined($line)) {
           last;
       }
       $eline = $self->_preprocess_line ($line);
    }

    if (defined $self->{error}) {
           return 0;
    }

    return 1;
}

sub _process_top_level ($$$) {
    my $self = shift;
    my $fhandle = shift;
    my $line = shift;

    $line = $self->_get_next_line ($fhandle) if not defined ($line);
    return(1) if not $line;
    
    while (1) {
	my $eline = $self->eval ($line);

	if ($eline =~ /^\s*#/) {
	    # comment, nothing to do.
	} elsif ($eline =~ /^\s*$/) {
	    # whitespace only
	} elsif ($eline =~ /^%use/) {
	    $self->_process_use ($fhandle, $line) or return 0;
	} elsif ($eline =~ /^%include/) {
	    $self->_process_include ($fhandle, $line, \&_process_top_level, ())
		or return 0;
	} elsif ($eline =~ /^%package/) {
	    $self->_process_package ($fhandle, $line) or return 0;
	} elsif ($eline =~ /^%[ir]class/) {
	    $self->_process_class_action ($fhandle, $line) or return 0;
	} elsif ($eline =~ /^%(description|${all_block_names})/) {
	    $self->_process_block ($fhandle, $line) or return 0;
	} elsif ($eline =~ /^%files/) {
	    $self->_process_files ($fhandle, $line) or return 0;
	} elsif ($eline =~ /^%actions/) {
	    $self->_process_actions($fhandle, $line) or return 0;
	} elsif ($eline =~ /^\s*%define/) {
	    $self->_process_define ($fhandle, $self->_pre_eval ($line))
		or return 0;
	} elsif ($eline =~ /^\s*\S+\s*:\s*\S+/) {
	    $self->_process_tag ($fhandle, $eline) or return 0;
	} elsif ($eline =~ /^\s*%error\s*(.*)/) {
	    $self->_set_error ("ERROR: $1", $fhandle);
	    return 0;
	} elsif ($eline =~ /^\s*%warning\s*(.*)/) {
	    print "WARNING: $1\n";
	} else {
	    $self -> _set_error ("syntax error", $fhandle);
	    return 0;
	}
	if (defined $self->{error}) {
	    return 0;
	}
	$line = $self->_get_next_line ($fhandle);
	return(1) if not $line;
    }
    $self->_set_error ("assertion failed in _process_top_level()", $fhandle);
    return (0);
}

sub _read_spec ($) {
    my $self = shift;

    my $fhandle = "SPEC_FILE" . $file_id++;
    my $fname = $self->{_file_name};

    open $fhandle, "<$fname" or 
	$self->{error} = "Could not open file $fname for reading",
	return (0);
    $_file_names{$fhandle} = $self->{_base_file_name};

    my $line;

    $self->{_being_loaded} = 1;
    $self->{_current_package} = $self->{_packages}[0];
    $self->{_main_package} = 1;

    while (1) {
	$line = $self->_get_next_line ($fhandle);
	if (not defined ($line)) {
	    last;
	}
	if (not $self->_process_top_level ($fhandle, $line)) {
	    $self->{_being_loaded} = 0;
	    $self->{_loaded} = 1;
	    return (0);
	}
    }

    close $fhandle;

    $self->{_current_package} = $self->{_packages}[0];
    $self->{_main_package} = 1;
    $self->{_being_loaded} = 0;
    $self->{_loaded} = 1;

    if (defined $self->{error}) {
	return 0;
    }

    if ($self->{_in_conditional} > 0) {
	$self->{error} = "Unclosed %if";
	return 0;
    }

    if ($os eq "solaris") {
	my $pkg_name = $self->get_value_of ("sunw_pkg");
	$pkg_name = $self->get_name () unless defined $pkg_name;
	if (length($pkg_name) > 32) {
	    $self->{error} = "Package name $src_pkg_name is too long (>32 chars)";
	    return 0;
	}

	my $src_pkg_name = $self->get_value_of ("sourcepackage");
	$src_pkg_name = "${pkg_name}-src" if not defined $src_pkg_name;
	if (length($src_pkg_name) > 32) {
	    $self->{error} = "Source package name $src_pkg_name is too long (>32 chars), use the SourcePackage tag to define a different source package name";
	    return 0;
	}	
    }

    return (1);
}

sub get_name ($) {
    my $self = shift;

    if (! $self->{_loaded} and ! $self->{_being_loaded}) {
	if (not $self->_read_spec ()) {
	    return undef;
	}
    }

    my $package = $self->{_packages}[0];
    my $name = $package->get_tag ("name");
    if (not defined ($name)) {
	return $self->{_base_file_name};
    }
    return $name;
}

sub get_packages ($) {
    my $self = shift;

    if (! ($self->{_loaded} or $self->{_being_loaded})) {
	if (not $self->_read_spec ()) {
	    return ();
	}
    }

    my $ref = $self->{_packages};
    return @$ref;
}

sub block_is_defined ($$) {
    my $self = shift;
    my $block_name = shift;

    if (! $self->{_loaded} and ! $self->{_being_loaded}) {
	if (not $self->_read_spec ()) {
	    return undef;
	}
    }

    return defined ($self->{_blocks}->{$block_name});
}

sub _append_to_block ($$$) {
    my $self = shift;
    my $block_name = shift;
    my $text_to_append = shift;

    if (defined ($self->{_blocks}->{$block_name})) {
	$self->{_blocks}->{$block_name} = 
	    $self->{_blocks}->{$block_name} . "\n" . $text_to_append;
    } else {
	$self->{_blocks}->{$block_name} = $text_to_append;
    }
}

sub get_block ($$;$) {
    my $self = shift;
    my $block_name = shift;
    my $builddir = shift;

    if (! $self->{_loaded} and ! $self->{_being_loaded}) {
	if (not $self->_read_spec ()) {
	    return undef;
	}
    }

    my $spec_block = $self->{_blocks}->{$block_name};
    if (defined ($spec_block)) {
	if (defined ($builddir)) {
	    $spec_block =~ s/\%\{setup:extradirs\}/\/$builddir/g;
	} else {
	    $spec_block =~ s/\%\{setup:extradirs\}//g;
	}
    }
    my $block;
    if (exists ($self->{_blocks}->{$block_name.chdir})) { 
	$block = "$self->{_blocks}->{$block_name.chdir}" .
	    "\n" . $spec_block;
    } else {
	$block = $spec_block;
    }
    return $block;
}

sub _get_block_nochdir ($$;$) {
    my $self = shift;
    my $block_name = shift;
    my $builddir = shift;

    if (! $self->{_loaded} and ! $self->{_being_loaded}) {
	if (not $self->_read_spec ()) {
	    return undef;
	}
    }

    my $spec_block = $self->{_blocks}->{$block_name};
    if (defined ($builddir) and defined ($spec_block)) {
	$spec_block =~ s/\%\{setup:extradirs\}/\%\{setup:extradirs\}\/$builddir/g;
    }
    return $spec_block;
}

sub get_file_name ($) {
    my $self = shift;

    return $self->{_file_name};
}

sub get_base_file_name ($) {
    my $self = shift;
    
    return $self->{_base_file_name};
}

sub get_svr4_name ($) {
    my $self = shift;
    my $svr4_pkg_name = $self->get_value_of ("sunw_pkg");
    $svr4_pkg_name = "$self" unless defined($svr4_pkg_name);
    return $svr4_pkg_name;
}

sub get_ips_name ($) {
    my $self = shift;
    my $ips_pkg_name = $self->get_value_of ("ips_package_name");
    $ips_pkg_name = "$self" unless defined($ips_pkg_name);
    return $ips_pkg_name;
}

sub get_svr4_src_pkg_name ($) {
    my $self = shift;

    my $svr4_pkg_name = $self->get_value_of ("sunw_pkg");
    $svr4_pkg_name = $self->get_name () if not defined $svr4_pkg_name;
    my $svr4_src_pkg_name = $self->get_value_of ("sourcepackage");
    if (not defined $svr4_src_pkg_name) {
	$svr4_src_pkg_name = $svr4_pkg_name;
	$svr4_src_pkg_name .= "-src";
    }
    return $svr4_src_pkg_name;
}

sub get_rpms ($) {
    my $self = shift;

    my @packages = $self->get_packages ();
    return if defined $self->{error};
    my @rpms = ();
    foreach my $pkg (@packages) {
	next if not $pkg->has_files ();
	my $pkg_arch = $pkg->get_tag ("buildarch");
	if (not defined ($pkg_arch)) {
	    $pkg_arch = $pkg->get_tag ("buildarchitectures");
	}
	push (@rpms, $pkg->get_name() . "-" . $pkg->get_tag ("version") . 
	      "-" . $pkg->get_tag ("release") . "." .
	      $pkg_arch . ".rpm");
    }

    return @rpms;
}

sub get_rpm_paths ($) {
    my $self = shift;

    my @packages = $self->get_packages ();
    return if defined $self->{error};
    my @rpms = ();
    foreach my $pkg (@packages) {
	next if not $pkg->has_files ();
	my $pkg_arch = $pkg->get_tag ("buildarch");
	if (not defined ($pkg_arch)) {
	    $pkg_arch = $pkg->get_tag ("buildarchitectures");
	}
	push (@rpms, $self->get_value_of ("_rpmdir") . "/" . 
	      $pkg_arch . "/" .
	      $pkg->get_name() . "-" . $pkg->get_tag ("version") . 
	      "-" . $pkg->get_tag ("release") . "." .
	      $pkg_arch . ".rpm");
    }

    return @rpms;
}

sub get_pkgs ($) {
    my $self = shift;

    my @packages = $self->get_packages ();
    return if defined $self->{error};
    my @pkgs = ();
    foreach my $pkg (@packages) {
	next if not $pkg->has_files ();
	next if $pkg->has_svr4_match ();
	my $sunw_pkg = $pkg->get_tag ('sunw_pkg');
	if (defined ($sunw_pkg)) {
	    push (@pkgs, $sunw_pkg);
	} else {
	    push (@pkgs, $pkg->get_name());
	}
    }

    return @pkgs;
}

sub get_package_names ($;$) {
    my $self = shift;
    my $datastream = shift;

    if (not $datastream) {
	return $self->get_pkgs ();
    } else {
	my @packages = $self->get_packages ();
	return undef if not defined ($packages[0]);
	my $inst = $packages[0]->get_tag ('SUNW_Pkg');
	$inst = $packages[0]->get_tag ('Name') unless $inst;
	$inst = "$self" unless $inst;

	my $version = $packages[0]->get_tag ('Version');
	my $dsname = "${inst}-${version}.${arch}.pkg";
	my @ds_pkg_names = ($dsname);

	return @ds_pkg_names;
    }
}

sub _concat($) {
    my $text = shift;

    return undef if not defined ($text);

    $text =~ s/\n/ /g;
    $text =~ s/ +/ /g;
    $text =~ s/^ //;
    $text =~ s/ $//;
    return $text;
}

sub get_value_of ($$) {
    my $self = shift;
    my $name = shift;

    if ($name =~ /^(${all_keywords}|)$/) {
	return;
    }

    if (! $self->{_loaded} and ! $self->{_being_loaded}) {
	if (not $self->_read_spec ()) {
	    return undef;
	}
    }

    if ($name eq "buildroot") {
	my $parent = $self->{_parent_spec};
	if (defined $parent) {
	    my $br = $parent->get_value_of ("buildroot");
	    if (defined $br) {
		return $br;
	    }
	}
    }

    my $package_ref = $self->{_packages}[0];
    if (defined ($package_ref) and $package_ref->tag_is_defined ($name)) {
	return $package_ref->get_tag ($name);
    } elsif ($name =~ /^(SOURCE|PATCH)([0-9]*).url$/) {
	my $num = $2;
	my $source_or_patch = lc($1);
	if (not defined ($num) or ($num eq "")) {
	    $num = 0;
	}
	my @values = $package_ref->get_array ($source_or_patch);
	return $values[$num];
    } elsif ($name =~ /^(SOURCE|PATCH)([0-9]*)$/) {
	my $num = $2;
	my $source_or_patch = lc($1);
	if (not defined ($num) or ($num eq "")) {
	    $num = 0;
	}
	my @values = $package_ref->get_array ($source_or_patch);
	my $val = $values[$num];
	return undef unless defined $val;
	$val =~ s/^.*\/([^\/]*)/$1/;
	return "%{_sourcedir}/$val";
    } elsif (defined ($self->{_defines}->{$name})) {
	return $self->eval ($self->{_defines}->{$name});
    } elsif ($name eq "DESC") {
	return $self->eval (_concat ($package_ref->get_block ("description")));
    } else {
	return undef;
    }
}

sub get_def ($$) {
    my $self = shift;
    my $name = shift;
    my $lcname = lc ($name);

    if (! $self->{_loaded} and ! $self->{_being_loaded}) {
	if (not $self->_read_spec ()) {
	    return undef;
	}
    }

    return $self->{_defines}->{$name};
}

sub get_sources ($) {
    my $self = shift;

    if (! $self->{_loaded} and ! $self->{_being_loaded}) {
	if (not $self->_read_spec ()) {
	    return undef;
	}
    }

    my $package_ref = $self->{_packages}[0];
    my @values = $package_ref->get_array ('source');
    my $specs_used = $self->{_specs_used};
    my @spec_names_used = keys %$specs_used;
    foreach my $spec_name_used (@spec_names_used) {
	my $spec_used = $self->{_specs_used}->{$spec_name_used};
	my @sources_used = $$spec_used->get_sources ();
	push (@values, @sources_used);
    }
    return _uniq (@values);
}

sub get_public_sources ($) {
    my $self = shift;

    if (! $self->{_loaded} and ! $self->{_being_loaded}) {
	if (not $self->_read_spec ()) {
	    return undef;
	}
    }

    my $package_ref = $self->{_packages}[0];
    my @values = ($package_ref->get_array ('source'));
    my $nosrc = $package_ref->get_tag ("nosource");
    if (defined $nosrc) {
	my @nosrcs = split /[,\s]+/, $nosrc;
	foreach my $nosrcid (@nosrcs) {
	    next if not defined $nosrcid;
	    $values[$nosrcid] = undef;
	}
    }
    my $specs_used = $self->{_specs_used};
    my @spec_names_used = keys %$specs_used;
    foreach my $spec_name_used (@spec_names_used) {
	my $spec_used = $self->{_specs_used}->{$spec_name_used};
	my @sources_used = $$spec_used->get_public_sources ();
	push (@values, @sources_used);
    }
    return _uniq (@values);
}

sub get_patches ($) {
    my $self = shift;

    if (! $self->{_loaded} and ! $self->{_being_loaded}) {
	if (not $self->_read_spec ()) {
	    return undef;
	}
    }

    my $package_ref = $self->{_packages}[0];
    my @values = $package_ref->get_array ('patch');
    my $specs_used = $self->{_specs_used};
    my @spec_names_used = keys %$specs_used;
    foreach my $spec_name_used (@spec_names_used) {
	my $spec_used = $self->{_specs_used}->{$spec_name_used};
	my @patches_used = $$spec_used->get_patches ();
	push (@values, @patches_used);
    }
    return _uniq (@values);
}

sub get_public_patches ($) {
    my $self = shift;

    if (! $self->{_loaded} and ! $self->{_being_loaded}) {
	if (not $self->_read_spec ()) {
	    return undef;
	}
    }

    my $package_ref = $self->{_packages}[0];
    my @values = ($package_ref->get_array ('patch'));
    my $noptch = $package_ref->get_tag ("nopatch");
    if (defined $noptch) {
	my @noptchs = split /[,\s]+/, $noptch;
	foreach my $noptchid (@noptchs) {
	    next if not defined $noptchid;
	    $values[$noptchid] = undef;
	}
    }
    my $specs_used = $self->{_specs_used};
    my @spec_names_used = keys %$specs_used;
    foreach my $spec_name_used (@spec_names_used) {
	my $spec_used = $self->{_specs_used}->{$spec_name_used};
	my @patches_used = $$spec_used->get_public_patches ();
	push (@values, @patches_used);
    }
    return _uniq (@values);
}

sub get_classes ($) {
    my $self = shift;
    if (! $self->{_loaded} and ! $self->{_being_loaded}) {
	if (not $self->_read_spec ()) {
	    return undef;
	}
    }

    my @classes = keys %{$self->{_classes}};
    return @classes;
}

sub _use_system_class ($$) {
    my $self = shift;
    my $class_name = shift;

    if ( -f "/usr/sadm/install/scripts/i.$class_name" or
	 -f "/usr/sadm/install/scripts/r.$class_name" ) {
	$self->{_classes}->{$class_name} = "system";
    } else {
	$self->_set_error ("Unknown system class: $class_name");
    }
}

sub get_class_script_names ($) {
    my $self= shift;
    my @scripts;

    if (! $self->{_loaded} and ! $self->{_being_loaded}) {
	if (not $self->_read_spec ()) {
	    return undef;
	}
    }

    foreach my $class_name (keys %{$self->{_classes}}) {
	if (defined ($self->{_classes}->{$class_name}->{iclass_file})) {
	    push (@scripts, 
		  $self->{_classes}->{$class_name}->{iclass_file});
	}
	if (defined ($self->{_classes}->{$class_name}->{rclass_file})) {
	    push (@scripts, 
		  $self->{_classes}->{$class_name}->{rclass_file});
	}
    }

    return @scripts;
}

sub _uniq (@) {
    my @arr = @_;

    my %h;

    foreach my $elem (@arr) {
	next if not defined $elem;
	$h{$elem} = 1;
    }
    return keys %h;
}

sub get_included_files ($) {
    my $self = shift;
    my $incref=$self->{_includes};
    my @includes = @$incref;

    if (! $self->{_loaded} and ! $self->{_being_loaded}) {
	if (not $self->_read_spec ()) {
	    return undef;
	}
    }

    foreach $used_spec_name (keys %{$self->{_specs_used}}) {
	next if not defined $used_spec_name;
	my $used_spec = $self->{_specs_used}->{$used_spec_name};
	my @more_includes = $$used_spec->get_included_files ();
	if (@more_includes) {
	    push (@includes, @more_includes);
	}
    }
    return _uniq (@includes);
}

sub get_used_spec_files ($) {
    my $self = shift;

    if (! $self->{_loaded} and ! $self->{_being_loaded}) {
	if (not $self->_read_spec ()) {
	    return undef;
	}
    }

    my @used_specs;
    foreach $used_spec_name (keys %{$self->{_specs_used}}) {
	next if not defined $used_spec_name;
	my $used_spec = $self->{_specs_used}->{$used_spec_name};
	push (@used_specs, $$used_spec->get_file_name ());
	my @more_used_specs = $$used_spec->get_used_spec_files ();
	if (@more_used_specs) {
	    push (@used_specs, @more_used_specs);
	}
    }
    return _uniq (@used_specs);
}

sub get_used_spec_labels ($;$) {
    my $self = shift;
    my $prefix = shift;

    if (! $self->{_loaded} and ! $self->{_being_loaded}) {
	if (not $self->_read_spec ()) {
	    return undef;
	}
    }

    my @used_labels;
    foreach $used_spec_name (keys %{$self->{_specs_used}}) {
	next if not defined $used_spec_name;
	my $used_spec = $self->{_specs_used}->{$used_spec_name};
	if (defined ($prefix)) {
	    push (@used_labels, "${prefix}.${used_spec_name}");
	} else {
	    push (@used_labels, ${used_spec_name});
	}
    }
    return _uniq (@used_labels);
}

sub get_topdir ($$) {
    my $build_engine = shift;
    my $predef_ref = shift;
    my $defines = "";
    foreach my $def (@$predef_ref) {
	$defines = $defines . " --define \"$def\"";
    }
    $_topdir = `$build_engine $defines -bp $_pkgbuild_libdir/get_rpm_topdir 2>&1`;
    if ($? != 0) {
	die ("pkgbuild internal error: could not determine the value of %_topdir\nDetails:\n$_topdir");
    }
    if ($_topdir =~ /\nTOPDIR=([^\n]*)\n/s) {
	$_topdir = $1;
    } else {
	die ("pkgbuild internal error: could not determine the value of %_topdir\nDetails:\n$_topdir");
    }
    return $_topdir;
}

sub get_error ($) {
    my $self = shift;

    if (defined $self->{error}) {
	return $self->{error};
    } else {
	return "No error.";
    }
}

sub has_error ($) {
    my $self = shift;

    return defined ($self->{error});
}

_init();
1;
