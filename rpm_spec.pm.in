#use strict;

# TODO: implement %ifarch, %ifos, %ifdef

use warnings;
use rpm_package;
use rpm_file;
use packagebase;

package rpm_spec;

sub get_name ($);

use overload ('""' => \&get_name);	  

my $arch;
my $os;
my $os_rel;

sub init () {
    $arch = `uname -p`;
    chomp ($arch);
    if ($arch eq "unknown") {
	$arch = `uname -m`;
	chomp ($arch);
	if ($arch eq 'i585') {
	    $arch = 'i386';
	} elsif ($arch eq 'i686') {
	    $arch = 'i386';
	}
    }

    $os = `uname -s`;
    chomp ($os);
    $os = lc($os);
    $os_rel = `uname -r`;
    chomp ($os_rel);
    if ($os eq 'sunos') {
	if ($os_rel >= 5) {
	    $os = 'solaris';
	}
    }
}

# Create a new rpm_spec object.
# Return undef if the spec_file is not found
sub new ($) {
    my $class = shift;
    my $spec_file = shift;
    my $self = {};
    
    if (! -r $spec_file) {
	return (undef);
    }
    
    my $packagebase = new packagebase ();
    my $spec = $packagebase->find_spec_by_file_name ($spec_file);
    if (defined ($spec)) {
	return ($spec);
    }

    $self->{_file_name} = $spec_file;
    my $base_file_name = $spec_file;
    $base_file_name =~ s/^.*\/([^\/]*)$/$1/;
    $self->{_base_file_name} = $base_file_name;
    $self->{_loaded} = 0;
    $self->{_being_loaded} = 0;
    $self->{_defines} = {};
    $self->{_specs_used} = {};
    $self->{_blocks} = {};
    
    my $main_package = rpm_package->new (\$self);
    $packagebase->add_package ($main_package);
    $packagebase->add_spec ($self);
    my @packages = ($main_package);
    $self->{_packages} = \@packages;
    
    $self->{_defines}->{_sysconfdir} = "/etc";
    $self->{_defines}->{_initrddir} = "%{_sysconfdir}/rc.d/init.d";
    $self->{_defines}->{_prefix} = "/usr";
    $self->{_defines}->{_exec_prefix} = "%{_prefix}";
    $self->{_defines}->{_bindir} = "%{_exec_prefix}/bin";
    $self->{_defines}->{_lib} = "lib";
    $self->{_defines}->{_libdir} = "%{_exec_prefix}/%{_lib}";
    $self->{_defines}->{_libexecdir} = "%{_exec_prefix}/libexec";
    $self->{_defines}->{_sbindir} = "%{_exec_prefix}/sbin";
    $self->{_defines}->{_sharedstatedir} = "%{_prefix}/com";
    $self->{_defines}->{_datadir} = "%{_prefix}/share";
    $self->{_defines}->{_includedir} = "%{_prefix}/include";
    $self->{_defines}->{_oldincludedir} = "/usr/include";
    $self->{_defines}->{_infodir} = "/usr/share/info";
    $self->{_defines}->{_mandir} = "/usr/share/man";
    $self->{_defines}->{_localstatedir} = "/var";
    $self->{_defines}->{_defaultdocdir} = "%_prefix/doc";
    $self->{_defines}->{_docdir} = "%_datadir/doc";
    $self->{_defines}->{__libtoolize} = "libtoolize";
    
    $self->{_defines}->{_global_cflags} = "-O2 -g -pipe";
    $self->{_defines}->{optflags} = "%{_global_cflags} -march=i386 -mcpu=i686";
    $self->{_defines}->{_var} = "/var";
    $self->{_defines}->{_tmppath} = "%{_var}/tmp";
    $self->{_defines}->{_usr} = "/usr";
    $self->{_defines}->{_usrsrc} = "%{_usr}/src";

    $self->{_defines}->{_topdir} = "@TOPDIR@";
    $self->{_defines}->{_builddir} = "%{_topdir}/BUILD";
    $self->{_defines}->{_rpmdir} = "%{_topdir}/RPMS";
    $self->{_defines}->{_sourcedir} = "%{_topdir}/SOURCES";
    $self->{_defines}->{_specdir} = "%{_topdir}/SPECS";
    $self->{_defines}->{_srcrpmdir} = "%{_topdir}/SRPMS";
    
    return (bless $self, $class);
}

sub eval ($$) {
    my $self = shift;
    my $str = shift;

    my $def;
    my $val;
    my $name;

    my $repeat_deref = 1;
    while ($repeat_deref) {
	$repeat_deref = 0;
	if ($str =~ /\%(?:{([a-zA-Z_][a-zA-Z0-9_]*)\.([a-zA-Z_][a-zA-Z0-9_]*)}|([a-zA-Z_][a-zA-Z0-9_]*)\.([a-zA-Z_][a-zA-Z0-9_]*))/) {
	    $name = $1;
	    $def = $2;

	    if (not defined $name) {
		$name = $3;
		$def = $4;
	    }

	    if (not defined ($self->{_specs_used}->{$name})) {
		print "WARNING: undefined tag %$name at \"$str\".\nForgotten or mistyped %use?\n";
		$val = undef;
	    } else {
		my $spec_used = $self->{_specs_used}->{$name};
		$val = $$spec_used->get_value_of ($def);
	    }

	    if (not defined ($val)) {
		$str =~ s/\%{$name.$def}/#p#E#r#C#e#N#t#{$name.$def}/ or
		    $str =~ s/\%$name.$def([^a-zA-Z0-9_])/#p#E#r#C#e#N#t#$name.$def$1/ or
		    $str =~ s/\%$name.$def$/#p#E#r#C#e#N#t#$name.$def/;
	    } else {
		$str =~ s/\%{$name.$def}/$val/g;
		$str =~ s/\%$name.$def([^a-zA-Z0-9_])/$val/g;
		$str =~ s/\%$name.$def$/$val/g;
	    }
	    $repeat_deref = 1;	    
	}
    }

    $repeat_deref = 1;
    while ($repeat_deref) {
	$repeat_deref = 0;
	if ($str =~ /\%(?:{([a-zA-Z_][a-zA-Z0-9_]*)\.([a-zA-Z_][a-zA-Z0-9_-]*)\.([a-zA-Z_][a-zA-Z0-9_]*)}|([a-zA-Z_][a-zA-Z0-9_]*)\.([a-zA-Z_][a-zA-Z0-9_-]*)\.([a-zA-Z_][a-zA-Z0-9_]*))/) {
	    $name = $1;
	    my $pkg = $2;
	    $def = $3;

	    if (not defined $name) {
		$name = $4;
		$pkg = $5;
		$def = $6;
	    }

	    if (not defined ($self->{_specs_used}->{$name})) {
		print "WARNING: undefined tag %$name at \"$str\".\nForgotten or mistyped %use?\n";
		$val = undef;
	    } else {
		my $spec_used = $self->{_specs_used}->{$name};
		my $pkg_ref = $$spec_used->find_package_by_name ($pkg);
		if (not defined ($pkg_ref)) {
		    $val = undef;
		} else {
		    $val = $$pkg_ref->get_tag ($def);
		}
	    }

	    if (not defined ($val)) {
		$str =~ s/\%{$name.$def}/#p#E#r#C#e#N#t#{$name.$def}/ or
		    $str =~ s/\%$name.$def([^a-zA-Z0-9_])/#p#E#r#C#e#N#t#$name.$def$1/ or
		    $str =~ s/\%$name.$def$/#p#E#r#C#e#N#t#$name.$def/;
	    } else {
		$str =~ s/\%{$name.$def}/$val/g;
		$str =~ s/\%$name.$def([^a-zA-Z0-9_])/$val/g;
		$str =~ s/\%$name.$def$/$val/g;
	    }
	    $repeat_deref = 1;	    
	}
    }

    $repeat_deref = 1;
    while ($repeat_deref) {
	$repeat_deref = 0;
	if ($str =~ /\%(?:{([a-zA-Z_][a-zA-Z0-9_]*)}|([a-zA-Z_][a-zA-Z0-9_]*))/) {
	    $def = $1;

	    if (not defined $def) {
		$def = $2;
	    }

	    $val = $self->get_value_of ($def);

	    if (not defined ($val)) {
		$str =~ s/\%{$def}/#p#E#r#C#e#N#t#{$def}/ or
		    $str =~ s/\%$def([^a-zA-Z0-9_])/#p#E#r#C#e#N#t#$def$1/ or
		    $str =~ s/\%$def$/#p#E#r#C#e#N#t#$def/;
	    } else {
		$str =~ s/\%{$def}/$val/g;
		$str =~ s/\%$def([^a-zA-Z0-9_])/$val$1/g;
		$str =~ s/\%$def$/$val/g;
	    }
	    $repeat_deref = 1;
	}

    }

    $str =~ s/#p#E#r#C#e#N#t#/%/g;
    return ($str);
}

sub _get_next_line ($$) {
    my $self = shift;
    my $fhandle = shift;

    my $line = <$fhandle>;
    return $line;
}

sub _process_use ($$$) {
    my $self = shift;
    my $fhandle = shift;
    my $line = shift;

    my $name;
    my $fname;
    if ($line =~ /\s*%use\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*=\s*(\S+)\s*$/) {
	$name = $1;
	$fname = $2;
    } else {
	$self->{error} = "syntax error in %use directive: $line";
	return 0;
    }

    my $specdir = $self->eval ("%_specdir");
    my $packagebase = new packagebase ();
    my $spec = $packagebase->find_spec_by_file_name ("$specdir/$fname");
    if (not defined ($spec)) {
	$spec = new rpm_spec ("$specdir/$fname");
	if (not defined ($spec)) {
	    $self->{error} = "Could not find spec file $specdir/$fname";
	    return 0;
	}
    }

    $self->{_specs_used}->{$name} = \$spec;

    return 1;
}

# Global file id to make recursion possible
my $file_id = 1;

sub _process_include ($$$$@) {
    my $self = shift;
    my $fhandle = shift;
    my $line = shift;
    my $callback = shift;
    my @cbargs = @_;

    my $specdir = $self->eval ("%_specdir");
    my $fname = $line;
    $fname =~ s/\s*%include\s+(\S+)\s*/$1/ or
	$self->{error} = "Invalid %include command: $line",
	return (0);

    my $inc_fhandle = "SPEC_FILE" . $file_id++;
    open $inc_fhandle, "<$specdir/$fname" or
	$self->{error} = "Could not open %include file $specdir/$fname for reading",
	return (0);

    while (1) {
	$line = <$inc_fhandle>;
	if (not defined ($line)) {
	    last;
	}
	if (not $self->$callback ($inc_fhandle, $line, @cbargs)) {
	    return (0);
	}
    }

    close $inc_fhandle;

    return (1);
}

sub _process_tag ($$$) {
    my $self = shift;
    my $fhandle = shift;
    my $line = shift;

    my @unique_tags = ("name", "version", "release",
		       "copyright", "license",
		       "distribution", "icon",
		       "url", "group",
		       "packager", "autoreqprov",
		       "serial", "nosource", "nopatch",
		       "sunw_basedir", "sunw_pkg",
		       "sunw_prodname", "sunw_prodvers",
		       "sunw_category", "sunw_hotline", 
		       "sunw_maxinst", "vendor", "sunw_rev",
		       "sunw_copyright",
		       "buildroot", "buildarchitectures",
		       "excludearch", "exclusivearch",
		       "excludeos", "exclusiveos", "prefix",
		       "summary", "version", "sunw_basedir",
		       "sunw_prodname", "sunw_prodvers",
		       "sunw_category", "sunw_hotline",
		       "sunw_maxinst", "vendor", "docdir",
		       "sunw_copyright");
    my @multi_tags = ("buildrequires", "source[0-9]*", "patch[0-9]*",
		      "requires", "obsoletes", "prereq", "provides");
    my $lcline = lc($line);
    chomp ($line);
    $lcline =~ s/^\s*//;
    my $tagname;
    my $value;
    my $package_ref = $self->{_current_package};

    foreach my $tag (@unique_tags) {
	if ($lcline =~ /^$tag\s*:\s*/) {
	    $line =~ /^\s*[a-zA-Z0-9_-]*\s*:\s*(.*\S)\s*$/;
	    $value = $1;
	    $tagname = $tag;
	    $tagname =~ s/^([a-z_]*).*$/$1/;
	    $package_ref->set_tag ($tagname, $self->eval ($value));
	    return 1;
	}
    }

    foreach my $tag (@multi_tags) {
	if ($lcline =~ /^$tag\s*:\s*/) {
	    $line =~ /^\s*[a-zA-Z0-9_-]*\s*:\s*(.*\S)\s*$/;
	    $value = $self->eval ($1);
	    $tagname = $tag;
	    $tagname =~ s/^([a-z_]*).*$/$1/;
	    $package_ref->push_tag ($tagname, $value);
	    return 1;
	}
    }

    $self->{error} = "Unknown tag: $line";
    return 0;
}

sub _process_define ($$$) {
    my $self = shift;
    my $fhandle = shift;
    my $line = shift;

    if ($line =~ /\s*%define\s+([a-zA-Z0-9_]*)\s+(.*\S)\s*$/) {
	my $tag = lc($1);
	my $value = $2;
	$self->{_defines}->{$1} = $2;
	return 1;
    }

    return 0;
}

sub _process_package ($$$) {
    my $self = shift;
    my $fhandle = shift;
    my $line = shift;

    my $package_name;

    if ($line =~ /\s*%[pP][aA][cC][kK][aA][gG][eE]\s+-n\s+(\S+)\s*$/) {
	$package_name = $1;
    } elsif ($line =~ /\s*%[pP][aA][cC][kK][aA][gG][eE]\s+(\S+)\s*$/) {
	my $mainpkg_ref = \$self->{_packages}[0];
	$package_name = $$mainpkg_ref->get_tag ("name") . "-" . $1;
    } else {
	$self->{error} = "invalid %package directive: $line";
	return 0;
    }

    my $new_package = rpm_package->new_subpackage (\$self, $package_name);
    my $ref = $self->{_packages};
    push (@$ref, $new_package);
    my $packagebase = new packagebase;
    $packagebase->add_package ($new_package);
    $self->{_current_package} = $new_package;

    $line = $self->_get_next_line ($fhandle);
    if (defined ($line)) {
	return $self->_process_top_level ($fhandle, $line);
    }

    return 1;
}

sub _preprocess_line ($$) {
    my $self = shift;
    my $line = shift;

    my $lcline = lc($line);
    chomp ($line);
    $lcline =~ s/^\s*//;

    $line = $self->eval ($line);

    return ($line, $lcline);
}

sub _get_unpack_commands ($$) {
    my $srcname = shift;
    my $opt_q = shift;
    my $unpack;
    my $uncompress;

    if (not defined $opt_q) {
	$unpack = " | /bin/tar xvf -";
    } else {
	$unpack = " | /bin/tar xf -";
    }
    if ($srcname =~ /(\.tar\.bz2|\.tbz|\.tbz2)$/) {
	$uncompress = "/usr/bin/bzip2 -dc";
    } elsif ($srcname =~ /(\.tar\.gz|\.tgz)$/) {
	$uncompress = "/usr/bin/gzip -dc";
    } elsif ($srcname =~ /(\.tar)$/) {
	$uncompress = "/bin/cat";
    } elsif ($srcname =~ /(\.zip)$/) {
	if (not defined $opt_q) {
	    $uncompress = "unzip";
	} else {
	    $uncompress = "unzip -q";
	}
	$unpack = "";
    } elsif ($srcname =~ /(\.jar)$/) {
	$uncompress = "/bin/cat";
	if (not defined $opt_q) {
	    $unpack = " | jar xvf -";
	} else {
	    $unpack = " | jar xf -";
	}
    } else {
## TODO: add CVS checkout
	print "WARNING: I don't know how to unpack $srcname\n";
	$unpack = "/bin/cat";
    }

    return ($uncompress, $unpack);
}

sub _process_macro ($$$$$$) {
    my $self = shift;
    my $name = shift;
    my $package = shift;
    my $macro = shift;
    my $block_name = shift;
    my $line = shift;

    my %macro_opts;
    if (defined ($name)) {
	if (defined ($package)) {
	    $line =~ s/\s*%$name.$package.$macro(\s*)/$1/;
	    $line =~ s/\s*%{$name.$package.$macro}(\s*)/$1/;
	} else {
	    $line =~ s/\s*%$name.$macro(\s*)/$1/;
	    $line =~ s/\s*%{$name.$macro}(\s*)/$1/;
	}
    } else {
	$line =~ s/\s*%$macro(\s*)/$1/;
	$line =~ s/\s*%{$macro}(\s*)/$1/;
    }
    my @opts = split /\s+-/, $line;
    foreach my $opt (@opts) {
	if ($opt =~ /(\S+)\s+(.*)/) {
	    $macro_opts{$1}=$2;
	} elsif ($opt =~ /([a-zA-Z])([0-9]+)/) {
	    $macro_opts{$1}=$2;	    
	} else {
	    $macro_opts{$opt} = '';
	}
    }

    my $macro_expansion = '';

    if (defined ($name)) {
	my $spec_used = $self->{_specs_used}->{$name};
	my $scriptlet;

	if ($macro =~ /^(pre|post|preun|postun|verifyscript)$/) {
	    $pkg_ref = $$spec_used->find_package_by_name ($package);
	    if (not defined($pkg_ref)) {
		print "WARNING: subpackage not found: $name.$package\n";
	    } else {
		$scriptlet = $pkg_ref->get_block ($macro);
	    }
	} else {
	    $scriptlet = $$spec_used->get_block ($macro);
	}
	if (not defined ($scriptlet)) {
	    $scriptlet = "";
	}
	if (defined ($macro_opts{'d'})) {
	    $scriptlet = "cd %{_builddir}/$macro_opts{'d'}\n${scriptlet}cd ..";
	}
	if ($macro eq "prep") {
	    $scriptlet = "cd %{_builddir}\n$scriptlet";
	}
	$macro_expansion = $scriptlet;
    } else {
	if ($macro =~ /setup([0-9]*)/) {
	    my $num = $1;
	    if ($num eq "") {
		$num = 0;
	    }

	    my $dirname = "%name-%version";
	    if (defined ($macro_opts{'n'})) {
		$dirname = $macro_opts{'n'};
	    }
	    if (not defined ($self->{_defines}->{_build_src_dir_name})) {
		$self->{_defines}->{_build_src_dir_name} = $dirname;
	    } 
	    $macro_expansion = "";

	    if (not defined ($macro_opts{'D'})) {
		$macro_expansion = $macro_expansion . "rm -rf $dirname\n";
	    }
	    if (defined ($macro_opts{'c'})) {
		$macro_expansion = $macro_expansion . "mkdir $dirname\n" .
		    "cd $dirname\n";
	    }
	    if (not defined ($macro_opts{'T'})) {
		my $srcname = $self->get_value_of("SOURCE$num");
		my $uncompress;
		my $unpack;
		($uncompress, $unpack) = 
		    _get_unpack_commands ($srcname, $macro_opts{'q'});
		$macro_expansion = $macro_expansion .
		    "$uncompress %SOURCE$num$unpack\n";
	    }
	    if (defined ($macro_opts{'b'})) {
		my $srcnum = $macro_opts{'b'};
		if ($srcnum =~ /^[0-9]+$/) {
		    my $srcname = $self->eval("%SOURCE$srcnum");
		    my $uncompress;
		    my $unpack;
		    ($uncompress, $unpack) = 
			_get_unpack_commands ($srcname, $macro_opts{'q'});
		    $macro_expansion = $macro_expansion .
			"$uncompress %SOURCE$srcnum$unpack\n";
		    $macro_expansion = $macro_expansion .
			"STATUS=$?\n" .
			"if [ $STATUS -ne 0 ]; then\n" .
			"  exit $STATUS\n" .
			"fi\n";
		} else {
		    print "ERROR: numeric argument required after -a option of %setup\n";
		}
	    }
	    if (not defined ($macro_opts{'c'})) {
		$macro_expansion = $macro_expansion . "cd $dirname\n";
	    }
	    if (defined ($macro_opts{'a'})) {
		my $srcnum = $macro_opts{'a'};
		if ($srcnum =~ /^[0-9]+$/) {
		    my $srcname = $self->eval("%SOURCE$srcnum");
		    my $uncompress;
		    my $unpack;
		    ($uncompress, $unpack) = 
			_get_unpack_commands ($srcname, $macro_opts{'q'});
		    $macro_expansion = $macro_expansion .
			"$uncompress %SOURCE$srcnum$unpack\n";
		} else {
		    print "ERROR: numeric argument required after -a option of %setup\n";
		}
	    }
	    if ($os eq "solaris") {
		$macro_expansion = $macro_expansion . 
		    "[ `/usr/xpg4/bin/id -u` = 0 ] && /bin/chown -Rhf root .\n";
		$macro_expansion = $macro_expansion .
		    "[ `/usr/xpg4/bin/id -u` = 0 ] && /bin/chgrp -Rhf other .\n";
	    } else {
		$macro_expansion = $macro_expansion . 
		    "[ `/usr/bin/id -u` = 0 ] && /bin/chown -Rhf root .\n";
		$macro_expansion = $macro_expansion .
		    "[ `/usr/bin/id -u` = 0 ] && /bin/chgrp -Rhf root .\n";
	    }
	    $macro_expansion = $macro_expansion .
		"/bin/chmod -Rf a+rX,g-w,o-w .\n";
	} elsif ($macro =~ /^patch([0-9]*)/) {
	    my $num = $macro_opts{'P'};
	    if (not defined($num)) {
		if (not defined ($1)) {
		    $num = 0;
		} else {
		    $num = $1;
		}
	    }
	    if ($num eq "") {
		$num = 0;
	    }
	    my $package_ref = $self->{_packages}[0];
	    my @values = $package_ref->get_array ('patch');
	    my $val = $values[$num];
	    $val =~ s/^.*\/([^\/]*)/$1/;

	    my $patch_opts = '';
	    if (defined ($macro_opts{'p'})) {
		$patch_opts = $patch_opts . " -p $macro_opts{'p'}";
	    }
	    if (defined ($macro_opts{'E'})) {
		$patch_opts = $patch_opts . " -E";
	    }
	    if (defined ($macro_opts{'b'})) {
		$patch_opts = $patch_opts . " -b -z $macro_opts{'b'}";
	    }
	    $macro_expansion = "patch $patch_opts < %{_sourcedir}/$val"
	}
    }

    $self->_append_to_block($block_name, $self->eval ($macro_expansion));
}

sub _process_block ($$$;$$) {
    my $self = shift;
    my $fhandle = shift;
    my $line = shift;
    my $block_name = shift;
    my $package_name = shift;

    my $package_ref = $self->{_packages}[0];
    if (not defined ($block_name) or not defined($package_name)) {

	$line =~ /^\s*%([a-z]*)/;
	$block_name = $1;

	if ($line =~ /^\s*%$block_name\s+-n\s+(\S+)\s*$/) {
	    $package_name = $1;
	} elsif ($line =~ /^\s*%$block_name\s+(\S+)\s*$/) {
	    $package_name = $package_ref->get_name() . "-" . $1;
	} else {
	    $package_name = $package_ref->get_name();
	}
    }

    $package_ref = undef;
    my $all_packages = $self->{_packages};
    foreach $package (@$all_packages) {
	if ($package->get_name() eq $package_name) {
	    $package_ref = $package;
	}
    }

    if (not defined ($package_ref)) {
	$self->{error} = "Package $package_name not defined in $line";
	return 0;
    }

    if (not defined $self->{_blocks}->{$block_name}) {
	if ($block_name =~ /(build|install|clean)/) {
	    my $dirname = $self->eval ("%{_build_src_dir_name}");
	    if ($dirname eq "%{_build_src_dir_name}") {
		$dirname = $self->eval ("%name-%version");
	    }
	    $self->{_blocks}->{$block_name} = "cd $dirname\n";
	} else {
	    $self->{_blocks}->{$block_name} = "";
	}
    }

    my $lcline;

    while (1) {
	$line = $self->_get_next_line ($fhandle);
	if (not defined($line)) {
	    last;
	}

	($line, $lcline) = $self->_preprocess_line ($line);

	if ($lcline =~ /^\s*%define/) {
	    if (not $self->_process_define ($fhandle, $line)) {
		return (0);
	    }
	} elsif ($lcline =~ /^\s*%include/) {
	    $self->_process_include ($fhandle, $line, \&_process_block, 
				     ($block_name, $package_name));
	} elsif ($lcline =~ /^\s*%setup/) {
	    $self->_process_macro (undef, undef, "setup", $block_name, $line);
	} elsif ($lcline =~ /^\s*%patch/) {
	    $self->_process_macro (undef, undef, "patch", $block_name, $line);
	} elsif ($lcline =~ /^\s*%([a-zA-Z_][a-zA-Z0-9_]*)\.(prep|build|install|clean|changelog|pre|post|preun|postun|verifyscript)/) {
	    if (defined ($self->{_specs_used}->{$1})) {
		$self->_process_macro ($1, undef, $2, $block_name, $line);
	    } else {
		print "WARNING: undefined macro in $line\n";
	    }
	} elsif ($lcline =~ /^\s*%([a-zA-Z_][a-zA-Z0-9_]*)\.([a-zA-Z_][a-zA-Z0-9_-]*)\.(prep|build|install|clean|changelog|pre|post|preun|postun|verifyscript)/) {
	    if (defined ($self->{_specs_used}->{$1})) {
		$self->_process_macro ($1, $2, $3, $block_name, $line);
	    } else {
		print "WARNING: undefined macro in $line\n";
	    }
	} elsif (not $line =~ /^\s*%/) {
	    if ($block_name =~ /(prep|build|install|clean|changelog)/) {
		$self->_append_to_block ($block_name, $self->eval ($line));
	    } else {
		$package_ref->append_to_block ($block_name, $self->eval ($line));
	    }
	} else {
	    return $self->_process_top_level ($fhandle, $line);
	}
    }

    return 1;
}

sub _process_files ($$$;$) {
    my $self = shift;
    my $fhandle = shift;
    my $line = shift;
    my $package_name = shift;

# TODO: %files -f not implemented!

    my $package_ref = $self->{_packages}[0];
    if (not defined($package_name)) {
	if ($line =~ /^\s*%files\s+-n\s+(\S+)\s*$/) {
	    $package_name = $1;
	} elsif ($line =~ /^\s*%files\s+(\S+)\s*$/) {
	    $package_name = $package_ref->get_name() . "-" . $1;
	} else {
	    $package_name = $package_ref->get_name();
	}
    }

    $package_ref = undef;
    my $all_packages = $self->{_packages};
    foreach $package (@$all_packages) {
	if ($package->get_name() eq $package_name) {
	    $package_ref = $package;
	}
    }

    if (not defined ($package_ref)) {
	$self->{error} = "Package $package_name not defined in $line";
	return 0;
    }

    my @defattr = ('-', '-', '-');
    my @all_verify = rpm_file->get_all_verify();

    my @this_attr = (@defattr);
    my $is_doc = 0;
    my $is_config = 0;
    my @this_verify = (@all_verify);
    my $is_dir = 0;

    $line = $self->_get_next_line ($fhandle);
    if (not defined($line)) {
	return 1;
    }
    ($line, $lcline) = $self->_preprocess_line ($line);

    while (1) {
	if ($lcline =~ /^\s*%define/) {
	    if (not $self->_process_define ($fhandle, $line)) {
		return (0);
	    }
	} elsif ($lcline =~ /^\s*%include/) {
	    $self->_process_include ($fhandle, $line, \&_process_files,
				     ($package_name));
	} elsif ($lcline =~ /^\s*%defattr\s*\(\s*(-|[0-9]+)\s*,\s*(-|[a-zA-Z][a-zA-Z_-]*)\s*,\s*(-|[a-zA-Z][a-zA-Z_-]*)\s*\)\s*$/) {
	    @defattr = ($1, $2, $3);
	} elsif ($lcline =~ /^\s*%doc/) {
	    $is_doc = 1;
	    $lcline =~ s/^\s*%doc\s*//;
	    $line =~ s/^\s*%doc\s*//;
	    next;
	} elsif ($lcline =~ /^\s*%config/) {
	    $is_config = 1;
	    $lcline =~ s/^\s*%config\s*//;
	    $line =~ s/^\s*%config\s*//;
	    next;	    
	} elsif ($lcline =~ /^\s*%attr\s*\(\s*(-|[0-9]+)\s*,\s*(-|[a-zA-Z][a-zA-Z_-]*)\s*,\s*(-|[a-zA-Z][a-zA-Z_-]*)\s*\)\s*/) {
	    @this_attr = ($1, $2, $3);
	    $lcline =~ s/^\s*%attr\s*\([^\)]*\)\s*//;
	    $line =~ s/^\s*%attr\s*\([^\)]*\)\s*//;
	    next;
	} elsif ($lcline =~ /^\s*%verify\s*\(([^\)]*)\)/) {
	    @this_verify = split /\s+/, $1;
	    $lcline =~ s/^\s*%verify\s*\([^\)]*\)//;
	    $line =~ s/^\s*%verify\s*\([^\)]*\)//;
	    next;
	} elsif ($lcline =~ /^\s*%docdir/) {
	    $is_doc = 1;
	    $is_dir = 1;
	    $lcline =~ s/^\s*%docdir\s*//;
	    $line =~ s/^\s*%docdir\s*//;
	    next;
	} elsif ($lcline =~ /^\s*%dir/) {
	    $is_dir = 1;
	    $lcline =~ s/^\s*%dir\s*//;
	    $line =~ s/^\s*%dir\s*//;
	    next;
	} elsif ($line =~ /^\s*(\/.*\S)\s*$/) {
	    my $file = rpm_file->new ($1, \@this_attr, \@this_verify,
				     not ($is_dir), $is_doc,
				     $is_config);
	    $package_ref->add_file ($file);
	} else {
	    return $self->_process_top_level ($fhandle, $line);
	}

	@this_attr = (@defattr);
	$is_doc = 0;
	$is_config = 0;
	@this_verify = (@all_verify);
	$is_dir = 0;

	$line = $self->_get_next_line ($fhandle);
	if (not defined($line)) {
	    last;
	}
	($line, $lcline) = $self->_preprocess_line ($line);
    }

    return 1;
}

sub _process_top_level ($$$) {
    my $self = shift;
    my $fhandle = shift;
    my $line = shift;

    my $lcline = lc($line);
    chomp ($line);
    $lcline =~ s/^\s*//;

    if ($lcline =~ /^#/) {
	# comment, nothing to do.
	return 1;
    } elsif ($lcline eq "") {
	return 1;
    } elsif ($lcline =~ /^\s*%use/) {
	return $self->_process_use ($fhandle, $line);
    } elsif ($lcline =~ /^\s*%include/) {
	return $self->_process_include ($fhandle, $line, \&_process_top_level, ());
    } elsif ($lcline =~ /^\s*%package/) {
	return $self->_process_package ($fhandle, $line);
    } elsif ($lcline =~ /^\s*%(description|prep|build|install|clean|changelog|pre|post|preun|postun|verifyscript)/) {
	return $self->_process_block ($fhandle, $line);
    } elsif ($lcline =~ /^\s*%files/) {
	return $self->_process_files ($fhandle, $line);
    } elsif ($lcline =~ /^\s*%define/) {
	return $self->_process_define ($fhandle, $line);
    } elsif ($lcline =~ /^\s*\S+\s*:\s*\S+/) {
	return $self->_process_tag ($fhandle, $line);
    }

    $self -> {error} = "Unable to process line " . $line;
    return 0;
}

sub _read_spec ($) {
    my $self = shift;

    my $fhandle = "SPEC_FILE" . $file_id++;
    my $fname = $self->{_file_name};

    open $fhandle, "<$fname" or 
	$self->{error} = "Could not open file $fname for reading",
	return (0);

    my $line;

    $self->{_being_loaded} = 1;
    $self->{_current_package} = $self->{_packages}[0];

    while (1) {
	$line = <$fhandle>;
	if (not defined ($line)) {
	    last;
	}
	if (not $self->_process_top_level ($fhandle, $line)) {
	    $self->{_being_loaded} = 0;
	    $self->{_loaded} = 1;
	    return (0);
	}
    }

    close $fhandle;

    $self->{_current_package} = $self->{_packages}[0];
    $self->{_being_loaded} = 0;
    $self->{_loaded} = 1;

    return (1);
}

sub get_name ($) {
    my $self = shift;

    if (! $self->{_loaded} and ! $self->{_being_loaded}) {
	if (not $self->_read_spec ()) {
	    print "ERROR: " . $self->{error} . "\n";
	    return undef;
	}
    }

    my $package = $self->{_packages}[0];
    return $package->get_tag ("name");
}

sub get_packages ($) {
    my $self = shift;

    if (! ($self->{_loaded} or $self->{_being_loaded})) {
	if (not $self->_read_spec ()) {
	    print "ERROR: " . $self->{error} . "\n";
	    return undef;
	}
    }

    my $ref = $self->{_packages};
    return @$ref;
}

sub block_is_defined ($$) {
    my $self = shift;
    my $block_name = shift;

    if (! $self->{_loaded} and ! $self->{_being_loaded}) {
	if (not $self->_read_spec ()) {
	    print "ERROR: " . $self->{error} . "\n";
	    return undef;
	}
    }

    return defined ($self->{_blocks}->{$block_name});
}

sub _append_to_block ($$$) {
    my $self = shift;
    my $block_name = shift;
    my $text_to_append = shift;

    if (defined ($self->{_blocks}->{$block_name})) {
	$self->{_blocks}->{$block_name} = 
	    $self->{_blocks}->{$block_name} . "\n" . $text_to_append;
    } else {
	$self->{_blocks}->{$block_name} = $text_to_append;
    }
}

sub get_block ($$) {
    my $self = shift;
    my $block_name = shift;

    if (! $self->{_loaded} and ! $self->{_being_loaded}) {
	if (not $self->_read_spec ()) {
	    print "ERROR: " . $self->{error} . "\n";
	    return undef;
	}
    }

    return $self->{_blocks}->{$block_name};
}

sub get_file_name ($) {
    my $self = shift;

    return $self->{_file_name};
}

sub get_base_file_name ($) {
    my $self = shift;

    return $self->{_base_file_name};
}

sub get_value_of ($$) {
    my $self = shift;
    my $name = lc (shift);

    if (! $self->{_loaded} and ! $self->{_being_loaded}) {
	if (not $self->_read_spec ()) {
	    print "ERROR: " . $self->{error} . "\n";
	    return undef;
	}
    }

    my $package_ref = $self->{_packages}[0];
    if ($package_ref->tag_is_defined ($name)) {
	return $package_ref->get_tag ($name);
    } elsif ($name =~ /^source([0-9]*)$/) {
	my $num = $1;
	if (not defined ($num)) {
	    $num = 0;
	}
	my @values = $package_ref->get_array ('source');
	my $val = $values[$num];
	$val =~ s/^.*\/([^\/]*)/$1/;
	return "%{_sourcedir}/$val";
    } else {
	return $self->{_defines}->{$name};
    }
}

init();
1;
