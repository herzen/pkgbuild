@WARNING_MESSAGE_L1@
@WARNING_MESSAGE_L2@
@WARNING_MESSAGE_L3@
@WARNING_MESSAGE_L4@
@WARNING_MESSAGE_L5@
@WARNING_MESSAGE_L6@
@WARNING_MESSAGE_L7@

#use strict;

use warnings;
use rpm_package;
use rpm_file;
use packagebase;

package rpm_spec;

sub get_name ($);

use overload ('""' => \&get_name);	  

my $arch;
my $os;
my $os_rel;

my $_default_topdir = "@TOPDIR@";

sub init () {
    $arch = `uname -p`;
    chomp ($arch);
    if ($arch eq "unknown") {
	$arch = `uname -m`;
	chomp ($arch);
	if ($arch eq 'i585') {
	    $arch = 'i386';
	} elsif ($arch eq 'i686') {
	    $arch = 'i386';
	}
    }

    $os = `uname -s`;
    chomp ($os);
    $os = lc($os);
    $os_rel = `uname -r`;
    chomp ($os_rel);
    if ($os eq 'sunos') {
	if ($os_rel >= 5) {
	    $os = 'solaris';
	}
    }

    if ($os eq "linux") {
	foreach my $dir (@INC) {
	    if (-f "$dir/get_rpm_topdir") {
		$_default_topdir = `rpm -ba $dir/get_rpm_topdir 2>&1 | grep '^TOPDIR=' | cut -f2 -d=`;
		chomp ($_default_topdir);
		last;
	    }
	}
    }
}

# Create a new rpm_spec object.
# Return undef if the spec_file is not found
sub new ($;$$) {
    my $class = shift;
    my $spec_file = shift;
    my $predef_ref = shift;
    my $parent_spec = shift;
    my $self = {};
    
    if (! -r $spec_file) {
	return (undef);
    }
    
    if ((not defined ($predef_ref) or not @$predef_ref) and
	not defined $parent_spec) {
	my $packagebase = new packagebase ();
	my $spec = $packagebase->find_spec_by_file_name ($spec_file);
	if (defined ($spec)) {
	    return ($spec);
	}
    }

    $self->{_file_name} = $spec_file;
    my $base_file_name = $spec_file;
    $base_file_name =~ s/^.*\/([^\/]*)$/$1/;
    $self->{_base_file_name} = $base_file_name;
    $self->{_loaded} = 0;
    $self->{_being_loaded} = 0;
    $self->{_defines} = {};
    $self->{_specs_used} = {};
    $self->{_blocks} = {};
    $self->{_in_conditional} = 0;

    if (defined ($parent_spec)) {
	my $parent_def_ref = $parent_spec->{_defines};
	$self->{_defines} = {%$parent_def_ref};
	delete ($self->{_defines}->{_build_src_dir_name});
    } else {
	$self->{_defines}->{_pkgbuild} = "pkgbuild";
	$self->{_defines}->{_pkgbuild_version} = "@PKGBUILD_VERSION@";
	$self->{_defines}->{_target} = "i386";
	$self->{_defines}->{_sysconfdir} = "/etc";
	$self->{_defines}->{_initrddir} = "%{_sysconfdir}/rc.d/init.d";
	$self->{_defines}->{_prefix} = "/usr";
	$self->{_defines}->{_exec_prefix} = "%{_prefix}";
	$self->{_defines}->{_bindir} = "%{_exec_prefix}/bin";
	$self->{_defines}->{_lib} = "lib";
	$self->{_defines}->{_libdir} = "%{_exec_prefix}/%{_lib}";
	$self->{_defines}->{_libexecdir} = "%{_exec_prefix}/libexec";
	$self->{_defines}->{_sbindir} = "%{_exec_prefix}/sbin";
	$self->{_defines}->{_sharedstatedir} = "%{_prefix}/com";
	$self->{_defines}->{_datadir} = "%{_prefix}/share";
	$self->{_defines}->{_includedir} = "%{_prefix}/include";
	$self->{_defines}->{_oldincludedir} = "/usr/include";
	$self->{_defines}->{_infodir} = "/usr/share/info";
	$self->{_defines}->{_mandir} = "/usr/share/man";
	$self->{_defines}->{_localstatedir} = "/var";
	$self->{_defines}->{_defaultdocdir} = "%_prefix/doc";
	$self->{_defines}->{_docdir} = "%_datadir/doc";
	$self->{_defines}->{__libtoolize} = "libtoolize";
    
	$self->{_defines}->{_global_cflags} = "-O2 -g -pipe";
	$self->{_defines}->{optflags} = "%{_global_cflags}";
	$self->{_defines}->{_var} = "/var";
	$self->{_defines}->{_tmppath} = "%{_var}/tmp";
	$self->{_defines}->{_usr} = "/usr";
	$self->{_defines}->{_usrsrc} = "%{_usr}/src";

	$self->{_defines}->{_topdir} = $_default_topdir;
	$self->{_defines}->{_builddir} = "%{_topdir}/BUILD";
	$self->{_defines}->{_rpmdir} = "%{_topdir}/RPMS";
	$self->{_defines}->{_sourcedir} = "%{_topdir}/SOURCES";
	$self->{_defines}->{_specdir} = "%{_topdir}/SPECS";
	$self->{_defines}->{_srcrpmdir} = "%{_topdir}/SRPMS";
    }

    if (defined ($predef_ref)) {
	foreach my $predef (@$predef_ref) {
	    next if not defined $predef;
	    if ($predef =~ /^\s*([a-zA-Z0-9_]*)\s+(.*\S)\s*$/) {
		$self->{_defines}->{$1} = $2;
	    } else {
		print "ERROR: invalid definition $predef\n";
		return undef;
	    }
	}
    }
    
    bless ($self, $class);
    my $main_package = rpm_package->new (\$self);
    my @packages = ($main_package);
    $self->{_packages} = \@packages;

    if ((not defined ($predef_ref) or not @$predef_ref) and
	not defined $parent_spec) {
	my $packagebase = new packagebase ();
	$packagebase->add_package ($main_package);
	$packagebase->add_spec ($self);
    }

    return $self;
}

sub eval ($$) {
    my $self = shift;
    my $str = shift;

    my $def;
    my $val;
    my $name;

    if (not defined ($str)) {
	return undef;
    }

    if ($str =~ /^#/) {
	return $str;
    }

    $str =~ s/\%{S:([0-9]+)}/%{SOURCE$1}/g;
    $str =~ s/\%{P:([0-9]+)}/%{PATCH$1}/g;

    my $repeat_deref = 1;
    while ($repeat_deref) {
	$repeat_deref = 0;
	if ($str =~ /\%{\?([^:]*):(.*)}/) {
            $name = $1;
	    $def = $2;
            $repeat_deref = 1;
	    $val = $self->get_value_of ($name);
	    if (not defined ($val)) {
		$str =~ s/\%{\?([^:]*):(.*)}//;
            } else {
                $str =~ s/\%{\?([^:]*):(.*)}/$2/;
            }
        }
    }
    if ($str =~ /\%{\?(.*)/) {
	$self->{error} = "unterminated %{?$1";
	return "";
    }

    $repeat_deref = 1;
    while ($repeat_deref) {
	$repeat_deref = 0;
	if ($str =~ /\%(?:{([a-zA-Z_][a-zA-Z0-9_]*)\.([a-zA-Z_][a-zA-Z0-9_]*)}|([a-zA-Z_][a-zA-Z0-9_]*)\.([a-zA-Z_][a-zA-Z0-9_]*))/) {
	    $name = $1;
	    $def = $2;
	    $repeat_deref = 1;	    

	    if (not defined $name) {
		$name = $3;
		$def = $4;
	    }

	    if (not defined ($self->{_specs_used}->{$name})) {
		print "WARNING: undefined tag %$name at \"$str\".\nForgotten or mistyped %use?\n";
		$val = undef;
	    } else {
		my $spec_used = $self->{_specs_used}->{$name};
		$val = $$spec_used->get_value_of ($def);
	    }

	    if (not defined ($val)) {
		$str =~ s/\%{$name.$def}/#p#E#r#C#e#N#t#{$name.$def}/ or
		    $str =~ s/\%$name.$def([^a-zA-Z0-9_])/#p#E#r#C#e#N#t#$name.$def$1/ or
		    $str =~ s/\%$name.$def$/#p#E#r#C#e#N#t#$name.$def/;
	    } else {
		$str =~ s/\%{$name.$def}/$val/g;
		$str =~ s/\%$name.$def([^a-zA-Z0-9_])/$val/g;
		$str =~ s/\%$name.$def$/$val/g;
	    }
	}
    }

    $repeat_deref = 1;
    while ($repeat_deref) {
	$repeat_deref = 0;
	if ($str =~ /\%(?:{([a-zA-Z_][a-zA-Z0-9_]*)\.([a-zA-Z_][a-zA-Z0-9_-]*)\.([a-zA-Z_][a-zA-Z0-9_]*)}|([a-zA-Z_][a-zA-Z0-9_]*)\.([a-zA-Z_][a-zA-Z0-9_-]*)\.([a-zA-Z_][a-zA-Z0-9_]*))/) {
	    $name = $1;
	    my $pkg = $2;
	    $def = $3;
	    $repeat_deref = 1;	    

	    if (not defined $name) {
		$name = $4;
		$pkg = $5;
		$def = $6;
	    }

	    if (not defined ($self->{_specs_used}->{$name})) {
		print "WARNING: undefined tag %$name at \"$str\".\nForgotten or mistyped %use?\n";
		$val = undef;
	    } else {
		my $spec_used = $self->{_specs_used}->{$name};
		my $pkg_ref = $$spec_used->find_package_by_name ($pkg);
		if (not defined ($pkg_ref)) {
		    $val = undef;
		} else {
		    $val = $$pkg_ref->get_tag ($def);
		}
	    }

	    if (not defined ($val)) {
		$str =~ s/\%{$name.$def}/#p#E#r#C#e#N#t#{$name.$def}/ or
		    $str =~ s/\%$name.$def([^a-zA-Z0-9_])/#p#E#r#C#e#N#t#$name.$def$1/ or
		    $str =~ s/\%$name.$def$/#p#E#r#C#e#N#t#$name.$def/;
	    } else {
		$str =~ s/\%{$name.$def}/$val/g;
		$str =~ s/\%$name.$def([^a-zA-Z0-9_])/$val/g;
		$str =~ s/\%$name.$def$/$val/g;
	    }
	}
    }

    $repeat_deref = 1;
    while ($repeat_deref) {
	$repeat_deref = 0;
	if ($str =~ /\%(?:{([a-zA-Z_][a-zA-Z0-9_]*)}|([a-zA-Z_][a-zA-Z0-9_]*))/) {
	    $def = $1;
	    $repeat_deref = 1;

	    if (not defined $def) {
		$def = $2;
	    }

	    $val = $self->get_value_of ($def);

	    if (not defined ($val)) {
		$str =~ s/\%{$def}/#p#E#r#C#e#N#t#{$def}/ or
		    $str =~ s/\%$def([^a-zA-Z0-9_])/#p#E#r#C#e#N#t#$def$1/ or
		    $str =~ s/\%$def$/#p#E#r#C#e#N#t#$def/;
	    } else {
		$str =~ s/\%{$def}/$val/g;
		$str =~ s/\%$def([^a-zA-Z0-9_])/$val$1/g;
		$str =~ s/\%$def$/$val/g;
	    }
	}

    }

    $str =~ s/#p#E#r#C#e#N#t#/%/g;
    return ($str);
}

sub _eat_lines ($$) {
    my $self = shift;
    my $fhandle = shift;
    my $line;

    my $depth = 1;

    while (1) {
	$line = <$fhandle>;
	if (not defined $line) {
	    last;
	}
	if ($line =~ /^\s*%if(arch|os)/) {
	    $depth++;
	} elsif ($line =~ /^\s*%else/) {
	    $depth--;
	    if ($depth == 0) {
		return "%else";
	    }
	} elsif ($line =~ /^\s*%endif/) {
	    $depth--;
	    if ($depth == 0) {
		return "%endif";
	    }
	}
    }
    return undef;
}

sub _get_next_line ($$) {
    my $self = shift;
    my $fhandle = shift;

    my $line = <$fhandle>;
    if (not defined $line) {
	return undef;
    }

    if ($line =~ /^%if(arch|os|narch|nos)/) {
	my $cond = 0;
	
	if ($line =~ /^%ifarch\s+(\S*)/) {
	    $cond = ("$arch" eq "$1");
	} elsif ($line =~ /^%ifnarch\s+(\S*)/) {
	    $cond = ("$arch" ne "$1");
	} elsif ($line =~ /^%ifos\s+(\S*)/) {
	    $cond = ("$os" eq "$1");
	} elsif ($line =~ /^%ifnos\s+(\S*)/) {
	    $cond = ("$os" ne "$1");
	}

	++$self->{_in_conditional};

	if ($cond) {
	    $line = $self->_get_next_line ($fhandle);
	    if (not defined($line)) {
		$self->{error} = "Unclosed %if";
		return undef;
	    }
	    return $line;
	}

	my $lastline = $self->_eat_lines ($fhandle);

	if (not defined $lastline) {
	    return undef;
	}
	if ($lastline eq "%endif") {
	    --$self->{_in_conditional};
	}
	$line = $self->_get_next_line ($fhandle);
	return $line;

    } elsif ($line =~ /^\s*%else/) {
	if ($self->{_in_conditional} == 0) {
	    $self->{error} = "$fhandle: Got a %else with no if";
	    return undef;
	}
	my $lastline = $self->_eat_lines ($fhandle);
	if (not defined $lastline) {
	    return undef;
	}
	if ($lastline eq "%else") {
	    $self->{error} = "%endif expected, %else found";
	    $line = undef;
	}
	if ($lastline eq "%endif") {
	    --$self->{_in_conditional};
	    $line = $self->_get_next_line ($fhandle);
	}
	return $line;
    } elsif ($line =~ /^\s*%endif/) {
	if ($self->{_in_conditional} == 0) {
	    $self->{error} = "$fhandle: Got a %endif with no if";
	    return undef;
	}
	--$self->{_in_conditional};
	$line = $self->_get_next_line ($fhandle);
	return $line;
    }

    return $line;
}

sub _process_use ($$$) {
    my $self = shift;
    my $fhandle = shift;
    my $line = shift;

    my $name;
    my $fname;
    if ($line =~ /\s*%use\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*=\s*(\S+)\s*$/) {
	$name = $1;
	$fname = $2;
    } else {
	$self->{error} = "syntax error in %use directive: $line";
	return 0;
    }

    if ($fname =~ /^"(.*)"$/) {
	$fname = $1;
    }

    my $specdir = $self->get_value_of ("_specdir");
    my $spec = new rpm_spec ("$specdir/$fname", undef, $self);
    if (not defined ($spec)) {
	$self->{error} = "Could not open file $specdir/$fname";
	return 0;
    }

    $spec->get_value_of ("name");
    if (defined ($spec->{error})) {
	$self->{error}="$spec->{_base_file_name}: $spec->{error}";
	return 0;
    }

    $self->{_specs_used}->{$name} = \$spec;

    return 1;
}

# Global file id to make recursion possible
my $file_id = 1;

sub _process_include ($$$$@) {
    my $self = shift;
    my $fhandle = shift;
    my $line = shift;
    my $callback = shift;
    my @cbargs = @_;

    my $specdir = $self->get_value_of ("_specdir");
    my $fname = $line;
    $fname =~ s/\s*%include\s+(\S+)\s*/$1/ or
	$self->{error} = "Invalid %include command: $line",
	return (0);
    if ($fname =~ /^"(.*)"$/) {
	$fname = $1;
    }

    my $inc_fhandle = "SPEC_FILE" . $file_id++;
    open $inc_fhandle, "<$specdir/$fname" or
	$self->{error} = "Could not open %include file $specdir/$fname for reading",
	return (0);

    while (1) {
	$line = $self->_get_next_line ($inc_fhandle);
	if (not defined ($line)) {
	    last;
	}
	if (not $self->$callback ($inc_fhandle, $line, @cbargs)) {
	    return (0);
	}
    }

    close $inc_fhandle;

    if (defined $self->{error}) {
	return 0;
    }

    return (1);
}

sub _process_tag ($$$) {
    my $self = shift;
    my $fhandle = shift;
    my $line = shift;

    my @unique_tags = ("name", "version", "release",
		       "epoch",
		       "copyright", "license",
		       "distribution", "icon",
		       "url", "group",
		       "packager", "autoreqprov",
		       "serial", "nosource", "nopatch",
		       "sunw_basedir", "sunw_pkg",
		       "sunw_prodname", "sunw_prodvers",
		       "sunw_category", "sunw_hotline", 
		       "sunw_maxinst", "vendor", "sunw_rev",
		       "sunw_copyright",
		       "buildroot", "buildarchitectures", "buildarch",
		       "excludearch", "exclusivearch",
		       "excludeos", "exclusiveos", "prefix",
		       "summary", "version", "sunw_basedir",
		       "sunw_prodname", "sunw_prodvers",
		       "sunw_category", "sunw_hotline",
		       "sunw_maxinst", "vendor", "docdir",
		       "sunw_copyright");
    my @multi_tags = ("buildrequires", "requires", "obsoletes", "conflicts",
		      "prereq", "provides", "buildprereq");
    my @ord_tags = ( "source", "patch" );
    my @localised_tags = ("summary");
    my $lcline = lc($line);
    chomp ($line);
    $lcline =~ s/^\s*//;
    my $tagname;
    my $value;
    my $package_ref = $self->{_current_package};

    foreach my $tag (@unique_tags) {
	if ($lcline =~ /^$tag\s*:\s*/) {
	    $line =~ /^\s*[a-zA-Z0-9_-]*\s*:\s*(.*\S)\s*$/;
	    $value = $1;
	    $tagname = $tag;
	    $tagname =~ s/^([a-z_]*).*$/$1/;
	    $package_ref->set_tag ($tagname, $self->eval ($value));
	    return 1;
	}
    }

    foreach my $tag (@multi_tags) {
	if ($lcline =~ /^$tag\s*:\s*/) {
	    $line =~ /^\s*[a-zA-Z0-9_-]*\s*:\s*(.*\S)\s*$/;
	    $value = $self->eval ($1);
	    $tagname = $tag;
	    $tagname =~ s/^([a-z_]*).*$/$1/;
	    $package_ref->push_tag ($tagname, $value);
	    return 1;
	}
    }

    foreach my $tag (@ord_tags) {
	if ($lcline =~ /^$tag([0-9]*)\s*:\s*/) {
	    my $num = $1;
	    $line =~ /^\s*[a-zA-Z0-9_-]*\s*:\s*(.*\S)\s*$/;
	    $value = $self->eval ($1);
	    $tagname = $tag;
	    $tagname =~ s/^([a-z_]*).*$/$1/;
	    $package_ref->set_ord_tag ($tagname, $num, $value);
	    return 1;
	}
    }

    foreach my $tag (@localised_tags) {
	if ($lcline =~ /^$tag\(([^)]*)\)\s*:\s*/) {
	    my $locale = $1;
	    $line =~ /^\s*[a-zA-Z0-9()@_-]*\s*:\s*(.*\S)\s*$/;
	    $value = $1;
	    $tagname = $tag;
	    $tagname =~ s/^([a-z_]*).*$/$1/;
	    $package_ref->set_tag ("$tagname::$locale", $self->eval ($value));
	    return 1;
	}
    }

    $self->{error} = "Unknown tag: $line";
    return 0;
}

sub _process_define ($$$) {
    my $self = shift;
    my $fhandle = shift;
    my $line = shift;

    if ($line =~ /\s*%define\s+([a-zA-Z0-9_]*)\s+(.*\S)\s*$/) {
	my $tag = lc($1);
	my $value = $2;
	$self->{_defines}->{$1} = $2;
	return 1;
    }

    return 0;
}

sub _process_package ($$$) {
    my $self = shift;
    my $fhandle = shift;
    my $line = shift;

    my $package_name;

    if ($line =~ /\s*%[pP][aA][cC][kK][aA][gG][eE]\s+-n\s+(\S+)\s*$/) {
	$package_name = $1;
    } elsif ($line =~ /\s*%[pP][aA][cC][kK][aA][gG][eE]\s+(\S+)\s*$/) {
	my $mainpkg_ref = \$self->{_packages}[0];
	$package_name = $$mainpkg_ref->get_tag ("name") . "-" . $1;
    } else {
	$self->{error} = "invalid %package directive: $line";
	return 0;
    }

    my $new_package = rpm_package->new_subpackage (\$self, $package_name);
    my $ref = $self->{_packages};
    push (@$ref, $new_package);
    my $packagebase = new packagebase;
    $packagebase->add_package ($new_package);
    $self->{_current_package} = $new_package;

    $line = $self->_get_next_line ($fhandle);
    if (defined ($line)) {
	return $self->_process_top_level ($fhandle, $line);
    }

    if (defined $self->{error}) {
	return 0;
    }

    return 1;
}

sub _preprocess_line ($$) {
    my $self = shift;
    my $line = shift;

    my $lcline = lc($line);
    chomp ($line);
    $lcline =~ s/^\s*//;

    $line = $self->eval ($line);

    return ($line, $lcline);
}

sub _get_unpack_commands ($$) {
    my $srcname = shift;
    my $opt_q = shift;
    my $unpack;
    my $uncompress;

    if (not defined $opt_q) {
	$unpack = " | /bin/tar xvf -";
    } else {
	$unpack = " | /bin/tar xf -";
    }
    if ($srcname =~ /(\.tar\.bz2|\.tbz|\.tbz2)$/) {
	$uncompress = "/usr/bin/bzip2 -dc";
    } elsif ($srcname =~ /(\.tar\.gz|\.tgz)$/) {
	$uncompress = "/usr/bin/gzip -dc";
    } elsif ($srcname =~ /(\.tar)$/) {
	$uncompress = "/bin/cat";
    } elsif ($srcname =~ /(\.zip)$/) {
	if (not defined $opt_q) {
	    $uncompress = "unzip";
	} else {
	    $uncompress = "unzip -q";
	}
	$unpack = "";
    } elsif ($srcname =~ /(\.jar)$/) {
	$uncompress = "/bin/cat";
	if (not defined $opt_q) {
	    $unpack = " | jar xvf -";
	} else {
	    $unpack = " | jar xf -";
	}
    } else {
## TODO: add CVS checkout
	print "WARNING: I don't know how to unpack $srcname\n";
	$unpack = "/bin/cat";
    }

    return ($uncompress, $unpack);
}

sub find_package_by_name ($) {
    my $self = shift;
    my $name = shift;

    my $ref = $self->{_packages};
    foreach my $package (@$ref) {
	if ($package->get_tag ("name") eq $name) {
	    return $package;
	}
    }
    return undef;
}

sub _process_macro ($$$$$$) {
    my $self = shift;
    my $name = shift;
    my $package = shift;
    my $macro = shift;
    my $block_name = shift;
    my $line = shift;

    my %macro_opts;
    my $opt_line = $line;
    if (defined ($name)) {
	if (defined ($package)) {
	    $opt_line =~ s/\s*%$name.$package.$macro(\s*)/$1/;
	    $opt_line =~ s/\s*%{$name.$package.$macro}(\s*)/$1/;
	} else {
	    $opt_line =~ s/\s*%$name.$macro(\s*)/$1/;
	    $opt_line =~ s/\s*%{$name.$macro}(\s*)/$1/;
	}
    } else {
	$opt_line =~ s/\s*%$macro(\s*)/$1/;
	$opt_line =~ s/\s*%{$macro}(\s*)/$1/;
    }
    my @opts = split /\s+-/, $opt_line;
    foreach my $opt (@opts) {
	$opt =~ s/\s*$//;
	if ($opt =~ /(\S+)\s+(.*)/) {
	    $macro_opts{$1}=$2;
	} elsif ($opt =~ /([a-zA-Z])([0-9]+)/) {
	    $macro_opts{$1}=$2;	    
	} else {
	    $macro_opts{$opt} = '';
	}
    }

    my $macro_expansion = '';

    if (defined ($name)) {
	my $spec_used = $self->{_specs_used}->{$name};
	if (not defined $spec_used) {
	    $self->{error} = "name $name not found. Missing of mistyped %use?";
	    return 0;
	}
	my $scriptlet;

	if ($macro =~ /^(pre|post|preun|postun|verifyscript|triggerin|triggerun|triggerpostun)$/) {
	    $pkg_ref = $$spec_used->find_package_by_name ($package);
	    if (not defined($pkg_ref)) {
		print "WARNING: subpackage not found: $name.$package\n";
	    } else {
		$scriptlet = $pkg_ref->get_block ($macro);
	    }
	} else {
	    $scriptlet = $$spec_used->get_block ($macro);
	}
	if (not defined ($scriptlet)) {
	    $scriptlet = "";
	}
	if (defined ($macro_opts{'d'})) {
	    $scriptlet = "cd %{_builddir}/$macro_opts{'d'}\n${scriptlet}\ncd ..";
	}
	if ($macro eq "prep") {
	    $scriptlet = "cd %{_builddir}\n$scriptlet\n";
	}
	$macro_expansion = $scriptlet;
    } else {
	if ($macro =~ /setup([0-9]*)/) {
	    my $num = $1;
	    if ($num eq "") {
		$num = 0;
	    }

	    my $dirname = "%name-%version";
	    if (defined ($macro_opts{'n'})) {
		$dirname = $macro_opts{'n'};
	    }
	    if (not defined ($self->{_defines}->{_build_src_dir_name})) {
		$self->{_defines}->{_build_src_dir_name} = $dirname;
	    }
	    $macro_expansion = "";

	    if (not defined ($macro_opts{'D'})) {
		$macro_expansion = $macro_expansion . "rm -rf $dirname\n";
	    }
	    if (defined ($macro_opts{'c'})) {
		$macro_expansion = $macro_expansion . "mkdir $dirname\n" .
		    "cd $dirname\n";
	    }
	    if (not defined ($macro_opts{'T'})) {
		my $srcname = $self->get_value_of("SOURCE$num");
		my $uncompress;
		my $unpack;
		($uncompress, $unpack) = 
		    _get_unpack_commands ($srcname, $macro_opts{'q'});
		$macro_expansion = $macro_expansion .
		    "$uncompress %SOURCE$num$unpack\n";
	    }
	    if (defined ($macro_opts{'b'})) {
		my $srcnum = $macro_opts{'b'};
		if ($srcnum =~ /^[0-9]+$/) {
		    my $srcname = $self->eval("%SOURCE$srcnum");
		    my $uncompress;
		    my $unpack;
		    ($uncompress, $unpack) = 
			_get_unpack_commands ($srcname, $macro_opts{'q'});
		    $macro_expansion = $macro_expansion .
			"$uncompress %SOURCE$srcnum$unpack\n";
		    $macro_expansion = $macro_expansion .
			"STATUS=\$?\n" .
			"if [ \$STATUS -ne 0 ]; then\n" .
			"  exit \$STATUS\n" .
			"fi\n";
		} else {
		    $self->{error} = "numeric argument required after -a option of %setup\n";
		    return (0);
		}
	    }
	    if (not defined ($macro_opts{'c'})) {
		$macro_expansion = $macro_expansion . "cd $dirname\n";
	    }
	    if (defined ($macro_opts{'a'})) {
		my $srcnum = $macro_opts{'a'};
		if ($srcnum =~ /^[0-9]+$/) {
		    my $srcname = $self->eval("%SOURCE$srcnum");
		    my $uncompress;
		    my $unpack;
		    ($uncompress, $unpack) = 
			_get_unpack_commands ($srcname, $macro_opts{'q'});
		    $macro_expansion = $macro_expansion .
			"$uncompress %SOURCE$srcnum$unpack\n";
		} else {
		    print "ERROR: numeric argument required after -a option of %setup\n";
		}
	    }
	    if ($os eq "solaris") {
		$macro_expansion = $macro_expansion . 
		    "[ `/usr/xpg4/bin/id -u` = 0 ] && /bin/chown -Rhf root .\n";
		$macro_expansion = $macro_expansion .
		    "[ `/usr/xpg4/bin/id -u` = 0 ] && /bin/chgrp -Rhf other .\n";
	    } else {
		$macro_expansion = $macro_expansion . 
		    "[ `/usr/bin/id -u` = 0 ] && /bin/chown -Rhf root .\n";
		$macro_expansion = $macro_expansion .
		    "[ `/usr/bin/id -u` = 0 ] && /bin/chgrp -Rhf root .\n";
	    }
	    $macro_expansion = $macro_expansion .
		"/bin/chmod -Rf a+rX,g-w,o-w .\n";
	} elsif ($macro =~ /^patch([0-9]*)/) {
	    my $num = $macro_opts{'P'};
	    if (not defined($num) or $num eq "") {
		if (not defined ($1)) {
		    $num = 0;
		} else {
		    $num = $1;
		}
	    }
	    if ($num eq "") {
		$num = 0;
	    }
	    my $package_ref = $self->{_packages}[0];
	    my @values = $package_ref->get_array ('patch');

	    my $val = $values[$num];
	    if (not defined ($val)) {
		$self->{error} = "ERROR: no such patch: Patch$num";
		return 0;
	    }
	    $val =~ s/^.*\/([^\/]*)/$1/;

	    my $patch_opts = '';
	    if (defined ($macro_opts{'p'})) {
		$patch_opts = $patch_opts . " -p $macro_opts{'p'}";
	    } else {
		$patch_opts = $patch_opts . " -p 0";
	    }
	    if (defined ($macro_opts{'E'})) {
		$patch_opts = $patch_opts . " -E";
	    }
	    if (defined ($macro_opts{'b'})) {
		$patch_opts = $patch_opts . " -b -z $macro_opts{'b'}";
	    }
	    $macro_expansion = "echo 'Patch #$num ($val):'\n" .
		"patch $patch_opts < %{_sourcedir}/$val"
	}
    }

    $self->_append_to_block($block_name, $self->eval ($macro_expansion));
}

sub _process_block ($$$;$$) {
    my $self = shift;
    my $fhandle = shift;
    my $line = shift;
    my $block_name = shift;
    my $package_name = shift;

    my $package_ref = $self->{_packages}[0];
    if (not defined ($block_name) or not defined($package_name)) {

	$line =~ /^\s*%([a-z]*)/;
	$block_name = $1;

	if ($line =~ /^\s*%$block_name\s+-n\s+(\S+)\s*$/) {
	    $package_name = $1;
	} elsif ($line =~ /^\s*%$block_name\s+(\S+)\s*$/) {
	    $package_name = $package_ref->get_name() . "-" . $1;
	} else {
	    $package_name = $package_ref->get_name();
	}
    }

    $package_ref = undef;
    my $all_packages = $self->{_packages};
    foreach $package (@$all_packages) {
	if ($package->get_name() eq $package_name) {
	    $package_ref = $package;
	}
    }

    if (not defined ($package_ref)) {
	$self->{error} = "Package $package_name not defined in $line";
	return 0;
    }

    if (not defined $self->{_blocks}->{$block_name}) {
	if ($block_name =~ /(build|install|clean)/) {
	    my $dirname = $self->eval ("%{_build_src_dir_name}");
	    if ($dirname eq "%{_build_src_dir_name}") {
		$dirname = $self->eval ("%name-%version");
	    }
	    $self->{_blocks}->{$block_name} = "cd $dirname\n";
	} else {
	    $self->{_blocks}->{$block_name} = "";
	}
    }

    my $lcline;

    while (1) {
	$line = $self->_get_next_line ($fhandle);
	if (not defined($line)) {
	    last;
	}

	($line, $lcline) = $self->_preprocess_line ($line);

	if ($lcline =~ /^\s*%define/) {
	    if (not $self->_process_define ($fhandle, $line)) {
		return (0);
	    }
	} elsif ($lcline =~ /^\s*%include/) {
	    if (not $self->_process_include ($fhandle, $line, 
					     \&_process_block, 
					     ($block_name, $package_name))) {
		return (0);
	    }
	} elsif ($lcline =~ /^\s*%(setup[0-9]*)/) {
	    $self->_process_macro (undef, undef, $1, $block_name, $line);
	} elsif ($lcline =~ /^\s*%(patch[0-9]*)/) {
	    $self->_process_macro (undef, undef, $1, $block_name, $line);
	} elsif ($lcline =~ /^\s*%([a-zA-Z_][a-zA-Z0-9_]*)\.(prep|build|install|clean|changelog|pre|post|preun|postun|verifyscript|triggerin|triggerun|triggerpostun)/) {
	    if (defined ($self->{_specs_used}->{$1})) {
		$self->_process_macro ($1, undef, $2, $block_name, $line);
	    } else {
		print "WARNING: undefined macro in $line\n";
	    }
	} elsif ($lcline =~ /^\s*%([a-zA-Z_][a-zA-Z0-9_]*)\.([a-zA-Z_][a-zA-Z0-9_-]*)\.(prep|build|install|clean|changelog|pre|post|preun|postun|verifyscript|triggerin|triggerun|triggerpostun)/) {
	    if (defined ($self->{_specs_used}->{$1})) {
		$self->_process_macro ($1, $2, $3, $block_name, $line);
	    } else {
		print "WARNING: undefined macro in $line\n";
	    }
	} elsif (not $line =~ /^%/) {
	    if ($block_name =~ /(prep|build|install|clean|changelog)/) {
		$self->_append_to_block ($block_name, $self->eval ($line));
	    } else {
		$package_ref->append_to_block ($block_name, $self->eval ($line));
	    }
	} else {
	    return $self->_process_top_level ($fhandle, $line);
	}
    }

    if (defined $self->{error}) {
	return 0;
    }

    return 1;
}

sub _process_files ($$$;$) {
    my $self = shift;
    my $fhandle = shift;
    my $line = shift;
    my $package_name = shift;

# TODO: %files -f not implemented!

    my $package_ref = $self->{_packages}[0];
    if (not defined($package_name)) {
	if ($line =~ /^\s*%files\s+-n\s+(\S+)\s*$/) {
	    $package_name = $1;
	} elsif ($line =~ /^\s*%files\s+(\S+)\s*$/) {
	    $package_name = $package_ref->get_name() . "-" . $1;
	} else {
	    $package_name = $package_ref->get_name();
	}
    }

    $package_ref = undef;
    my $all_packages = $self->{_packages};
    foreach $package (@$all_packages) {
	if ($package->get_name() eq $package_name) {
	    $package_ref = $package;
	}
    }

    if (not defined ($package_ref)) {
	$self->{error} = "Package $package_name not defined in $line";
	return 0;
    }

    my @defattr = ('-', '-', '-');
    my @all_verify = rpm_file->get_all_verify();

    my @this_attr = (@defattr);
    my $is_doc = 0;
    my $is_config = 0;
    my @this_verify = (@all_verify);
    my $is_dir = 0;

    $line = $self->_get_next_line ($fhandle);
    if (not defined($line)) {
	if (defined $self->{error}) {
	    return 0;
	}

	return 1;
    }
    ($line, $lcline) = $self->_preprocess_line ($line);

    while (1) {
	if ($line =~ /^\s*$/) {
	    # ignore empty lines
	} elsif ($lcline =~ /^\s*#/) {
	    # comment, skip to next line
	} elsif ($lcline =~ /^\s*%define/) {
	    if (not $self->_process_define ($fhandle, $line)) {
		return (0);
	    }
	} elsif ($lcline =~ /^\s*%include/) {
	    if (not $self->_process_include ($fhandle, $line, \&_process_files,
					     ($package_name))) {
		return (0);
	    }
	} elsif ($line =~ /^\s*%defattr\s*\(\s*(-|[0-9]+)\s*,\s*(-|[a-zA-Z][a-zA-Z0-9_-]*)\s*,\s*(-|[a-zA-Z][a-zA-Z0-9_-]*)\s*\)\s*$/) {
	    @defattr = ($1, $2, $3);
	} elsif ($lcline =~ /^\s*%doc/) {
	    $is_doc = 1;
	    $lcline =~ s/^\s*%doc\s*//;
	    $line =~ s/^\s*%doc\s*//;
# FIXME: should process %doc stuff properly...
#	    next;
	} elsif ($lcline =~ /^\s*%config/) {
	    $is_config = 1;
	    $lcline =~ s/^\s*%config\s*//;
	    $line =~ s/^\s*%config\s*//;
	    next;	    
	} elsif ($lcline =~ /^\s*%attr\s*\(\s*(-|[0-9]+)\s*,\s*(-|[a-zA-Z][a-zA-Z0-9_-]*)\s*,\s*(-|[a-zA-Z][a-zA-Z0-9_-]*)\s*\)\s*/) {
	    @this_attr = ($1, $2, $3);
	    $lcline =~ s/^\s*%attr\s*\([^\)]*\)\s*//;
	    $line =~ s/^\s*%attr\s*\([^\)]*\)\s*//;
	    next;
	} elsif ($lcline =~ /^\s*%verify\s*\(([^\)]*)\)/) {
	    @this_verify = split /\s+/, $1;
	    $lcline =~ s/^\s*%verify\s*\([^\)]*\)//;
	    $line =~ s/^\s*%verify\s*\([^\)]*\)//;
	    next;
	} elsif ($lcline =~ /^\s*%docdir/) {
	    $is_doc = 1;
	    $is_dir = 1;
	    $lcline =~ s/^\s*%docdir\s*//;
	    $line =~ s/^\s*%docdir\s*//;
	    next;
	} elsif ($lcline =~ /^\s*%dir/) {
	    $is_dir = 1;
	    $lcline =~ s/^\s*%dir\s*//;
	    $line =~ s/^\s*%dir\s*//;
	    next;
	} elsif ($line =~ /^\s*(\/.*\S)\s*$/) {
	    my $file = rpm_file->new ($1, \@this_attr, \@this_verify,
				     not ($is_dir), $is_doc,
				     $is_config);
	    $package_ref->add_file ($file);
	} else {
	    return $self->_process_top_level ($fhandle, $line);
	}

	@this_attr = (@defattr);
	$is_doc = 0;
	$is_config = 0;
	@this_verify = (@all_verify);
	$is_dir = 0;

	$line = $self->_get_next_line ($fhandle);
	if (not defined($line)) {
	    last;
	}
	($line, $lcline) = $self->_preprocess_line ($line);
    }

    if (defined $self->{error}) {
	return 0;
    }

    return 1;
}

sub _process_top_level ($$$) {
    my $self = shift;
    my $fhandle = shift;
    my $line = shift;

    my $lcline = lc($line);
    chomp ($line);
    $lcline =~ s/^\s*//;

    if ($lcline =~ /^#/) {
	# comment, nothing to do.
	return 1;
    } elsif ($lcline =~ /^\s*$/) {
	return 1;
    } elsif ($lcline =~ /^\s*%use/) {
	return $self->_process_use ($fhandle, $line);
    } elsif ($lcline =~ /^\s*%include/) {
	return $self->_process_include ($fhandle, $line, \&_process_top_level, ());
    } elsif ($lcline =~ /^%package/) {
	return $self->_process_package ($fhandle, $line);
    } elsif ($lcline =~ /^%(description|prep|build|install|clean|changelog|pre|post|preun|postun|verifyscript|triggerin|triggerun|triggerpostun)/) {
	return $self->_process_block ($fhandle, $line);
    } elsif ($lcline =~ /^%files/) {
	return $self->_process_files ($fhandle, $line);
    } elsif ($lcline =~ /^\s*%define/) {
	return $self->_process_define ($fhandle, $line);
    } elsif ($lcline =~ /^\s*\S+\s*:\s*\S+/) {
	return $self->_process_tag ($fhandle, $line);
    }

    $self -> {error} = "Unable to process line " . $line;
    return 0;
}

sub _read_spec ($) {
    my $self = shift;

    my $fhandle = "SPEC_FILE" . $file_id++;
    my $fname = $self->{_file_name};

    open $fhandle, "<$fname" or 
	$self->{error} = "Could not open file $fname for reading",
	return (0);

    my $line;

    $self->{_being_loaded} = 1;
    $self->{_current_package} = $self->{_packages}[0];

    while (1) {
	$line = $self->_get_next_line ($fhandle);
	if (not defined ($line)) {
	    last;
	}
	if (not $self->_process_top_level ($fhandle, $line)) {
	    $self->{_being_loaded} = 0;
	    $self->{_loaded} = 1;
	    return (0);
	}
    }

    close $fhandle;

    $self->{_current_package} = $self->{_packages}[0];
    $self->{_being_loaded} = 0;
    $self->{_loaded} = 1;

    if (defined $self->{error}) {
	return 0;
    }

    if ($self->{_in_conditional} > 0) {
	$self->{error} = "Unclosed %if";
	return 0;
    }

    return (1);
}

sub get_name ($) {
    my $self = shift;

    if (! $self->{_loaded} and ! $self->{_being_loaded}) {
	if (not $self->_read_spec ()) {
	    print "ERROR: " . $self->{error} . "\n";
	    return undef;
	}
    }

    my $package = $self->{_packages}[0];
    my $name = $package->get_tag ("name");
    if (not defined ($name)) {
	return $self->{_base_file_name};
    }
    return $name;
}

sub get_packages ($) {
    my $self = shift;

    if (! ($self->{_loaded} or $self->{_being_loaded})) {
	if (not $self->_read_spec ()) {
	    print "ERROR: " . $self->{error} . "\n";
	    return undef;
	}
    }

    my $ref = $self->{_packages};
    return @$ref;
}

sub block_is_defined ($$) {
    my $self = shift;
    my $block_name = shift;

    if (! $self->{_loaded} and ! $self->{_being_loaded}) {
	if (not $self->_read_spec ()) {
	    print "ERROR: " . $self->{error} . "\n";
	    return undef;
	}
    }

    return defined ($self->{_blocks}->{$block_name});
}

sub _append_to_block ($$$) {
    my $self = shift;
    my $block_name = shift;
    my $text_to_append = shift;

    if (defined ($self->{_blocks}->{$block_name})) {
	$self->{_blocks}->{$block_name} = 
	    $self->{_blocks}->{$block_name} . "\n" . $text_to_append;
    } else {
	$self->{_blocks}->{$block_name} = $text_to_append;
    }
}

sub get_block ($$) {
    my $self = shift;
    my $block_name = shift;

    if (! $self->{_loaded} and ! $self->{_being_loaded}) {
	if (not $self->_read_spec ()) {
	    print "ERROR: " . $self->{error} . "\n";
	    return undef;
	}
    }

    return $self->{_blocks}->{$block_name};
}

sub get_file_name ($) {
    my $self = shift;

    return $self->{_file_name};
}

sub get_base_file_name ($) {
    my $self = shift;
    
    return $self->{_base_file_name};
}

sub get_rpms ($) {
    my $self = shift;

    my @packages = $self->get_packages ();
    my @rpms = ();
    foreach my $pkg (@packages) {
	my $pkg_arch = $pkg->get_tag ("buildarch");
	if (not defined ($pkg_arch)) {
	    $pkg_arch = $pkg->get_tag ("buildarchitectures");
	}
	push (@rpms, $pkg->get_name() . "-" . $pkg->get_tag ("version") . 
	      "-" . $pkg->get_tag ("release") . "." .
	      $pkg_arch . ".rpm");
    }

    return @rpms;
}

sub get_rpm_paths ($) {
    my $self = shift;

    my @packages = $self->get_packages ();
    my @rpms = ();
    foreach my $pkg (@packages) {
	my $pkg_arch = $pkg->get_tag ("buildarch");
	if (not defined ($pkg_arch)) {
	    $pkg_arch = $pkg->get_tag ("buildarchitectures");
	}
	push (@rpms, $self->get_value_of ("_rpmdir") . "/" . 
	      $pkg_arch . "/" .
	      $pkg->get_name() . "-" . $pkg->get_tag ("version") . 
	      "-" . $pkg->get_tag ("release") . "." .
	      $pkg_arch . ".rpm");
    }

    return @rpms;
}

sub get_pkgs ($) {
    my $self = shift;

    my @packages = $self->get_packages ();
    my @pkgs = ();
    foreach my $pkg (@packages) {
	push (@pkgs, $pkg->get_name());
    }

    return @pkgs;
}

sub get_package_names ($) {
    my $self = shift;
    return $self->get_pkgs ();
}

sub get_value_of ($$) {
    my $self = shift;
    my $name = shift;
    my $lcname = lc ($name);

    if (! $self->{_loaded} and ! $self->{_being_loaded}) {
	if (not $self->_read_spec ()) {
	    print "ERROR: " . $self->{error} . "\n";
	    return undef;
	}
    }

    my $package_ref = $self->{_packages}[0];
    if (defined ($package_ref) and $package_ref->tag_is_defined ($lcname)) {
	return $package_ref->get_tag ($lcname);
    } elsif ($name =~ /^(SOURCE|PATCH)([0-9]*)$/) {
	my $num = $2;
	my $source_or_patch = lc($1);
	if (not defined ($num)) {
	    $num = 0;
	}
	my @values = $package_ref->get_array ($source_or_patch);
	my $val = $values[$num];
	return undef unless defined $val;
	$val =~ s/^.*\/([^\/]*)/$1/;
	return "%{_sourcedir}/$val";
    } else {
	return $self->eval ($self->{_defines}->{$name});
    }
}

sub get_def ($$) {
    my $self = shift;
    my $name = shift;
    my $lcname = lc ($name);

    if (! $self->{_loaded} and ! $self->{_being_loaded}) {
	if (not $self->_read_spec ()) {
	    print "ERROR: " . $self->{error} . "\n";
	    return undef;
	}
    }

    return $self->{_defines}->{$name};
}

sub get_sources ($) {
    my $self = shift;

    if (! $self->{_loaded} and ! $self->{_being_loaded}) {
	if (not $self->_read_spec ()) {
	    print "ERROR: " . $self->{error} . "\n";
	    return undef;
	}
    }

    my $package_ref = $self->{_packages}[0];
    my @values = $package_ref->get_array ('source');
    my $specs_used = $self->{_specs_used};
    my @spec_names_used = keys %$specs_used;
    foreach my $spec_name_used (@spec_names_used) {
	my $spec_used = $self->{_specs_used}->{$spec_name_used};
	my @sources_used = $$spec_used->get_sources ();
	push (@values, @sources_used);
    }
    return @values;
}

sub get_patches ($) {
    my $self = shift;

    if (! $self->{_loaded} and ! $self->{_being_loaded}) {
	if (not $self->_read_spec ()) {
	    print "ERROR: " . $self->{error} . "\n";
	    return undef;
	}
    }

    my $package_ref = $self->{_packages}[0];
    my @values = $package_ref->get_array ('patch');
    my $specs_used = $self->{_specs_used};
    my @spec_names_used = keys %$specs_used;
    foreach my $spec_name_used (@spec_names_used) {
	my $spec_used = $self->{_specs_used}->{$spec_name_used};
	my @patches_used = $$spec_used->get_patches ();
	push (@values, @patches_used);
    }
    return @values;
}

sub get_default_topdir () {
    return $_default_topdir;
}

init();
1;
