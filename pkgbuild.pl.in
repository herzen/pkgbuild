#!@PERL@
#
@WARNING_MESSAGE_L1@
@WARNING_MESSAGE_L2@
@WARNING_MESSAGE_L3@
@WARNING_MESSAGE_L4@
@WARNING_MESSAGE_L5@
@WARNING_MESSAGE_L6@
@WARNING_MESSAGE_L7@
#
#  The pkgbuild build engine
#
#  Copyright 2009 Sun Microsystems, Inc.
#
#  pkgbuild is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License 
#  version 2 published by the Free Software Foundation.
#
#  pkgbuild is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#  General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
#  As a special exception to the GNU General Public License, if you
#  distribute this file as part of a program that contains a
#  configuration script generated by Autoconf, you may include it under
#  the same distribution terms that you use for the rest of that program.
#
#  Authors:  Laszlo Peter  <laca@sun.com>
#            Petr Sobotka  <sobotkap@gmail.com>
#

#use strict;
use warnings;
use Getopt::Long qw(:config gnu_compat no_auto_abbrev bundling pass_through);
use rpm_spec;
use pkgdb;
use ips_utils;
use File::Basename;

my $myname = "pkgbuild";
my $myversion = "@PKGBUILD_VERSION@";
my $version_printed = 0;
my $debug_level = 0;
my $verbose = 1;
my $build_command;
my $build_skip = 0;
my $interactive_mode = 0;
my $check_deps = 1;
my $pkgdb;
my $ips_utils = new ips_utils;

my $ips_server = $ENV{PKGBUILD_IPS_SERVER};
if (not defined($ips_server)) {
    if (defined ($ips_utils)) {
	$ips_server = $ips_utils->get_local_ips_server();
    }
}

my $mydir = `pwd`;
chomp ($mydir);
my @spec_names = ();

my $arch;
my $os;
my $os_rel;

sub debug_print ($) {
    my $msg = shift;
    if ($debug_level > 0) {
	print "DEBUG:" . $msg . "\n";
    }
}

sub init () {
    $arch = `uname -p`;
    chomp ($arch);
    if ($arch eq "unknown") {
	$arch = `uname -m`;
	chomp ($arch);
	if ($arch eq 'i586') {
	    $arch = 'i386';
	} elsif ($arch eq 'i686') {
	    $arch = 'i386';
	}
    }

    $os = `uname -s`;
    chomp ($os);
    $os = lc($os);
    $os_rel = `uname -r`;
    chomp ($os_rel);
    if ($os eq 'sunos') {
	if ($os_rel =~ /^5\./) {
	    $os = 'solaris';
	}
    }
}

my @predefines = ();

sub add_define ($$) {
    shift;
    my $def = shift;

    push (@predefines, $def);
}

my %build_phases = ('p', 'p', 
		    'c', 'pc',
		    'i', 'pci',
		    'b', 'pcib',
		    'a', 'pciba',
		    's', 's');

sub short_circuit_option {
    if (defined ($build_command)) {
	$build_command = substr($build_command, length($build_command)-1);
    } else {
	%build_phases = ('p', 'p',
			 'c', 'c',
			 'i', 'i',
			 'b', 'b',
			 's', 's',
			 'a', 'a');
    }
}

sub set_build_command ($$) {
    shift;
    my $key = shift;

    if (defined $build_command) {
	fatal ("only one major mode may be specified");
    }
    if ($key =~ /^[abicps]$/) {
	$build_command = $build_phases{$key};
    } elsif ($key eq 'l') {
	fatal ("-bl not implemented");
    } else {
	fatal ("--build (-b) requires one of a,b,i,c,p,l,s as its sole argument");
    }
}

sub set_rebuild ($) {
    shift;
    my $pkg = shift;

    if (defined $build_command) {
	fatal ("only one major mode may be specified");
    }
    if (not $pkg =~ /^\//) {
	$pkg = "$mydir/$pkg";
    }

    if ( -f $pkg ) {
	# check if it's a datastream pkg
	my $ftype = `/usr/bin/file $pkg | cut -f2 -d:`;
	chomp ($ftype);
	if (not $ftype =~ /package datastream/) {
	    fatal ("file $pkg is not a package datastream");
	}
	my $tmpdir=`mktemp -d`;
	chomp ($tmpdir);
	system ("/usr/bin/pkgtrans -o $pkg $tmpdir all");
	$pkg = `/bin/ls -d $tmpdir/* | head -1`;
	chomp ($pkg);
	print "pkg is $pkg\n";
    }
    $build_command = $build_phases{'b'};
    my $main_spec = `grep '^1 s none .*/\.\.main\.spec=' $pkg/pkgmap 2>&1`;
    if ($? == 0) {
	chomp ($main_spec);
	$main_spec =~ s/^1 s none (.*\/)\.\.main\.spec=(.*)/$1$2/;
	$main_spec = "$pkg/reloc/$main_spec";
	my $src_topdir = $main_spec;
	$src_topdir =~ s/\/SPECS\/[^\/]*\.spec$//;
	add_define (0, "_sourcedir $src_topdir/SOURCES");
	add_define (0, "_specdir $src_topdir/SPECS");
	@spec_names = ($main_spec);
	return 1;
    }

    if (-l "$pkg/SPECS/..main.spec") {
	add_define (0, "_sourcedir $pkg/SOURCES");
	add_define (0, "_specdir $pkg/SPECS");
	$main_spec = readlink ("$pkg/SPECS/..main.spec");
	$main_spec = "$pkg/SPECS/$main_spec";
	@spec_names = ($main_spec);
	return 1;
    }

    fatal ("$pkg is not a source package");
}

sub process_with ($$) {
    my $with = shift;
    my $opt = shift;

    if ($with ne "with" and $with ne "without") {
	fatal ("Internal error in sub process_with()");
    }
    my $optname = $opt;
    $optname =~ tr /\-/_/;
    push (@predefines, "_${with}_${optname} --${with}-${opt}");
}

my $pkgformat = "filesystem";
sub set_pkgformat ($) {
    shift;
    my $format = shift;

    if ($format eq "fs" or $format eq "filesystem") {
	$pkgformat = "filesystem";
    } elsif ($format eq "ds" or $format eq "datastream") {
	$pkgformat = "datastream";
    } elsif ($format eq "ips") {
	$pkgformat = "ips";
    } else {
	fatal ("Invalid argument to pkgformat option: $format");
    }
}

sub process_options {
    if (not GetOptions ('debug=n'   => \$debug_level,
		'help'      => \&usage,
		'version'   => \&print_version,
		'b=s'       => \&set_build_command,
		'v+'        => \$verbose,
		'define=s'  => \&add_define,
		'deps!'     => \$check_deps,
		'interactive!' => \$interactive_mode,
		'bp'        => sub { set_build_command (0, 'p'); },
		'bl'        => sub { fatal ("-bl not implemented\n") },
		'bc'        => sub { set_build_command (0, 'c'); },
		'bi'        => sub { set_build_command (0, 'i'); },
		'bb'        => sub { set_build_command (0, 'b'); },
		'ba'        => sub { set_build_command (0, 'a'); },
		'bs'        => sub { set_build_command (0, 's'); },
		'rebuild=s' => \&set_rebuild,
		'with=s'    => \&process_with,
		'without=s' => \&process_with,
		'pkgformat=s' => \&set_pkgformat,
		'short-circuit' => \&short_circuit_option, 
		'build=s'   => \$build_command,
		'rcfile=s'  => sub { print "--rcfile option not implemented\n" },
			'<>' => \&process_args)) {
	exit 1;
    }
}

sub process_args () {
    my $arg = shift;

    if ($arg =~ /^--with-(.*)/) {
	process_with ("with", $1);
	return;
    } elsif ($arg =~ /^--without-(.*)/) {
	process_with ("without", $1);
	return;
    } elsif ($arg =~ /^-/) {
	fatal ("Unknown option: $arg\n");
    }
    
    push (@spec_names, $arg);
}

sub print_version () {
    $version_printed = 1;
    print "$myname version $myversion\n";
}

sub usage () {
    print_version();
    print <<_EOF_;
Copyright 2003-2008 Sun Microsystems, Inc.
This program may be freely redistributed under the terms of the GNU GPLv2

* = the option is implemented 

 Usage:
*  --help                  - print this message
*  --version               - print the version of rpm being used
*  --interactive           - start a shell in the build directory if fails
                             and allow to continue after the shell terminates
   all modes support the following arguments:
      --rcfile <file>      - use <file> instead of /etc/rpmrc and \$HOME/.rpmrc
*    -v                    - be a little more verbose
*    -vv                   - be incredibly verbose (for debugging)
*   -b<stage> <spec>
    -t<stage> <tarball>    - build package, where <stage> is one of:
*         p                - prep (unpack sources and apply patches)
          l                - list check (do some cursory checks on %files)
*         c                - compile (prep and compile)
*         i                - install (prep, compile, install)
*         b                - binary package (prep, compile, install, package)
*         s                - source package (install, package)
*         a                - bin/src package (prep, compile, install, package)
*     --short-circuit      - skip straight to specified stage (for c,i,b)
      --clean              - remove build tree when done
      --rmsource           - remove sources and spec file when done
      --sign               - generate PGP/GPG signature
      --buildroot <dir>    - use <dir> as the build root
      --target=<platform>+ - build the packages for the build targets
                             platform1...platformN.
      --nobuild            - do not execute any stages
      --timecheck <secs>   - set the time check to <secs> seconds (0 disables)
*     --define "<name> <value>"
                           - define <name> as <value> as if you had
			     "%define <name> <value>" in the spec file 
*     --with-foo or --with foo
                           - same as "%define _with_foo --with-foo"
*     --without-foo or --without foo
                           - same as "%define _without_foo --without-foo" 

*   --rebuild <src_pkg>    - install source package, build binary package and
                             remove spec file, sources, patches, and icons.
    --rmsource <spec>      - remove sources and spec file
    --recompile <src_pkg>  - like --rebuild, but don't build any package
*   --pkgformat={filesystem|fs|datastream|ds|ips}
                           - Create packages in filesystem or datastream
                             format.  Default: filesystem
_EOF_
# '
    exit(1);
}

sub message (@) {
    my @messages = @_;

    foreach my $msg (@messages) {
	print "$myname: $msg\n";
    }
}

my @tempfiles = ();
sub register_tempfile ($) {
    push  (@tempfiles, shift);
}

sub remove_tempfiles () {
    foreach my $tmpf (@tempfiles) {
	if ( -d $tmpf ) {
	    `rm -rf $tmpf`;
	} elsif ( -f $tmpf ) {
	    `rm -f $tmpf`;
	}
    }
}

sub fatal (@) {
    message (@_);
    remove_tempfiles ();
    exit 1;
}

sub get_versions_installed ($) {
    my $pkg = shift;

    my @retlist = ();
    if ($os eq "linux") {
	my $pkglist=`rpm -q --queryformat '%{VERSION}\t%{RELEASE}\t%{SERIAL}\n' $pkg 2>/dev/null`;
	if ($? != 0) {
	    return \@retlist;
	}
	my @pkginfos=split /\n/, $pkglist;
	foreach my $pkginfo (@pkginfos) {
	    next if not defined ($pkginfo);
	    if ($pkginfo =~ /^([^\t]*)\t([^\t]*)\t([^\t]*)$/) {
		push (@retlist, ($1, $2, $3));
	    } else {
		message ("WARNING: couldn't parse version number of $pkg");
	    }
	}
	return \@retlist;
    } elsif ($os eq "solaris") {
	my $pkglist=`/usr/bin/pkginfo -l '$pkg.*' 2>&1 | grep VERSION: | cut -f2- -d:`;
	if ($? != 0) {
	    return \@retlist;
	}
	my @pkginfos=split /\n/, $pkglist;
	foreach my $pkginfo (@pkginfos) {
	    next if not defined ($pkginfo);
	    if ($pkginfo =~ /^\s*(.*),REV=(.*)\s*$/) {
		push (@retlist, ($1, $2, undef));
	    } else {
		$pkginfo =~ s/\s*//;
		push (@retlist, ($pkginfo, undef, undef));
	    }
	}
	return \@retlist;
    } else {
	return \@retlist;
    }   
}

sub compare_version ($$$$$$$) {
    my $vers1 = shift;
    my $rev1 = shift;
    my $serial1 = shift;
    my $op = shift;
    my $vers2 = shift;
    my $rev2 = shift;
    my $serial2 = shift;

    return 1;

# FIXME: this is unfinished!
    if ($op =~ /S$/) {
	if (not defined ($serial1) or not defined ($serial2)) {
	    return 0;
	}
	my $comp_res = compare_version_string ($serial1, $serial2);
	if ($op eq "=S") {
	    if ($serial1 = $serial2) {
		return 1;
	    }
	} elsif ($op eq "<=S" or $op eq "=<S") {
	} elsif ($op eq ">=S" or $op eq "=>S") {
	}
    } else {
	if (not defined ($version1) or not defined ($version2)) {
	    return 0;
	}
	my $version_comp_res = compare_version_string ($serial1, $serial2);
	my $rev_comp_res;
	if ($version_comp_res == 0) {
	    if (not defined ($version1) or not defined ($version2)) {
		return 0;
	    }
	    my $version_comp_res = compare_version_string ($serial1, $serial2);
	}
	if ($op eq "=") {
	} elsif ($op eq "<=" or $op eq "=<") {
	} elsif ($op eq ">=" or $op eq "=>") {
	}
    }
}

sub check_dep ($$) {
    my $spec = shift;
    my $dep = shift;

    if (not defined ($dep)) {
	return 1;
    }

    if ($dep =~ /^\s*\//) {
	# Requires: /path/to/file  kind of dependency
	if (-e $dep) {
	    return 1;
	}
	return 0;
    }

    my $pkg = $dep;
    # FIXME: we're simple chopping off any version comparisons
    # should really verify them instead
    $dep =~ s/(\S+).*/$1/;
    if (not defined ($pkg)) {
	print "empty dependency: $dep\n";
	return 0;
    }
    my $ref_vers;
    my $ref_rev;
    my $ref_serial;
    my $rel_op;
    my $re_quoted_pkg = $pkg;
    # quote chars with special meaning in regexps
    $re_quoted_pkg =~ s/([\+\*\(\)\[\].\\])/\\$1/g;
    if ($dep =~ /^$re_quoted_pkg\s*(=|<=|=<|>=|=>)\s*(\S*),REV=(\S*)\s*$/) {
	if ($os eq "solaris") {
	    $rel_op = $1;
	    $ref_vers = $2;
	    $ref_rev = $3;
	} else {
	    $rel_op = $1;
	    $ref_vers = "$2,REV=$3";
	    if ($ref_vers =~ /^([^-]*)-([^-]*)$/) {
		$ref_vers = $1;
		$ref_rev = $2;
	    }
	}
    } elsif ($dep =~ /^$re_quoted_pkg\s*(=|<=|=<|>=|=>)\s*(\S*)\s*$/) {
	$rel_op = $1;
	$ref_vers = $2;
	if ($os eq "linux") {
	    if ($ref_vers =~ /^([^-]*)-([^-]*)$/) {
		$ref_vers = $1;
		$ref_rev = $2;
	    }
	}
    } elsif ($dep =~ /^$re_quoted_pkg\s*(=S|<=S|=<S|>=S|=>S)\s*(\S*)\s*$/) {
	$rel_op = $1;
	$ref_serial = $2;
	if ($os eq "solaris") {
	    print "WARNING: \"Serial\" dependency tests not " .
		"implemented on Solaris\n";
	    print "WARNING: ignoring dependency \"$dep\"\n";
	    return 1;
	}
    } elsif ($dep =~ /^$re_quoted_pkg\s*$/) {
	# no version to compare to, check existance of pkg only
    } else {
	print "WARNING: could not parse dependency: $dep\n";
	return 0;
    }

    my $subpkg = $spec->find_package_by_name ($pkg);
    if (not defined $subpkg) {
	if ($os eq "linux") {
	    `rpm -q $pkg`;
	    if ($? != 0) {
		`rpm -q --provides $pkg`;
		if ($? != 0) {
		    return 0;
		}
	    }
	} elsif ($os eq "solaris") {
	    `/usr/bin/pkginfo -q '$pkg.*'`;
	    if ($? != 0) {
		return 0;
	    }
	} else {
	    print "WARNING: I don't know how to verify dependency $pkg ".
		"on this OS.\n";
	    return 1;
	}
    }

    if (defined ($ref_vers)) {
	if (defined $subpkg) {
	    my $subpkg_version = $subpkg->get_tag ("version");
	    my $subpkg_release = $subpkg->get_tag ("release");
	    my $subpkg_serial = $subpkg->get_tag ("serial");
	    my $subpkg_rev = $subpkg->get_tag ("rev");

	    if (compare_version ($ref_vers, $ref_rev, $ref_serial,
				 $rel_op, 
				 $subpkg_version, $subpkg_rev, 
				 $subpkg_serial)) {
		return 1;
	    }
	}

	my $version_list_ref = get_versions_installed ($pkg);
	if (not @$version_list_ref) {
	    return 0;
	}

	if ($rel_op =~ /S$/) {
#FIXME	    
	}
	foreach $vers_ref (@$version_list_ref) {
	    my ($version, $rev, $serial) = @$vers_ref;
	    if (compare_version ($ref_vers, $ref_rev, $ref_serial,
				 $rel_op, 
				 $version, $rev, $serial)) {
		return 1;
	    }
	}
	return 0;
    }

    return 1;
}

sub check_build_requires ($) {
    my $spec = shift;

    my @packages = $spec->get_packages ();

    foreach my $pkg (@packages) {
	my @reqss = $pkg->get_array ("buildrequires");
	foreach my $req (@reqss) {
	    next if not defined $req;
	    check_dep ($spec, $req) or
		message ("error: $req is required to build " .
			 $spec), return 0;
	}
	@reqss = $pkg->get_array ("buildconflicts");
	foreach my $req (@reqss) {
	    next if not defined $req;
	    check_dep ($spec, $req) and
		message ("error: $req conflicts with " .
			 $spec), return 0;
	}
	@reqss = $pkg->get_array ("buildprereq");
	foreach my $req (@reqss) {
	    next if not defined $req;
	    check_dep ($spec, $req) or
		message ("error: $req is required to build " .
			 $spec), return 0;
	}
    }

    return 1;
}

sub get_script_header ($) {
    my $spec = shift;

    my $error_handler = "";
    if ($interactive_mode) {
	$error_handler = "pkgbuild_start_shell () {\n" .
	    "  set +x\n" .
	    "  export PS1='pkgbuild@\\H> '\n" .
	    "  echo '*** Command failed; entering interactive mode'\n" .
	    "  echo '*** starting shell'\n" .
	    "  echo '*** when finished'\n" .
	    "  echo '***     type   exit      to continue'\n" .
	    "  echo '***     type   exit 1    to abort'\n" .
	    "\n" .
	    "  /bin/bash --noprofile --norc +o monitor -i || exit 1\n" .
	    "\n" .
	    "  set -x\n" .
	    "}\n" .
	    "\n" .
	    "trap pkgbuild_start_shell ERR\n" .
	    "\n";
    } else {
	$error_handler = "set -e\n\n";
    }
    my $script = "#!/bin/bash\n\n" .
	$error_handler .
	$spec->eval ("RPM_SOURCE_DIR=\"%{_sourcedir}\"") . "\n" .
	$spec->eval ("RPM_BUILD_DIR=\"%{_builddir}\"") . "\n" .
	$spec->eval ("RPM_OPT_FLAGS=\"%{optflags}\"") . "\n" .
	"RPM_ARCH=\"$arch\"\n" .
	"RPM_OS=\"$os\"\n" .
	"RPM_OS_REL=\"$os_rel\"\n" .
	"export RPM_SOURCE_DIR RPM_BUILD_DIR RPM_OPT_FLAGS RPM_ARCH RPM_OS\n" .
	"RPM_DOC_DIR=\"/usr/share/doc/packages/" . $spec . "\"\n" .
        "export RPM_DOC_DIR\n" .
	"RPM_PACKAGE_NAME=\"" . $spec . "\"\n" .
	"RPM_PACKAGE_VERSION=\"" . $spec->eval ('%version') . "\"\n" .
	"RPM_PACKAGE_RELEASE=\"" . $spec->eval ('%release') . "\"\n" .
	"export RPM_PACKAGE_NAME RPM_PACKAGE_VERSION RPM_PACKAGE_RELEASE\n" .
	$spec->eval ("RPM_BUILD_ROOT=\"%buildroot\"") . "\n" .
	"export RPM_BUILD_ROOT\n\n" .
	"set -x\n" .
	"umask 022\n" .
	"uname -a\n\n";

    return $script;
}

# I couldn't find a standard perl implementation of mkdir -p so
# this is simple a recursive implementation
sub mkdir_p ($);

sub mkdir_p ($) {
    my $dir = shift;

    if (-d $dir) {
	return 1;
    }

    my $pdir = dirname ($dir);
    if (! -d $pdir) {
	mkdir_p ($pdir) or return 0;
    }

    return 1 if -d $dir;
    mkdir ($dir) or return 0;
    return 1;
}

my $file_id = 0;
sub open_tempfile ($) {
    my $spec = shift;

    my $tempdir = $spec->eval('%{_tmppath}');
    if (not defined $tempdir) {
	$tempdir = "/tmp";
    }
    my $the_file_id = ++$file_id;
    my $fhandle = "TEMP_FILE" . $the_file_id;
    my $fname = "pkgbuild-tmp-$the_file_id.$$";
    mkdir_p ($tempdir);
    open $fhandle, ">$tempdir/$fname" or
	fatal ("failed to create temporary file $tempdir/$fname");
    return ($fhandle, "$tempdir/$fname");
}

sub do_block ($$) {
    my $spec = shift;
    my $block_name = shift;

    my $script = $spec->get_block ($block_name);
    if (not defined ($script)) {
	return 1;
    }
    my $fhandle;
    my $script_name;
    ($fhandle, $script_name) = open_tempfile ($spec);
    my $script_hdr = get_script_header ($spec);

    print $fhandle "$script_hdr";
    print $fhandle $spec->eval ("cd %{_builddir}\n\n");
    print $fhandle "$script\n" if $script;
    print $fhandle "exit 0\n";

    close $fhandle;
    my $retval;

    print "Executing(%$block_name): /bin/bash $script_name\n";
    if ($block_name eq 'build' or $block_name eq 'install') {
	my $bsdirname = $spec->eval ('%{_build_src_dir_name}');
	if ($bsdirname eq '%{_build_src_dir_name}') {
	    $bsdirname = $spec->eval ('%name-%version');
	}
	my $blddir = $spec->eval ("%{_builddir}");
	`test -d $blddir/$bsdirname && cp $script_name $blddir/$bsdirname/.pkgbuild.$block_name.sh && chmod a+x $blddir/$bsdirname/.pkgbuild.$block_name.sh`;
    }
    system ("/bin/bash $script_name");
    $retval = $?;
    unlink $script_name;
    if ($retval) {
	print "Bad exit status from $script_name (%$block_name)\n";
    }

    return (not $retval);
}


my %all_files;

sub make_pkginfo ($$) {
    my $spec = shift;
    my $package = shift;

    my $fhandle = "pkginfo" . ++$file_id;

    my $pkginfodir = $spec->eval ("%_topdir") . "/PKGMAPS/pkginfo";
    my $fname = $package . ".pkginfo";
    open $fhandle, ">$pkginfodir/$fname" or
	fatal ("failed to create file $pkginfodir/$fname");

    my $pkgname = $package->get_tag ('SUNW_Pkg');
    $pkgname = "$package" unless $pkgname;
    print $fhandle "PKG=" . $pkgname . "\n";
    my $summary = $package->get_tag ('summary');
    $summary = $pkgname unless defined ($summary);
    print $fhandle "NAME=$summary\n";
    my $desc = $package->get_tag ('SUNW_Desc');
    if (defined ($desc)) {
        print $fhandle "DESC=$desc\n";
    } else {
        print $fhandle "DESC=$summary\n";
    }
    print $fhandle "ARCH=$arch\n";

    my $prodname = $package->get_tag ('SUNW_ProdName');
    print $fhandle "SUNW_PRODNAME=$prodname\n" if $prodname;

    my $prodvers = $package->get_tag ('SUNW_ProdVers');
    print $fhandle "SUNW_PRODVERS=$prodvers\n" if $prodvers;

    my $basedir = $package->get_tag ('SUNW_BaseDir');
    if (not defined ($basedir)) {
	$basedir = "/";
    }

    my $parent_dir = $basedir;
    while ($parent_dir =~ /\// and $parent_dir ne "/") {
	$all_files{substr($parent_dir, 1)}="base directory";
	$parent_dir =~ s/\/[^\/]+$//;
    }
    
    my $pkgtype = $package->get_tag ('SUNW_PkgType');
    if (defined ($pkgtype)) {
	print $fhandle "SUNW_PKGTYPE=$pkgtype\n";
    } elsif ($basedir eq "/usr") {
	print $fhandle "SUNW_PKGTYPE=usr\n";
    } elsif ($basedir eq "/") {
	print $fhandle "SUNW_PKGTYPE=root\n";
    }

    my $pkgvers = $package->get_tag ('SUNW_PkgVers');
    $pkgvers = "1.0" unless $pkgvers;
    print $fhandle "SUNW_PKGVERS=$pkgvers\n";

    my $pkglist = $package->get_tag ('SUNW_PkgList');
    if (defined ($pkglist)) {
       print $fhandle "SUNW_PKGLIST=$pkglist\n";
    }

    my $loc = $package->get_tag ('SUNW_Loc');
    if (defined ($loc)) {
       print $fhandle "SUNW_LOC=$loc\n";
    }

    my $category = $package->get_tag ('SUNW_Category');
    if (not defined ($category)) {
	$category = "application";
    }
    print $fhandle "CATEGORY=$category\n";

    my $zone_stuff = $package->get_tag ('SUNW_Pkg_AllZones');
    if (defined ($zone_stuff)) {
	print $fhandle "SUNW_PKG_ALLZONES=$zone_stuff\n";
    }

    $zone_stuff = $package->get_tag ('SUNW_Pkg_Hollow');
    if (defined ($zone_stuff)) {
	print $fhandle "SUNW_PKG_HOLLOW=$zone_stuff\n";
    }

    $zone_stuff = $package->get_tag ('SUNW_Pkg_ThisZone');
    if (defined ($zone_stuff)) {
	print $fhandle "SUNW_PKG_THISZONE=$zone_stuff\n";
    }

    my $vendor = $package->get_tag ('Vendor');
    print $fhandle "VENDOR=$vendor\n" if $vendor;

    my $hotline = $package->get_tag ('SUNW_HotLine');
    print $fhandle "HOTLINE=$hotline\n" if $hotline;

    print $fhandle "EMAIL=\n";

    my $maxinst = $package->get_tag ('SUNW_MaxInst');
    print $fhandle "MAXINST=$maxinst\n" if $maxinst;

    my $version = $package->get_tag ('Version');
    my $rev = $package->get_tag ('SUNW_Rev');
    if (not defined $rev) {
	$rev = `date +%Y.%m.%d.%H.%M.%S`;
    }
    chomp ($rev);
    print $fhandle "VERSION=$version,REV=$rev\n";
    
    print $fhandle "BASEDIR=$basedir\n";

    my @classes = $package->get_classes ();
    print $fhandle "CLASSES=none";
    foreach my $class_name (@classes) {
	next if not defined $class_name;
	next if $class_name eq "none";
	print $fhandle " $class_name"
    }
    print $fhandle "\n";

    close $fhandle;
    return "i pkginfo=$pkginfodir/$fname\n";
}

# expand macros in file $src in the contect of $spec and write the output
# to file $dst
sub eval_file ($$$) {
    my $spec = shift;
    my $src = shift;
    my $dst = shift;

    open SRC, "<$src" or
	fatal ("failed to open file $src for reading");
    open DST, ">$dst" or
	fatal ("failed to open file $dst for writing");

    while (my $line = <SRC>) {
	if ($line =~ /%({[.a-zA-Z0-9_]+}|[.a-zA-Z0-9_]+)/) {
	    print DST $spec->eval ($line);
	} else {
	    print DST $line;
	}
    }

    close SRC;
    close DST;
}

sub make_copyright ($$;$) {
    my $spec = shift;
    my $package = shift;
    my $pkgname = shift;

    my $cr_file;
    if (defined $package) {
	$cr_file = $package->get_tag ('sunw_copyright');
    } else {
	$cr_file = $spec->get_value_of ('sunw_copyright');
    }
    return undef unless defined $cr_file;

    # in case it's a URL
    $cr_file = basename($cr_file);

    my $srcdir = $spec->eval ('%_sourcedir');
    if (not -f "$srcdir/$cr_file") {
	message ("warning: copyright file $srcdir/$cr_file not found");
	return undef;
    }

    my $copyrightdir = $spec->eval ("%_pkgmapdir") . "/copyright";
    if (defined $package) {
	$pkgname = "$package";
    }
    eval_file ($spec, "$srcdir/$cr_file", "$copyrightdir/${pkgname}.copyright");

    return "i copyright=$copyrightdir/${pkgname}.copyright\n";
}

sub make_depend ($$) {
    my $spec = shift;
    my $package = shift;

    my @deps = $package->get_array ("requires");

    if (not @deps) {
	print "WARNING: $package: no dependencies\n";
	return "";
    }

    my $fhandle = "pkginfo" . ++$file_id;

    my $pkgdependdir = $spec->eval ("%_pkgmapdir") . "/depend";
    my $fname = $package . ".depend";
    my $topdir = $spec->eval ("%_topdir");
    open $fhandle, ">$pkgdependdir/$fname" or
	fatal ("failed to create file $pkgdependdir/$fname");

    foreach my $dep (@deps) {
	if (not defined ($dep)) {
	    next;
	}
	# FIXME: we're simple chopping off any version comparisons
	# should really verify them instead
	$dep =~ s/(\S+).*/$1/;
	# look for a package defined in this spec file first
	my $subpkg = $spec->find_package_by_name ($dep);
	if (defined ($subpkg)) {
	    print $fhandle "P $dep " . $subpkg->get_tag ("summary") . "\n";
	    next;
	}
	# look for packages installed on the system
	my $pkgname = `/usr/bin/pkginfo '$dep.*' 2>/dev/null | head -1`;
	chomp ($pkgname);
	if ($pkgname ne '') {
	    $pkgname =~ s/^\S*\s*$dep\s*(\S.*)$/$1/;
	    print $fhandle "P $dep $pkgname\n"; 
	    next;
	}
	
        # If the dep is a file that exists, see if we can work out what
        # package(s) own it
        if (-e $dep) {
            my @pkgs = $pkgdb->file2pkgs($dep);
            my $pkg;
            if (@pkgs == 1) { 
                $pkg = $pkgs[0];
		if ($pkg =~ /^pkg:\//) {
		    # we're on an ips-based system, need to translate the
		    # dependency to a legacy package
		    $pkg = ips_to_svr4($pkg);
		}
            } elsif (@pkgs) {
                # This /should/ be a directory, rather than a file
                # (according to contents(4) on solaris-10, only 
                # directories can be owned by more than one package)
                # but I bet you can have files owned by more than one.
                # We'll choose a package and warn.
                my @favoured_packages = qw(pkg:/SUNWcs 
                                           SUNWcsr SUNWcsu SUNWcsxu
                                           SUNWcar SUNWcarx SUNWcsd
                                           SUNWcsl SUNWcslx);
                foreach my $p (@favoured_packages) {
                    # if we depend on a favoured package, depend 
                    # only on it.
                    my @ps = grep /^${p}(@.*)?$/, @pkgs;
		    $pkg = $ps[0];
		    last if defined ($pkg);
                }
                # If we have no better idea, prefer SUNW packages to others
		if (not defined ($pkg)) {
		    my @sunpkgs = grep /^SUNW/, @pkgs;
		    if (@sunpkgs >= 1) { 
			$pkg = $sunpkgs[0];
		    }
		}
                # Oh, sod it.  Depend on the first one.  We could perhaps
                # do better.
                $pkg = $pkgs[0] unless defined $pkg;
		
		if ($pkg =~ /^pkg:\//) {
		    # we're on an ips-based system, need to translate the
		    # dependency to a legacy package
		    $pkg = ips_to_svr4($pkg);
		}

                message("WARNING: $dep could mean a dependency on "
                        . "many packages.  Choosing $pkg from "
                        . join(', ', map "'$_'", @pkgs));
	    }
	    if ($pkg) {
		my $pkgname = `/usr/bin/pkginfo '$pkg.*' 2>/dev/null | head -1`;
		chomp ($pkgname);
		if ($pkgname ne '') {
		    $pkgname =~ s/^\S*\s*$pkg\s*(\S.*)$/$1/;
		    print $fhandle "P $pkg $pkgname\n";
		    next;
		}
	    }
        } else {
	    # look in list of packages built by pkgtool on this system
	    $pkgname = `grep "^${dep}:" "$topdir/.pkgnames" | head -1`;
	    chomp ($pkgname);
	    if ($pkgname ne '') {
		$pkgname =~ s/^${dep}:(.*)/$1/;
	    } else {
		# look in a predefined list of package names
		$pkgname = `grep "^${dep}:" "@PKGBUILD_LIBDIR@/pkgnames" | head -1`;
		chomp ($pkgname);
		if ($pkgname ne '') {
		    $pkgname =~ s/^${dep}:(.*)/$1/;
		} else {
		    message ("warning: could not find the description of "
			     . "package $dep", "omitting from depend file");
		    next;
		}
	    }
	}
	print $fhandle "P $dep $pkgname\n"; 
    }

    close $fhandle;
    return "i depend=$pkgdependdir/$fname\n";
}

sub make_scripts ($$) {
    my $spec = shift;
    my $package = shift;

    my $retstr = "";
    my $scriptdir = $spec->eval ("%_pkgmapdir") . "/scripts";

    my $pre = $package->get_block ("pre");
    if (defined ($pre)) {
	my $fhandle = "script" . ++$file_id;
	my $fname = $package . ".preinstall";
	open $fhandle, ">$scriptdir/$fname" or
	    fatal ("failed to create file $scriptdir/$fname");
	print $fhandle "$pre\n";
	close $fhandle;
	$retstr = $retstr . "i preinstall=$scriptdir/$fname\n";
    }

    my $post = $package->get_block ("post");
    if (defined ($post)) {
	my $fhandle = "script" . ++$file_id;
	my $fname = $package . ".postinstall";
	open $fhandle, ">$scriptdir/$fname" or
	    fatal ("failed to create file $scriptdir/$fname");
	print $fhandle "$post\n";
	close $fhandle;
	$retstr = $retstr . "i postinstall=$scriptdir/$fname\n";
    }

    my $preun = $package->get_block ("preun");
    if (defined ($preun)) {
	my $fhandle = "script" . ++$file_id;
	my $fname = $package . ".preremove";
	open $fhandle, ">$scriptdir/$fname" or
	    fatal ("failed to create file $scriptdir/$fname");
	print $fhandle "$preun\n";
	close $fhandle;
	$retstr = $retstr . "i preremove=$scriptdir/$fname\n";
    }

    my $postun = $package->get_block ("postun");
    if (defined ($postun)) {
	my $fhandle = "script" . ++$file_id;
	my $fname = $package . ".postremove";
	open $fhandle, ">$scriptdir/$fname" or
	    fatal ("failed to create file $scriptdir/$fname");
	print $fhandle "$postun\n";
	close $fhandle;
	$retstr = $retstr . "i postremove=$scriptdir/$fname\n";
    }

    my @classes = $package->get_classes ();
    foreach my $class_name (@classes) {
	next if not defined $class_name;
	next if $class_name eq "none";
	my $script = $package->get_class_script ($class_name, "iclass");
	if (not defined $script) {
	    my $err = $package->get_error ();
	    return undef if defined $err;
	} else {
	    open $fhandle, ">$scriptdir/i.$class_name" or
		fatal ("failed to create file $scriptdir/i.$class_name");
	    print $fhandle "$script";
	    close $fhandle;
	    $retstr = $retstr . "i i.$class_name=$scriptdir/i.$class_name\n";
	}
	$script = $package->get_class_script ($class_name, "rclass");
	if (not defined $script) {
	    my $err = $package->get_error ();
	    return undef if defined $err;
	} else {
	    open $fhandle, ">$scriptdir/r.$class_name" or
		fatal ("failed to create file $scriptdir/r.$class_name");
	    print $fhandle "$script";
	    close $fhandle;
	    $retstr = $retstr . "i r.$class_name=$scriptdir/r.$class_name\n";
	}
    }

    return $retstr;
}

sub get_file_mode ($) {
    my $fname = shift;

    $mode = (stat($fname))[2];
    if (not defined ($mode)) {
	print "WARNING: could not stat() $fname\n";
	return "0644";
    }
    return sprintf("%04o", $mode & 07777);
}

sub get_file_type ($) {
    my $fname = shift;

    if (-l $fname) {
	return "s";
    } elsif (-d $fname) {
	return "d";
    } elsif (-p $fname) {
	return "p";
    } elsif (-b $fname) {
	return "b";
    } elsif (-c $fname) {
	return "c";
    } elsif (-f $fname) {
	return "f";
    } else {
	return "-";
    }
}

# return the directory, relative to $basedir, where %doc files are
# placed for $package
sub get_docdir ($$) {
    my $package = shift;
    my $basedir = shift;

    my $docdir = $package->eval ("%_pkg_docdir");
    if ($docdir eq '%_pkg_docdir') {
	$docdir = $package->eval ("%{_datadir}/%{name}");
    }

    if (index ($docdir, $basedir) != 0) {
	$package->_set_error ("%_pkg_docdir ($docdir) is not under basedir $basedir");
	return undef;
    }

    $docdir = substr ($docdir, length ($basedir));
    $docdir =~ s/^\/*//;

    return $docdir;
}

# process a %doc file and return the proto line for $type: ips or svr4
sub get_doc_proto_line ($$$$) {
    my $type = shift;
    my $file = shift;
    my $fname = shift;
    my $basedir = shift;

    my $package = $file->get_package ();
    my $docdir = get_docdir ($package, $basedir);
    return undef if not defined ($docdir);
    # now find the build directory:
    my $blddir = $package->eval ("%{_builddir}");
    my $bsdirname = $package->eval ('%{_build_src_dir_name}');
    if ($bsdirname eq '%{_build_src_dir_name}') {
	$bsdirname = $package->eval ('%name-%version');
    }

    my $doc_subdir = $file->get_doc_subdir();
    if (defined ($doc_subdir)) {
	$doc_subdir .= "/";
    } else {
	$doc_subdir = "";
    }

    if (! -f "$blddir/$bsdirname/$doc_subdir$fname") {
	return undef;
    }
    my $mydir = `pwd`;
    chomp ($mydir);
    # get the directory of $fname, in case we have something like
    # %doc foo/bar/COPYING
    my $fname_basedir = dirname ($fname);
    mkdir_p ("./$basedir/$docdir/$fname_basedir") or fatal ("Failed to create directory $mydir/$docdir/$fname_basedir");
    system ("cp -p '$blddir/$bsdirname/$doc_subdir$fname' './$basedir/$docdir/$fname_basedir'");
    if ($? != 0) {
	fatal ("ERROR: failed to copy $fname to $mydir/$basedir/$docdir/$fname_basedir");
	return undef;
    }
    my $compression = $file->get_compression ();
    if (defined ($compression)) {
	my $comp_retval;
	if ($compression eq 'compress') {
	    system ("rm -f './$basedir/$docdir/${fname}.Z'");
	    system ("/usr/bin/compress -f './$basedir/$docdir/$fname'");
	    $comp_retval = $?;
	    $fname .= ".Z";
	} elsif ($compression eq 'gzip') {
	    system ("rm -f './$basedir/$docdir/${fname}.gz'");
	    system ("/usr/bin/gzip -9 './$basedir/$docdir/$fname'");
	    $comp_retval = $?;
	    $fname .= ".gz";
	} elsif ($compression eq 'bzip2') {
	    system ("rm -f './$basedir/$docdir/${fname}.bz2'");
	    system ("/usr/bin/bzip2 -9 './$basedir/$docdir/$fname'");
	    $comp_retval = $?;
	    $fname .= ".bz2";
	}
	if ($comp_retval != 0) {
	    fatal ("ERROR: failed to $compression documentation file $mydir/$basedir/$docdir/$fname");
	    return undef;
	}
    }
	
    my $pkgbasedir = "$basedir/";
    $pkgbasedir =~ s/\/\/*/\//g;
    $pkgbasedir = substr ($pkgbasedir, 1);
    $all_files{"$pkgbasedir$docdir/$fname"} = "$package";
    if ($type eq 'svr4') {
	return "f none $docdir/$fname=$pkgbasedir$docdir/$fname 0444 root bin";
    } elsif ($type eq 'ips') {
	my $svr_package = $file->get_package->get_svr4_name();
	my $svrfname = $file->get_package ()->eval ("%_pkgdir") . "/" . $svr_package . "/reloc/" . "$docdir/$fname";
	return "file $svrfname mode=0444 owner=root group=bin path=\"$pkgbasedir$docdir/$fname\" doc=true";
    } else {
	return undef;
    }
}

# FIXME: this is ugly as hell
sub get_proto_line ($$$$$$$$) {
    my $file = shift;
    my $class_name = shift;
    my $buildroot = shift;
    my $fname = shift;
    my $basedir = shift;
    my $def_mode = shift;
    my $def_user = shift;
    my $def_grp = shift;

    my $mode = $def_mode;
    my $user = $def_user;
    my $group = $def_grp;
    my $ghost = 0;

    my $type = get_file_type ($fname);

    if (($type eq '-') and defined ($file) and $file->is_doc ()) {
	# documentation file, goes under /usr/share/doc/<package name>
	# must be copied to $RPM_BUILD_ROOT from the build dir
	return get_doc_proto_line ('svr4', $file, $fname, $basedir);
    }

    if ($type eq '-') {
	if (defined ($file) and not $file->is_ghost ()) {
	    # we don't know what type of file it is
	    # or it doesn't exist
	    return undef;
	} else {
	    if (not defined ($file)) {
		# parent dir of a ghost
		$ghost = 1;
		$type = 'd';
	    } else {
		$ghost = 1;
		$type='g';
	    }
	}
    }

    if ($class_name ne 'none' and $type eq 'f' and $file->is_config ()) {
	$type = "e";
    }

    if ($type eq 'f' and defined ($file)) {
	if ($file->is_ghost ()) {
	    $type = 'v';
	} elsif ($file->is_config ()) {
	    $type = 'v';
	}
    }

    if (index ("/$fname", $basedir) != 0) {
	fatal ("file $fname is not under basedir $basedir");
    }	
    
    if ( "/$fname" eq $basedir) {
	fatal ("file $fname is the base directory, should not be listed in %files");
    }

    $basedir = "$basedir/";
    $basedir =~ s/\/\/*/\//g;
    $basedir = substr ("$basedir", 1);

    my $relpath = substr ($fname, length ($basedir));
    my $protoline;

    if ($def_mode eq '-' and $type ne 's') {
	if ($ghost) {
	    if ($type eq 'd') {
		$mode = '0755';
	    } else {
		$mode = '0644';
	    }
	} else {
	    $mode = get_file_mode ($fname);
	}
    }
    if ($def_user eq '-') {
	if ($ghost) {
	    $user = 'root';
	} else {
	    $user = getpwuid ((stat($fname))[4]);
	}
    }
    if ($def_grp eq '-') {
	if ($ghost) {
	    $group = 'root';
	} else {
	    $group = getgrgid ((stat($fname))[5]);
	}
    }

    if ($type eq 'f' or $type eq 'v' or $type eq 'e') {
	$protoline = "$type $class_name $relpath=$basedir$relpath $mode $user $group";
    } elsif ($type eq 'd') {
	$protoline = "$type $class_name $relpath $mode $user $group";
    } elsif ($type eq 'g') {
	$protoline = "v $class_name $relpath=/dev/null $mode $user $group";
    } elsif ($type eq 's') {
	my $linkpoint = readlink ($fname);
	my $buildroot_reg = $buildroot;
	$buildroot_reg =~ s/([\+\*\(\)\[\].\\])/\\$1/g;
	if ($linkpoint =~ /^$buildroot_reg/) {
	    fatal ("ERROR: /$fname is an absolute symlink that points to \$RPM_BUILD_ROOT");
	} elsif ($linkpoint =~ /^\//) {
	    print "WARNING: $fname is an absolute symlink\n";
	}
	if ($file->is_hardlink()) {
	    $protoline = "l none $relpath=$linkpoint";
	} else {
	    $protoline = "$type none $relpath=$linkpoint";
	}
    } elsif ($type =~ /(c|b)/) {
	fatal ('device special files not implemented');
    } else {
	fatal ('ASSERTION FAILED: get_proto_line');
    }

    return $protoline;
}

sub list_all_files ($) {
    my $dirname = shift;

    my $find_output = `find $dirname -print | grep -v "^$dirname\$"`;
    my @file_list = split /\n/, $find_output;

    return @file_list;
}

# Start filling up the manifest
# If the type is not supported write warning and return undef
sub get_ips_proto_line ($$$$$$$$$$$) {
    my $file = shift;
    my $class_name = shift;
    my $buildroot = shift;
    my $fname = shift;
    my $basedir = shift;
    my $def_mode = shift;
    my $def_user = shift;
    my $def_grp = shift;
    my $hardlink = shift;
    my $svr_package = shift;
    my $spec = shift;

    my $mode = $def_mode;
    my $user = $def_user;
    my $group = $def_grp;

    # Delete double // from fname: example /usr//lib 
    $fname =~ s/\/+/\//g;
    my $type = get_file_type ($fname);
    my $line;
    
    debug_print "get_ips_proto_line $fname";
    if (($type eq '-') and defined ($file) and $file->is_doc ()) {
	# documentation file, goes under /usr/share/doc/<package name>
	# must be copied to $RPM_BUILD_ROOT from the build dir
	return get_doc_proto_line ('ips', $file, $fname, $basedir);
    }

    if ( $type eq 'g' ) {
	print "Warning: Ghost files are *not* supported, yet\n";
	return undef;
    }

    if (($mode eq "-") and ($type ne "-")) {
	$mode = get_file_mode ($fname);
    }

    if ( $user eq '-' ) {
	$user = getpwuid ((stat($fname))[4]);
    }

    if ( $group eq '-' ) {
	$group = getgrgid ((stat($fname))[5]);
    }

    $basedir = "$basedir/";
    $basedir =~ s/\/\/*/\//g;
    $basedir = substr ("$basedir", 1);

    my $relpath = substr ($fname, length ($basedir));

    my $svrfname = $spec->eval ("%_pkgdir") . "/" . $svr_package . "/reloc/" . $relpath;

    if ( $type eq 'f' and defined $file) {
	$line = "file $svrfname mode=$mode owner=$user group=$group path=\"$fname\"";
	if ($file->is_config()) {
	    $line .= " preserve=\"renamenew\"";
	}    
    } elsif ( $type eq 'd' ) {
	my $file1 = $fname;
	if ( not defined $file ) {
	    $file1 = $fname;
	    $file1 =~ s/^$buildroot//;
	    if ( $file1 !~ /^\// ) {
		$file1 = "/$file1";
	    }
	}
	$line = "dir mode=$mode owner=$user group=$group path=\"$file1\"";	
    } elsif ( $type eq 's' ) {
	# read the link target of the file in the proto area
	my $target = readlink ($fname);
	# Hardlinks are not tested in $RPM_BUILD_DIR, but they are used
	# only if spec file creator mark %files as hardlinks ...
	if ( defined $hardlink ){
	    $line = "hardlink path=\"$fname\" target=\"$target\"";
	} else {
	    $line = "link path=\"$fname\" target=\"$target\"";
	}
    }
    else {
	print "Warning: Unsupported object type $type on file $svrfname\n";
    }
	
    return $line;	
}

# Find all matches (in shell regexp file context)
# Return reference to array of files/dirs/links or whatever
sub find_all_matches($$) {
    my $fname = shift;
    my $build_path = shift;
    my $dirname = $build_path . $fname;
    #delete more duplicates of / - example /usr//lib
    $dirname =~ s/\/\/+/\//g;
    my $find_output = `find $dirname`;
    my @file_list = split /\n/, $find_output;
    
    # now remove all build_path prefixes 
    foreach $line (@file_list) {
	$line =~ s/^$build_path//;
	# Check if there is '/' at the beggining of path if not add it
	if ( $line !~ /^\// ) {
	    $line = "/$line";
	}
    }
    return \@file_list;
} 

# Specify if we want a proto hash for SVr4 or IPS
sub get_proto_hash ($$$) {
    my $spec = shift;
    my $package = shift;
    my $do_ips = shift;

    if (defined ($do_ips)) {
	debug_print "Collecting IPS proto information";
    } else {
	debug_print "Collecting SVr4 proto information";
    }
      
    my $has_errors = 0;

    my @files = $package->get_files ();
    my $error = $package->get_error ();
    my @defattr = $package->get_defattr ();
    if (defined ($error)) {
	print "ERROR: $error\n";
	return undef;
    }
    if (not @files) {
        my %empty_hash;
	return \%empty_hash;
    }
    
    my %file_info = ();
    my %default_dirs = ();

    my $cwd = `pwd`;
    chomp ($cwd);
    my $buildroot = $package->eval ("%buildroot");
    my $basedir = $package->get_tag ("sunw_basedir");
    if (not defined ($basedir) or ($basedir eq "")) {
	$basedir = "/";
    }
	
    chdir ($buildroot);

    foreach my $file (@files) {
	next if not $file;
	my $fn = "$file";
	# remove duplicate /'s, e.g. /etc///passwd
	$fn =~ s/^\/+//g;
	# remove /'s and whitespace from the end of the file name
	# except if fn is /
	$fn =~ s/(.)\/*\s*$/$1/;
	my $class_name = $file->get_class ();
	my @file_list;
	if (-f $fn) {
	    @file_list = ($fn);
	} else {
	    @file_list = glob ($fn);
	}
	if ((not @file_list) and (not $file->is_ghost())) {
	    message ("File not found by glob: $buildroot$file");
	    $has_errors = 1;
	}

	my @attribs = $file->get_attributes ();
	my @defattribs = $file->get_defattributes ();
	my @rec_list = ();
	
	foreach my $fname (@file_list) {
	    if (-d $fname) {
		if ($file->is_recursive()) {
		    my @files_in_dir = list_all_files ($fname);
		    @rec_list = (@rec_list, @files_in_dir);
		}
	    }
	}
    
	my @all_file_list = (@file_list, @rec_list);
	foreach my $fname (@all_file_list) {
	    if (defined ($file_info{$fname})) {
		message ("File listed twice: $fname");
		$has_errors = 1;
	    }
	    
	    if (not defined ($file_info{$fname})) {
		# Assume that we are going to use the defattrs;
                # we'll fixup later
                my @attribsToUse = @defattribs;
                my $mode = $attribsToUse[0];
                # We use the directory mode if this 
                # is a directory (and we have a default directory
                # mode)
                if ( -d $buildroot . '/' . $fname) {
                    if (exists $attribsToUse[3]) {
                        $mode = $attribsToUse[3];
                    }
                }
		
                # We use the attribs (rather than the defattribs)
                # if this is the file listed in %files AND
                # we have attributes
                if (grep $fname eq $_, @all_file_list) {
                    if (@attribs) {
                        @attribsToUse = @attribs;
                        $mode = $attribs[0];
                    }
                }
			
		my $pline;
		if (defined $do_ips) {
		    my $hardlink = undef;
		    
		    # FIXME: $fname should be used and not $file!
		    # 	but $fname wrong data type ( string?)
		    if ($file->is_hardlink()) {
			$hardlink = 1;
		    }
		    
		    if ( not defined $file_info{$fname} ) {
			$pline = undef;
			$pline = get_ips_proto_line ($file,
						     $class_name,
						     $buildroot,
						     $fname, 
						     $basedir,
						     $mode,
						     $attribsToUse[1],
						     $attribsToUse[2],
						     $hardlink,
						     $package->get_svr4_name(), $spec);
			if (not defined ($pline)) {
			    message ("IPS: File not found by glob: $buildroot/$fname");
			    $has_errors = 1;
			}
			$file_info{$fname} = $pline;
			if (defined ($all_files{$fname}) and substr ($pline, 0, 1) ne "d") {
			    # FIXME: Is this a warning I should care about?
			    #print "WARNING IPS: $fname is included in both $package and $all_files{$fname}\n";
			}
		    }
		} else {
		    # Now collect for SVr4 packages
		    my $pline = get_proto_line ($file,
						$class_name,
						$buildroot,
						$fname, 
						$basedir,
						$mode,
						$attribsToUse[1],
						$attribsToUse[2]);
		    if (not defined ($pline)) {
			$has_errors = 1;
			if ($file->is_doc ()) {
			    message ("Documentation (%doc) file not found: $fname");
			} else {
			    message ("File not found by glob: $buildroot/$fname");
			}
		    }
		    $file_info{$fname} = $pline;
		    if (defined ($all_files{$fname}) and
			substr ($pline, 0, 1) ne "d") {
			my $err_msg;
			if ($file->is_doc ()) {
			    $err_msg = "documentation file $fname is included in both $package and $all_files{$fname}";
			} else {
			    $err_msg = "$fname is included in both $package and $all_files{$fname}";
			}
			if ($package->eval ('%_duplicate_files_terminate_build') eq 1) {
			    print "ERROR: $err_msg\n";
			    $package->_set_error ("$err_msg");
			    $has_errors = 1;
			} else {
			    print "WARNING: $err_msg\n";
			}
		    }
		}
		# automatically adding all missing parent dirs
		my $parent_dir = $fname;
		if ($file->is_doc and not "$file" =~ /^\//) {
		    # %doc files may not include the docdir, only the file name
		    # so we prepend the name of the docdir otherwise it wouldn't
		    # be found in $RPM_BUILD_ROOT
		    my $docdir = get_docdir ($package, $basedir);
		    if (not defined ($docdir)) {
			$has_errors = 1;
		    } else {
			$parent_dir = "$basedir/$docdir/$fname";
			# delete leading /s
			$parent_dir =~ s/^\/+//;
		    }
		}
		$parent_dir =~ s/\/[^\/]+$//;
		while ($parent_dir ne "" and
		       "/$parent_dir" ne "$basedir" and
		       not defined ($file_info{$parent_dir}) and
		       not defined ($default_dirs{$parent_dir})) {
		    my $dirmode = $defattr[3];
            	    if (not defined $dirmode or $dirmode eq '-') {
			$dirmode = $defattr[0]; # fall back to old behaviour
		    }
		    my $pline;
		    if (defined $do_ips) {
			$pline = get_ips_proto_line(undef,
						    "none",
						    $buildroot,
						    $parent_dir,
						    $basedir,
						    $dirmode,
						    $defattr[1],
						    $defattr[2],
						    undef,
						    $package->get_svr4_name(), $spec);
		    } else {
			$pline = get_proto_line (undef,
						 "none",
						 $buildroot,
						 $parent_dir,
						 $basedir,
						 $dirmode,
						 $defattr[1],
						 $defattr[2]);
		    }
		    if (defined ($pline)) {
			$default_dirs{$parent_dir} = $pline;
		    } else {
			last;
		    }
		    $parent_dir =~ s/\/[^\/]+$//;
		}
	    }
    	}
    }
    chdir ($cwd);

    foreach my $dirname (keys %default_dirs) {
	if (not defined ($file_info{$dirname})) {
	    $file_info{$dirname} = $default_dirs{$dirname}
	}
    }

    if ($has_errors == 1) {
	return undef;
    } else {
	return \%file_info;
    }
}

sub make_solaris_pkg ($$) {
    my $spec = shift;
    my $package = shift;

    my $pkginfo_proto = make_pkginfo ($spec, $package);
    my $dep_proto = make_depend ($spec, $package);
    my $scr_proto = make_scripts ($spec, $package);
    return 0 if not defined $scr_proto;
    my $copyright = make_copyright ($spec, $package);

    my $files_ref = get_proto_hash ($spec, $package, undef);
    if (not defined ($files_ref)) {
	if ($spec->has_error ()) {
	    print ("pkgbuild: " . $spec->get_error () . "\n");
	}
	exit (1);
    }
    my %files = %$files_ref;
    foreach my $file (keys %files) {
	$file =~ s/^\/+//;
	$all_files{$file} = "$package";
    }
    if (not %files) {
	print "WARNING: empty package: $package\n";
    }

    my $fhandle = "proto" . ++$file_id;

    my $protodir = $spec->eval ("%_pkgmapdir") . "/proto";
    my $fname = $package . ".proto";
    open $fhandle, ">$protodir/$fname" or
	fatal ("failed to create file $protodir/$fname");

    print $fhandle $pkginfo_proto;
    print $fhandle $dep_proto;
    print $fhandle $scr_proto;
    if (defined $copyright) {
	print $fhandle $copyright;
    }
    foreach my $fname (sort (keys %files)) {
	next if not $fname;
	print $fhandle $files{$fname};
	print $fhandle "\n";
    }
    close ($fhandle);

    my $pkgdir = $spec->eval ("%_pkgdir");
    my $buildroot = $package->eval ("%buildroot");
    system ("/usr/bin/pkgmk -o -r $buildroot -d $pkgdir -f $protodir/$fname");
    my $retval = $?;
    if ($retval) {
	return 0;
    }

    if ($pkgformat eq "datastream") {
	my $inst = $package->get_tag ('SUNW_Pkg');
	$inst = "$package" unless $inst;
	my $version = $package->get_tag ('Version');
	my $dsname = "${inst}-${version}.${arch}.pkg";
	system ("/usr/bin/pkgtrans -o -s $pkgdir $pkgdir/$dsname $inst");
	$retval = $?;
	if (not $retval) {
	    system ("rm -rf $pkgdir/$inst");
	}
    }

    return (not $retval);
}


sub _uniq (@) {
    my @arr = @_;

    my %h;

    foreach my $elem (@arr) {
	next if not defined $elem;
	$h{$elem} = 1;
    }
    return keys %h;
}


# Write dependency info for pkgsend (without pkgsend command)
# The first agument contain reference to array - at the end of this
# array
sub make_ips_dependency ($$$) {
    my $ref_lines = shift;
    my $spec = shift;
    my $package = shift;
    
    my @packages = $spec->get_packages();
    my @deps;
    foreach my $pkg (@packages) {
	if ($pkg->is_subpkg()) {
	    # is this a subpkg of $package?
	    next if ("${package}-" . $pkg->get_pkg_tag() ne "$pkg");
	} else {
	    # is this $package?
	    next if ("${package}" ne "${pkg}");
	}
	my @pkg_deps = $package->get_array('requires');
	if (@pkg_deps) {
	    push (@deps, @pkg_deps);
	}
    }
    my @dep_lines = ();
    foreach my $dep (@deps) {
	# FIXME: we're simple chopping off any version comparisons
	# should really verify them instead
	$dep =~ s/(\S+).*/$1/;
	my $ips_dep = svr4_to_ips ($dep);
	if (not defined ($ips_dep)) {
	    if (-e $dep) {
		my @pkgs = $pkgdb->file2pkgs($dep);
		if (@pkgs == 1) {
		    if ($pkgs[0] =~ /^pkg:\//) {
			push @dep_lines, "depend fmri=$pkgs[0] type=require";
		    }
		} elsif (@pkgs) {
		    # multiple packages found
		    # see, if SUNWcs is one of them
		    my @cs = grep /^pkg:\/SUNWcs@/, @pkgs;
		    if (@cs) {
			message("WARNING: multiple packages match dependency: $dep, choosing pkg:/SUNWcs");
			push @dep_lines, "depend fmri=$cs[0] type=require";
		    } else {
			# SUNWcs not found
			# use the first package name found
			message("WARNING: multiple packages match dependency: $dep");
			push @dep_lines, "depend fmri=$pkgs[0] type=require";
		    }
		} else {
		    message("WARNING: Unknown dependency: $dep");
		}
	    }
	    next;
	}
	push @dep_lines, "depend fmri=$ips_dep type=require";
    }
    push @$ref_lines, _uniq (@dep_lines)
}

# Add open transaction line - with pkgsend command
sub open_ips_transaction($$) {
    my $ref_lines = shift;
    my $package = shift;
    
    my $name = "$package";
    my $ips_vendor_version = $package->eval ("%{?ips_vendor_version}%{!?ips_vendor_version:%version}");
    my $version = $package->eval("%ips_component_version,%ips_build_version-$ips_vendor_version");
	
    my $manifest = $package->eval ("%_pkgmapdir") . "/manifests/${package}.manifest";

    if (scalar @lines > 0) {
	print "Warning: Open transaction isn't first line of pkgsend script!\n";
    }
    push (@$ref_lines, "export PKG_REPO=\${PKGBUILD_IPS_SERVER:-$ips_server}");
    push (@$ref_lines, "eval `pkgsend open $name\@$version` || exit 1");
    push (@$ref_lines, "pkgsend include $manifest || exit 2");
} 

# Add summary line 
sub add_ips_license($$) {
    my $ref_lines = shift;
    my $package = shift;
    
    my $svr4_name = $package->get_svr4_name ();
    my $license_file= $package->eval ("%_pkgdir") . "/" . $svr4_name . "/install/copyright";

    return if not -f $license_file;
    my $license = $package->get_tag ("license");
    if (not defined ($license)) {
	# License is the new name for the Copyright tag
	$license = $package->get_tag ("copyright");
    }
    if (not defined ($license)) {
	$license = "unknown";
    }
    push (@$ref_lines, "license $license_file license=\"$license\"");
}

# Add summary line 
sub add_ips_summary($$) {
    my $ref_lines = shift;
    my $package = shift;

    my $meta_hash = $package->get_meta_hash();
    if (not defined ($$meta_hash{'pkg.name'})) {
	my $name = $package->get_tag("name");
	$$meta_hash{'pkg.name'} = $name;
    }
    if (not defined ($$meta_hash{'description'})) {
	my $summary = $package->get_tag("summary");
	$$meta_hash{'description'} = $summary;
    }
    if (not defined ($$meta_hash{'pkg.summary'})) {
	my $summary = $package->get_tag("summary");
	$$meta_hash{'pkg.summary'} = $summary;
    }
    if (not defined ($$meta_hash{'info.upstream_url'})) {
	my $upstream_url = $package->get_tag("url");
	$upstream_url = "http://pkgbuild.sf.net/" unless defined ($upstream_url);
	$$meta_hash{'info.upstream_url'} = $upstream_url;
    }
    if (not defined ($$meta_hash{'info.maintainer_url'})) {
	push (@$ref_lines, "set name=info.maintainer_url value=\"pkgbuild-sfe-devel\@sourceforge\.net\"");
    }

    foreach my $meta (keys %{$meta_hash}) {
	# handle info.classification separately, as there may be more than one
	# and they need to be in the same action
	next if $meta eq "info.classification";
	push (@$ref_lines, "set name=$meta value=\"$$meta_hash{$meta}\"");
    }

    # FIXME: this allows up to 2 classifications:
    #  1) defined using the Group tags, this must be a freedesktop.org group
    #  2) defined using meta(info.classification)
    my $group = $package->get_tag("group");
    my $classification_value;
    if (defined $group) {
	$classification_value = "value=\"org.freedesktop:" . $group . "\"";
    }

    if (defined $$meta_hash{"info.classification"}) {
	if (defined($classification_value)) {
	    $classification_value .= "value=\"" . $$meta_hash{"info.classification"} . "\"";
	} else {
	    $classification_value = " value=\"" . $$meta_hash{"info.classification"} . "\"";
	}
    }

    if (defined ($classification_value)) {
	push (@$ref_lines, "set name=info.classification $classification_value");
    }

    # add pointers sources specified by URLs and not listed in NoSource
    my @sources = $package->get_spec()->get_public_sources ();
    my $source_values = "";
    foreach my $src (@sources) {
	next if (not $src =~ /^(http|https|ftp):\/\//);
	$source_values .= " value=\"$src\"";
    }
    if ($source_values ne "") {
	push (@$ref_lines, "set name=info.source_url$source_values");
    }
}

sub add_ips_legacy($$$) {
    my $ref_lines = shift;
    my $spec = shift;
    my $package = shift;

    my @packages = $spec->get_packages ();
    foreach my $pkg (@packages) {
	if ($pkg->is_subpkg()) {
	    # is this a subpkg of $package?
	    next if ("${package}-" . $pkg->get_pkg_tag() ne "$pkg");
	} else {
	    # is this $package?
	    next if ("${package}" ne "${pkg}");
	}
	# PKG=$pkgname
	my $pkgname = $pkg->get_tag ('sunw_pkg');
	$pkgname = "$pkg" unless $pkgname;
	my $summary = $pkg->get_tag ('summary');
	$summary = $pkgname unless defined ($summary);
	# NAME=$desc
	# DESC=$desc
	my $desc = $pkg->get_tag ('sunw_desc');
	$desc = $summary unless defined ($desc);
	$desc = $pkgname unless defined ($desc);
	# CATEGORY=$category
	my $category = $pkg->get_tag ('sunw_category');
	if (not defined ($category)) {
	    $category = "application";
	}
	# VENDOR=$vendor
	my $vendor = $pkg->get_tag ('vendor');
	if (defined ($vendor)) {
	    $vendor = "vendor=\"$vendor\"";
	} else {
	    $vendor = "";
	}
	# HOTLINE=$hotline
	my $hotline = $pkg->get_tag ('sunw_hotline');
	$hotline = "Please contact your local service provider" 
	    unless defined ($hotline);
	# VERSION=$version,REV=$rev
	my $version = $pkg->get_tag ('version');
	my $rev = $pkg->get_tag ('sunw_rev');
	if (not defined $rev) {
	    $rev = `date +%Y.%m.%d.%H.%M.%S`;
	}
	chomp ($rev);

	push (@$ref_lines, "legacy arch=$arch category=$category desc=\"$desc\" hotline=\"$hotline\" name=\"$desc\" pkg=$pkgname $vendor version=$version,REV=$rev");

	# as seen in Bart's blog:
        # http://blogs.sun.com/barts/?cat=packaging+and+patching&date=20090204
	push (@$ref_lines, "set name=variant.arch value=$arch");
    }
}

# Add close transaction
sub close_ips_transaction($) {
    my $ref_lines = shift;
    my @lines = @$ref_lines;
    
    push (@$ref_lines , "pkgsend close || exit 3");
}

# Create file list from package with tag for subpackages for pkgsend command
sub make_ips_package ($$$$$) {
    my $spec = shift;
    my $package = shift;
    my $ref_lines = shift;
    my $all_files_ref = shift;
    my $tag = shift;
    
    if (defined $tag) {
	$tag = " $tag=true";
    } else {
	$tag = "";
    }
    
    my $files_ref = get_proto_hash ($spec, $package, 1);
    if (not defined ($files_ref)) {
	exit (1);
    }
    my %files = %$files_ref;
    foreach my $file (keys %files) {
	push(@$ref_lines, $files{$file} . $tag) 
	    unless defined $$all_files_ref{$file};
	# only include each file in the manifest once otherwise
	# we get an error during installation
	$$all_files_ref{$file} = 1;
    }
    if (not %files) {
	print "WARNING: empty package: $package\n";
    }
}

# Prepare pkgsend lines, which add files of package to ips repository
sub make_ips_files ($$$) {
    my $ref_lines = shift;
    my $spec = shift;
    my $package = shift;

    my @packages = $spec->get_packages ();
    my $tag;
    my %all_files_in_manifest = ();
    foreach $pkg (@packages) {
	$tag = $pkg->get_pkg_tag ();
	if ($pkg->is_subpkg()) {
	    # is this a subpkg of $package?
	    next if ("${package}-$tag"  ne "$pkg");
	} else {
	    # is this $package?
	    next if ("${package}" ne "${pkg}");
	}
	debug_print "making package $pkg";
	make_ips_package($spec, $pkg, $ref_lines, \%all_files_in_manifest, $tag);
    }
}

# Create infrastructure for IPS packages
sub create_ips_packages ($) {
    my $spec = shift;

    my @packages = $spec->get_packages ();
    foreach $package (@packages) {
	create_ips_package ($spec, $package) 
	    unless $package->is_subpkg ();
    }
}

sub create_ips_package ($$) {
    my $spec = shift;
    my $package = shift;

    debug_print "Publishing ips package";

    my @pkg_lines;
    my @manifest_lines;
    debug_print "Calling ips_transaction";
    open_ips_transaction(\@pkg_lines, $package);
    debug_print "Calling make_ips_dependency";
    make_ips_dependency(\@manifest_lines, $spec, $package);
    debug_print "Calling make_ips_files";
    make_ips_files(\@manifest_lines, $spec, $package);
    debug_print "Calling add_ips_summary";
    add_ips_summary(\@manifest_lines, $package);
    debug_print "Calling add_ips_license";
    add_ips_legacy(\@manifest_lines, $spec, $package);
    add_ips_license(\@manifest_lines, $package); 
    debug_print "Calling close_ips_transaction";
    close_ips_transaction(\@pkg_lines);
    
    my $script = $spec->eval ("%_pkgmapdir") . "/scripts/${package}_ips.sh";
    my $manifest = $spec->eval ("%_pkgmapdir") . "/manifests/${package}.manifest";

    debug_print "Prepare script - $script";
    prepare_ips_script($spec, $script, \@pkg_lines);
    debug_print "Prepare manifest - $manifest";
    prepare_ips_manifest($spec, $manifest, \@manifest_lines);
}

# publish an IPS package
sub publish_ips_packages ($) {
    my $spec = shift;

    my $retval;
    my @pkgs = $spec->get_packages ();
    foreach my $pkg (@pkgs) {
	next if $pkg->is_subpkg ();
	my $script = $spec->eval ("%_pkgmapdir") . "/scripts/${pkg}_ips.sh";
	print "Calling script $script\n";
	`chmod +x $script`;
	my $msg = `$script`;
	$retval = (! $?);
	print $msg;
    }
    return $retval;
}

# translate an svr4 package name to an IPS package name (and version)
# for use in IPS dependencies
sub svr4_to_ips($) {
    my $pkgname = shift;

    my $search_out = `pkg search -l $pkgname 2>&1 | grep '^legacy_pkg'`;
    chomp ($search_out);
    if ($search_out =~ /^legacy_pkg\s*legacy\s*${pkgname}\s*pkg:\/(\S+)\s*$/) {
	return $1;
    }
    return undef;
}

# translate an ips package name and version to an svr4 package name
# for use in svr4 dependencies
sub ips_to_svr4($) {
    my $pkgname = shift;

    return undef if not defined ($pkgname);
    my $search_out = `pkg contents -Ho action.raw -t legacy $pkgname 2>&1`;
    chomp ($search_out);
    if ($search_out =~ /^legacy.*\s+pkg="*(\S+)"*/) {
	return $1;
    }
    return undef;
}

# Save pkg lines array to script, which publish all info to ips repository
sub prepare_ips_script($$$) {
    my $spec = shift;
    my $file = shift;
    my $ref_lines = shift;
    
    my @lines = @$ref_lines;
    my $build_dir = $spec->eval('%buildroot');
    open FW, ">$file" or die "Failed to open file $file for writing\n";

    print FW "#/usr/bin/bash\n";
    
    foreach $line (@lines) {
	print FW "$line \n";
    }
    close FW; 
}

# Save manifest lines array to file, which gets included when the package is sent
# to the IPS repository

sub prepare_ips_manifest($$$) {
    my $spec = shift;
    my $file = shift;
    my $ref_lines = shift;
    
    my @lines = @$ref_lines;
    my $build_dir = $spec->eval('%buildroot');
    open FW, ">$file" or die "Failed to open file $file for writing\n";
    
    foreach $line (@lines) {
	print FW "$line\n";
    }
    close FW;
}

sub create_svr4_packages ($) {
    my $spec = shift;
    my $has_files_at_all = 0;

    if ($os ne 'solaris') {
#	return 1;
    }

    my @packages = $spec->get_packages ();

    foreach my $pkg (@packages) {
	if ($pkg->has_files()) {
	    $has_files_at_all = 1;
	    make_solaris_pkg ($spec, $pkg) or return 0;
	}
    }

    my $unpackaged = 0;
    my $unpackaged_files_terminate_build =
	$spec->eval ("%_unpackaged_files_terminate_build");
    if ($has_files_at_all) {
	my $buildroot = $spec->eval ("%buildroot");
	if ($buildroot ne "/" and -d $buildroot) {
	    my $old_cwd = `pwd`;
	    chdir ($buildroot) or
		$spec->_set_error ("Failed to access directory $buildroot")
		and return 0;
	    my @all_fnames = list_all_files (".");
	    foreach my $fname (@all_fnames) {
		$fname = substr ($fname, 2);
		if (not defined ($all_files{$fname})) {
		    if (not $unpackaged) {
			$unpackaged = 1;
			if ($unpackaged_files_terminate_build) {
			    print "error: ";
			    # FIXME _set_error is private...
			    $spec->_set_error ("Installed (but unpackaged) file(s) found");
			} else {
			    print "WARNING: ";
			}
			print "Installed (but unpackaged) file(s) found:\n";
		    }
		    print "        /$fname\n";
		}
	    }
	    chdir ($old_cwd);
	}
    }
    
    if ($unpackaged_files_terminate_build and $unpackaged) {
	return 0;
    }
    return 1;
}

sub make_src_pkginfo ($$) {
    my $spec = shift;
    my $pkgname = shift;

    my $fhandle = "pkginfo" . ++$file_id;

    my $pkginfodir = $spec->eval ("%_pkgmapdir") . "/pkginfo";
    my $fname = $pkgname . ".pkginfo";
    open $fhandle, ">$pkginfodir/$fname" or
	fatal ("failed to create file $pkginfodir/$fname");

    print $fhandle "PKG=" . $pkgname . "\n";
    my $summary = $spec->get_value_of ('summary');
    $summary = $pkgname unless defined ($summary);
    print $fhandle "NAME=$summary - sources\n";
    print $fhandle "DESC=$summary - sources\n";
    print $fhandle "ARCH=$arch\n";

    my $prodname = $spec->get_value_of ('sunw_prodname');
    print $fhandle "SUNW_PRODNAME=$prodname\n" if $prodname;

    my $prodvers = $spec->get_value_of ('sunw_prodvers');
    print $fhandle "SUNW_PRODVERS=$prodvers\n" if $prodvers;
    print $fhandle "SUNW_PKGTYPE=usr\n";

    my $pkgvers = $spec->get_value_of ('sunw_pkgvers');
    $pkgvers = "1.0" unless $pkgvers;
    print $fhandle "SUNW_PKGVERS=$pkgvers\n";

    my $category = $spec->get_value_of ('sunw_category');
    if (not defined ($category)) {
	$category = "application";
    }
    print $fhandle "CATEGORY=$category,SOURCE\n";

    my $vendor = $spec->get_value_of ('vendor');
    print $fhandle "VENDOR=$vendor\n" if $vendor;

    my $hotline = $spec->get_value_of ('sunw_hotline');
    print $fhandle "HOTLINE=$hotline\n" if $hotline;
    print $fhandle "EMAIL=\n";

    my $maxinst = $spec->get_value_of ('sunw_maxinst');
    print $fhandle "MAXINST=$maxinst\n" if $maxinst;

    my $version = $spec->eval ('%version');
    my $rev = $spec->get_value_of ('sunw_rev');
    if (not defined $rev) {
	$rev = `date +%Y.%m.%d.%H.%M`;
    } else {
	$rev = "$rev." . `date +%Y.%m.%d.%H.%M`;
    }
    chomp ($rev);
    print $fhandle "VERSION=$version,REV=$rev\n";
    print $fhandle "BASEDIR=/usr\n";
    print $fhandle "CLASSES=none\n";

    close $fhandle;
    return "i pkginfo=$pkginfodir/$fname\n";
}

# source package contents:
# SOURCES/
#    Source<1..n>
#    Patch<1..m>
#    SUNW_CopyRight
#    Class action script files
# SPECS/
#    $self->{file_name}
#    %use'd spec files (recursively)
#    %include'd files (recursively)
sub make_src_package ($) {
    my $spec = shift;

    if ($os ne 'solaris') {
#	return 1;
    }

    my $base_pkg_name = $spec->get_value_of ("sunw_pkg");
    $base_pkg_name = $spec->get_name () if not defined $base_pkg_name;
    my $base_pkg_version = $spec->eval ("%version");

    my $src_pkg_name = $spec->get_value_of ("sourcepackage");
    if (not defined $src_pkg_name) {
	$src_pkg_name = $base_pkg_name;
	$src_pkg_name .= "-src";
    }

    my @sources = $spec->get_public_sources ();

    my @patches = $spec->get_public_patches ();

    my $copyright = $spec->get_value_of ("sunw_copyright");

    my @script_files = $spec->get_class_script_names ();

    my @includes = $spec->get_included_files ();

    my $this_spec_file = $spec->get_file_name ();
    if (not $this_spec_file =~ /^\//) {
	$this_spec_file = "$mydir/$this_spec_file";
    }

    my @used_spec_files = $spec->get_used_spec_files ();

    my $pkginfo_line = make_src_pkginfo ($spec, $src_pkg_name);
    my $copyright_line = make_copyright ($spec, undef, $src_pkg_name);

    my $fhandle = "proto" . ++$file_id;

    my $protodir = $spec->eval ("%_pkgmapdir") . "/proto";
    my $fname = $src_pkg_name . ".proto";
    open $fhandle, ">$protodir/$fname" or
	fatal ("failed to create file $protodir/$fname");

    print $fhandle $pkginfo_line;
    if (defined $copyright_line) {
	print $fhandle $copyright_line;
    }

    my $srcdir = "share/src/${base_pkg_name}-${base_pkg_version}/SOURCES";
    my $specdir = "share/src/${base_pkg_name}-${base_pkg_version}/SPECS";
    print $fhandle "d none share 0755 root sys\n";
    print $fhandle "d none share/src 0755 root sys\n";
    print $fhandle "d none $srcdir 0755 root other\n";
    print $fhandle "d none $specdir 0755 root other\n";

    my $topdir = $spec->eval ("%_topdir");
    foreach my $fname (@sources, @patches, $copyright, @script_files) {
	next if not $fname;
	$fname =~ s/^.*\/([^\/]+)/$1/;
	print $fhandle "f none $srcdir/$fname=$topdir/SOURCES/$fname 644 root other\n";
    }

    foreach my $fname (@includes, @used_spec_files) {
	next if not $fname;
	if (not $fname =~ /\//) {
	    print $fhandle "f none $specdir/$fname=$topdir/SPECS/$fname 644 root other\n";
        } else {
            my $basefname = $fname;
            $basefname =~ s/^.*\/([^\/]+)/$1/;
            print $fhandle "f none $specdir/$basefname=$fname 644 root root\n";
        }
    }
    my $base_spec_name = $this_spec_file;
    $base_spec_name =~ s/^.*\/([^\/]*)$/$1/;
    print $fhandle "f none $specdir/$base_spec_name=$this_spec_file 644 root other\n";
    print $fhandle "s none $specdir/..main.spec=$base_spec_name\n";
    my $sourcedir = $spec->eval ("%_sourcedir");
    open VERSIONFILE, ">$sourcedir/..pkgbuild" or
	fatal ("failed to create file $sourcedir/..pkgbuild");
    print VERSIONFILE "pkgbuild_version=$myversion\n";
    close VERSIONFILE;

    print $fhandle "f none $specdir/..pkgbuild=$sourcedir/..pkgbuild 444 root other\n";

    close ($fhandle);

    my $spkgdir = $spec->eval ("%_srcpkgdir");
    system ("/usr/bin/pkgmk -o -r / -d $spkgdir -f $protodir/$fname");
    my $retval = $?;
    if ($retval) {
	return 0;
    }

    if ($pkgformat eq "datastream") {
	my $dsname = "${src_pkg_name}-${base_pkg_version}.src.pkg";
	system ("/usr/bin/pkgtrans -o -s $spkgdir $spkgdir/$dsname $src_pkg_name");
	$retval = $?;
	if (not $retval) {
	    system ("rm -rf $spkgdir/$src_pkg_name");
	}
    }

    return (not $retval);
}

sub main () {
    process_options ();
    if ($pkgformat eq 'ips') {
	$pkgdb = new pkgdb(1);
    } else {
	$pkgdb = new pkgdb;
    }
    init ();

    if (not @spec_names) {
	if (not defined $build_command and $version_printed) {
	    exit (0);
	}
	fatal ("no spec files given for build");
    }

    if (not defined $build_command) {
	usage ();
    }

    foreach my $spec_name (@spec_names) {
	my $spec = new rpm_spec ($spec_name, \@predefines);
	if (not defined $spec) {
	    fatal ("File is not a regular file: $spec_name");
	}
	my $name = $spec->get_value_of ("name");
	if (defined ($spec->{error})) {
	    fatal ($spec->{error});
	}
	if (not defined($name)) {
	    fatal ("The Name tag is not defined in " .
		   $spec->get_file_name());
	}
	if ($check_deps) {
	    check_build_requires ($spec) or exit (1);
	}
	if ($build_command =~ /p/) {
	    my $builddir = $spec->eval ("%_builddir");
	    mkdir_p ($builddir) or 
		fatal ("Failed to create directory $builddir");
	    do_block ($spec, 'prep') or exit (1);
	}
	if ($build_command =~ /c/) {
	    do_block ($spec, 'build') or exit (1);
	}
	if ($build_command =~ /i/) {
	    do_block ($spec, 'install') or exit (1);
	    do_block ($spec, 'check') or exit (1);
	}
	if ($build_command =~ /[ba]/) {
	    print "Creating packages...\n";
	    my $pkgdir = $spec->eval ("%_pkgdir");
	    mkdir_p ($pkgdir) or fatal ("Failed to create directory $pkgdir");
	    
	    $pkgdir = $spec->eval ("%_pkgmapdir");
	    foreach my $subdir ("copyright", "depend", "pkginfo", "proto", "manifests", "scripts") {
		mkdir_p ("$pkgdir/$subdir")
		    or fatal ("Failed to create directory $pkgdir/subdir");
	    }
	    
	    # Create an SVr4 package
	    create_svr4_packages ($spec) or 
		fatal ($spec->get_error ());
	    
	    if ($pkgformat eq "ips") {
		# Create IPS package(s)
		create_ips_packages ($spec);
		# Call the script to publish it
		if (not publish_ips_packages ($spec)) {
		    print "ERROR: failed to publish package to $ips_server\n";
		    exit (1);
		}
	    }
	}
	if ($build_command =~ /[as]/) {
	    $pkgdir = $spec->eval ("%_srcpkgdir");
	    mkdir_p ($pkgdir) or fatal ("Failed to create directory $pkgdir");
	    make_src_package ($spec) or
		fatal ($spec->get_error ());
	} 
	if ($build_command =~ /[ba]/) {
		do_block ($spec, 'clean') or exit (1);
	}
   }
}

main();
