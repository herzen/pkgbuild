#!@PERL@

@WARNING_MESSAGE_L1@
@WARNING_MESSAGE_L2@
@WARNING_MESSAGE_L3@
@WARNING_MESSAGE_L4@
@WARNING_MESSAGE_L5@
@WARNING_MESSAGE_L6@
@WARNING_MESSAGE_L7@

#use strict;
use warnings;
use Getopt::Long qw(:config gnu_compat no_auto_abbrev bundling);
use rpm_spec;

my $myname = "pkgbuild";
my $myversion = "@PKGBUILD_VERSION@";
my $version_printed = 0;
my $debug_level = 0;
my $verbose = 1;
my $build_command;
my $build_skip = 0;
my $check_deps = 1;

my $mydir;
my @spec_names = ();

my $arch;
my $os;
my $os_rel;

sub init () {
    $arch = `uname -p`;
    chomp ($arch);
    if ($arch eq "unknown") {
	$arch = `uname -m`;
	chomp ($arch);
	if ($arch eq 'i585') {
	    $arch = 'i386';
	} elsif ($arch eq 'i686') {
	    $arch = 'i386';
	}
    }

    $os = `uname -s`;
    chomp ($os);
    $os = lc($os);
    $os_rel = `uname -r`;
    chomp ($os_rel);
    if ($os eq 'sunos') {
	if ($os_rel >= 5) {
	    $os = 'solaris';
	}
    }
}

my @predefines = ();

sub add_define ($) {
    shift;
    my $def = shift;

    push (@predefines, $def);
}

my %build_phases = ('p', 'p', 
		    'c', 'pc',
		    'i', 'pci',
		    'b', 'pcib',
		    'a', 'pciba');

sub short_circuit_option {
    if (defined ($build_command)) {
	$build_command = substr($build_command, length($build_command)-1);
    } else {
	%build_phases = ('p', 'p',
			 'c', 'c',
			 'i', 'i',
			 'b', 'b',
			 'a', 'a');
    }
}

sub set_build_command ($) {
    shift;
    my $key = shift;

    if ($key =~ /^[abicp]$/) {
	$build_command = $build_phases{$key};
    } elsif ($key eq 'l') {
	fatal ("-bl not implemented");
    } else {
	fatal ("pkgbuild: --build (-b) requires one of a,b,i,c,p,l as its sole argument");
    }
}

sub process_options {
    
    GetOptions ('debug=n'   => \$debug_level,
		'help'      => \&usage,
		'version'   => \&print_version,
		'b=s'       => \&set_build_command,
		'bp'        => sub { $build_command = $build_phases{'p'} },
		'bl'        => sub { fatal ("-bl not implemented\n") },
		'bc'        => sub { $build_command = $build_phases{'c'} },
		'bi'        => sub { $build_command = $build_phases{'i'} },
		'bb'        => sub { $build_command = $build_phases{'b'} },
		'ba'        => sub { $build_command = $build_phases{'a'} },
		'short-circuit' => \&short_circuit_option, 
		'build=s'   => \$build_command,
		'deps!'     => \$check_deps,
		'define=s'  => \&add_define,
		'v+'        => \$verbose,
		'rcfile=s'  => sub { print "--rcfile option not implemented\n" },
		'<>' => \&process_args);
}

sub process_args () {
    my $arg = shift;

    if ($arg =~ /^-/) {
	print ("Unknown option: $arg\n");
	exit 1;
    }

    if (not defined $mydir) {
	$mydir = $arg;
	chdir ($arg);
    } else {
	push (@spec_names, $arg);
    }
}

sub print_version () {
    $version_printed = 1;
    print "$myname version $myversion\n";
}

sub usage () {
    print_version();
    print <<_EOF_;
Copyright (C) 2003 - Sun Microsystems, Inc.
This may be freely redistributed under the terms of the GNU GPL

* = the option is implemented 

 Usage:
*  --help                  - print this message
*  --version               - print the version of rpm being used
   all modes support the following arguments:
      --rcfile <file>      - use <file> instead of /etc/rpmrc and \$HOME/.rpmrc
     -v                    - be a little more verbose
     -vv                   - be incredibly verbose (for debugging)
*   -b<stage> <spec>
    -t<stage> <tarball>    - build package, where <stage> is one of:
*         p                - prep (unpack sources and apply patches)
          l                - list check (do some cursory checks on %files)
*         c                - compile (prep and compile)
*         i                - install (prep, compile, install)
*         b                - binary package (prep, compile, install, package)
*         a                - bin/src package (prep, compile, install, package)
*     --short-circuit      - skip straight to specified stage (only for c,i)
      --clean              - remove build tree when done
      --rmsource           - remove sources and spec file when done
      --sign               - generate PGP/GPG signature
      --buildroot <dir>    - use <dir> as the build root
      --target=<platform>+ - build the packages for the build targets
                             platform1...platformN.
      --nobuild            - do not execute any stages
      --timecheck <secs>   - set the time check to <secs> seconds (0 disables)
*     --define "<name> <value>"
                           - define <name> as <value> as if you had
			     "%define <name> <value>" in the spec file 
 
    --rebuild <src_pkg>    - install source package, build binary package and
                             remove spec file, sources, patches, and icons.
    --rmsource <spec>      - remove sources and spec file
    --recompile <src_pkg>  - like --rebuild, but don't build any package
_EOF_
# '
    exit(1);
}

sub message (@) {
    my @messages = @_;

    foreach my $msg (@messages) {
	print "$myname: $msg\n";
    }
}

sub fatal (@) {
    message (@_);
    exit 1;
}

sub get_versions_installed ($) {
    my $pkg = shift;

    my @retlist = ();
    if ($os eq "linux") {
	my $pkglist=`rpm -q --queryformat '%{VERSION}\t%{RELEASE}\t%{SERIAL}\n' $pkg 2>/dev/null`;
	if ($? != 0) {
	    return \@retlist;
	}
	my @pkginfos=split /\n/, $pkglist;
	foreach my $pkginfo (@pkginfos) {
	    next if not defined ($pkginfo);
	    if ($pkginfo =~ /^([^\t]*)\t([^\t]*)\t([^\t]*)$/) {
		push (@retlist, ($1, $2, $3));
	    } else {
		print "WARNING: couldn't parse version number of $pkg\n";
	    }
	}
	return \@retlist;
    } elsif ($os eq "solaris") {
	my $pkglist=`/usr/bin/pkginfo -l '$pkg.*' 2>&1 | grep VERSION: | cut -f2- -d:`;
	if ($? != 0) {
	    return \@retlist;
	}
	my @pkginfos=split /\n/, $pkglist;
	foreach my $pkginfo (@pkginfos) {
	    next if not defined ($pkginfo);
	    if ($pkginfo =~ /^\s*(.*),REV=(.*)\s*$/) {
		push (@retlist, ($1, $2, undef));
	    } else {
		$pkginfo =~ s/\s*//;
		push (@retlist, ($pkginfo, undef, undef));
	    }
	}
	return \@retlist;
    } else {
	return \@retlist;
    }   
}

sub compare_version ($$$$$$$) {
    my $vers1 = shift;
    my $rev1 = shift;
    my $serial1 = shift;
    my $op = shift;
    my $vers2 = shift;
    my $rev2 = shift;
    my $serial2 = shift;

    return 1;

# FIXME: this is unfinished!
    if ($op =~ /S$/) {
	if (not defined ($serial1) or not defined ($serial2)) {
	    return 0;
	}
	my $comp_res = compare_version_string ($serial1, $serial2);
	if ($op eq "=S") {
	    if ($serial1 = $serial2) {
		return 1;
	    }
	} elsif ($op eq "<=S" or $op eq "=<S") {
	} elsif ($op eq ">=S" or $op eq "=>S") {
	}
    } else {
	if (not defined ($version1) or not defined ($version2)) {
	    return 0;
	}
	my $version_comp_res = compare_version_string ($serial1, $serial2);
	my $rev_comp_res;
	if ($version_comp_res == 0) {
	    if (not defined ($version1) or not defined ($version2)) {
		return 0;
	    }
	    my $version_comp_res = compare_version_string ($serial1, $serial2);
	}
	if ($op eq "=") {
	} elsif ($op eq "<=" or $op eq "=<") {
	} elsif ($op eq ">=" or $op eq "=>") {
	}
    }
}

sub check_dep ($$) {
    my $spec = shift;
    my $dep = shift;

    if (not defined ($dep)) {
	return 1;
    }

    my $pkg = $dep;
    $pkg =~ s/\s+.*$//;
    if (not defined ($pkg)) {
	print "empty dependency: $dep\n";
	return 0;
    }
    my $ref_vers;
    my $ref_rev;
    my $ref_serial;
    my $rel_op;
    if ($dep =~ /^$pkg\s*(=|<=|=<|>=|=>)\s*(\S*),REV=(\S*)\s*$/) {
	if ($os eq "solaris") {
	    $rel_op = $1;
	    $ref_vers = $2;
	    $ref_rev = $3;
	} else {
	    $rel_op = $1;
	    $ref_vers = "$2,REV=$3";
	    if ($ref_vers =~ /^([^-]*)-([^-]*)$/) {
		$ref_vers = $1;
		$ref_rev = $2;
	    }
	}
    } elsif ($dep =~ /^$pkg\s*(=|<=|=<|>=|=>)\s*(\S*)\s*$/) {
	$rel_op = $1;
	$ref_vers = $2;
	if ($os eq "linux") {
	    if ($ref_vers =~ /^([^-]*)-([^-]*)$/) {
		$ref_vers = $1;
		$ref_rev = $2;
	    }
	}
    } elsif ($dep =~ /^$pkg\s*(=S|<=S|=<S|>=S|=>S)\s*(\S*)\s*$/) {
	$rel_op = $1;
	$ref_serial = $2;
	if ($os eq "solaris") {
	    print "WARNING: \"Serial\" dependency tests not " .
		"implemented on Solaris\n";
	    print "WARNING: ignoring dependency \"$dep\"\n";
	    return 1;
	}
    } elsif ($dep =~ /^$pkg\s*$/) {
	# no version to compare to, check existance of pkg only
    } else {
	print "WARNING: could not parse dependency: $dep\n";
	return 0;
    }

    my $subpkg = $spec->find_package_by_name ($pkg);
    if (not defined $subpkg) {
	if ($os eq "linux") {
	    `rpm -q $pkg`;
	    if ($? != 0) {
		`rpm -q --provides $pkg`;
		if ($? != 0) {
		    return 0;
		}
	    }
	} elsif ($os eq "solaris") {
	    `/usr/bin/pkginfo -q '$pkg.*'`;
	    if ($? != 0) {
		return 0;
	    }
	} else {
	    print "WARNING: I don't know how to verify dependency $pkg ".
		"on this OS.\n";
	    return 1;
	}
    }

    if (defined ($ref_vers)) {
	if (defined $subpkg) {
	    my $subpkg_version = $subpkg->get_tag ("version");
	    my $subpkg_release = $subpkg->get_tag ("release");
	    my $subpkg_serial = $subpkg->get_tag ("serial");
	    my $subpkg_rev = $subpkg->get_tag ("rev");

	    if (compare_version ($ref_vers, $ref_rev, $ref_serial,
				 $rel_op, 
				 $subpkg_version, $subpkg_rev, 
				 $subpkg_serial)) {
		return 1;
	    }
	}

	my $version_list_ref = get_versions_installed ($pkg);
	if (not @$version_list_ref) {
	    return 0;
	}

	if ($rel_op =~ /S$/) {
#FIXME	    
	}
	foreach $vers_ref (@$version_list_ref) {
	    my ($version, $rev, $serial) = @$vers_ref;
	    if (compare_version ($ref_vers, $ref_rev, $ref_serial,
				 $rel_op, 
				 $version, $rev, $serial)) {
		return 1;
	    }
	}
	return 0;
    }

    return 1;
}

sub check_build_requires ($) {
    my $spec = shift;

    my @packages = $spec->get_packages ();

    foreach my $pkg (@packages) {
	my @reqss = $pkg->get_array ("buildrequires");
	foreach my $reqstr (@reqss) {
	    next if not defined $reqstr;
	    my @reqs = split /\s*,\s*/, $reqstr;
	    foreach my $req (@reqs) {
		check_dep ($spec, $req) or
		    message ("error: $req is required to build " .
			     $spec), return 0;
	    }
	}
	@reqss = $pkg->get_array ("requires");
	foreach my $reqstr (@reqss) {
	    next if not defined $reqstr;
	    my @reqs = split /\s*,\s*/, $reqstr;
	    foreach my $req (@reqs) {
		check_dep ($spec, $req) or
		    message ("error: $req is required to build " .
			     $spec), return 0;
	    }
	}
	@reqss = $pkg->get_array ("prereq");
	foreach my $reqstr (@reqss) {
	    next if not defined $reqstr;
	    my @reqs = split /\s*,\s*/, $reqstr;
	    foreach my $req (@reqs) {
		check_dep ($spec, $req) or
		    message ("error: $req is required to build " .
			     $spec), return 0;
	    }
	}
    }

    return 1;
}

sub get_script_header ($) {
    my $spec = shift;

    my $script = "#!/bin/bash\n\n" .
	"set -e\n\n" .
	$spec->eval ("RPM_SOURCE_DIR=\"%{_sourcedir}\"") . "\n" .
	$spec->eval ("RPM_BUILD_DIR=\"%{_builddir}\"") . "\n" .
	$spec->eval ("RPM_OPT_FLAGS=\"%{optflags}\"") . "\n" .
	"RPM_ARCH=\"$arch\"\n" .
	"RPM_OS=\"$os\"\n" .
	"RPM_OS_REL=\"$os_rel\"\n" .
	"export RPM_SOURCE_DIR RPM_BUILD_DIR RPM_OPT_FLAGS RPM_ARCH RPM_OS\n" .
	"RPM_DOC_DIR=\"/usr/share/doc/packages/" . $spec . "\"\n" .
        "export RPM_DOC_DIR\n" .
	"RPM_PACKAGE_NAME=\"" . $spec . "\"\n" .
	"RPM_PACKAGE_VERSION=\"" . $spec->eval ('%version') . "\"\n" .
	"RPM_PACKAGE_RELEASE=\"" . $spec->eval ('%release') . "\"\n" .
	"export RPM_PACKAGE_NAME RPM_PACKAGE_VERSION RPM_PACKAGE_RELEASE\n" .
	$spec->eval ("RPM_BUILD_ROOT=\"%buildroot\"") . "\n" .
	"export RPM_BUILD_ROOT\n\n" .
	"set -x\n" .
	"umask 022\n" .
	"uname -a\n\n";

    return $script;
}

my $file_id = 0;
sub open_tempfile ($) {
    my $spec = shift;

    my $tempdir = $spec->eval('%{_tmppath}');
    if (not defined $tempdir) {
	$tempdir = "/tmp";
    }
    my $the_file_id = ++$file_id;
    my $fhandle = "TEMP_FILE" . $the_file_id;
    my $fname = "pkgbuild-tmp-$the_file_id.$$";
    open $fhandle, ">$tempdir/$fname" or
	fatal ("failed to create temporary file $tempdir/$fname");
    return ($fhandle, "$tempdir/$fname");
}

sub do_block ($$) {
    my $spec = shift;
    my $block_name = shift;

    my $fhandle;
    my $script_name;
    ($fhandle, $script_name) = open_tempfile ($spec);
    my $script = get_script_header ($spec);

    print $fhandle "$script";
    $script = $spec->get_block ($block_name);
    print $fhandle $spec->eval ("cd %{_builddir}\n\n");
    print $fhandle "$script\n" if $script;
    print $fhandle "exit 0\n";

    close $fhandle;
    my $retval;

    system ("/bin/bash $script_name");
    $retval = $?;
    unlink $script_name;

    return (not $retval);
}

sub make_pkginfo ($$) {
    my $spec = shift;
    my $package = shift;

    my $fhandle = "pkginfo" . ++$file_id;

    my $pkginfodir = $spec->eval ("%_topdir") . "/PKGMAPS/pkginfo";
    my $fname = $package . ".pkginfo";
    open $fhandle, ">$pkginfodir/$fname" or
	fatal ("failed to create file $pkginfodir/$fname");

    my $pkgname = $package->get_tag ('SUNW_Pkg');
    $pkgname = "$package" unless $pkgname;
    print $fhandle "PKG=" . $pkgname . "\n";
    print $fhandle "NAME=" . $package->get_tag ('summary') . "\n";
    print $fhandle "DESC=" . $package->get_tag ('summary') . "\n";
    print $fhandle "ARCH=$arch\n";

    my $prodname = $package->get_tag ('SUNW_ProdName');
    print $fhandle "SUNW_PRODNAME=$prodname\n" if $prodname;

    my $prodvers = $package->get_tag ('SUNW_ProdVers');
    print $fhandle "SUNW_PRODVERS=$prodvers\n" if $prodvers;

    my $basedir = $package->get_tag ('SUNW_BaseDir');
    if (not defined ($basedir)) {
	$basedir = "/";
    }

    if ($basedir eq "/usr") {
	print $fhandle "SUNW_PKGTYPE=usr\n";
    } elsif ($basedir eq "/") {
	print $fhandle "SUNW_PKGTYPE=root\n";
    }

    my $pkgvers = $package->get_tag ('SUNW_PkgVers');
    $pkgvers = "1.0" unless $pkgvers;
    print $fhandle "SUNW_PKGVERS=$pkgvers\n";

    my $category = $package->get_tag ('SUNW_Category');
    if (not defined ($category)) {
	$category = "application";
    }
    print $fhandle "CATEGORY=$category\n";

    my $vendor = $package->get_tag ('Vendor');
    print $fhandle "VENDOR=$vendor\n" if $vendor;

    my $hotline = $package->get_tag ('SUNW_HotLine');
    print $fhandle "HOTLINE=$hotline\n" if $hotline;

    print $fhandle "EMAIL=\n";

    my $maxinst = $package->get_tag ('SUNW_MaxInst');
    print $fhandle "MAXINST=$maxinst\n" if $maxinst;

    my $version = $package->get_tag ('Version');
    my $rev = $package->get_tag ('SUNW_Rev');
    if (not defined $rev) {
	$rev = `date +%Y.%m.%d.%H.%M`;
    } else {
	$rev = "$rev." . `date +%Y.%m.%d.%H.%M`;
    }
    chomp ($rev);
    print $fhandle "VERSION=$version,REV=$rev\n";
    
    print $fhandle "BASEDIR=$basedir\n";

    print $fhandle "CLASSES=none\n";

    close $fhandle;
    return "i pkginfo=$pkginfodir/$fname\n";
}

sub make_depend ($$) {
    my $spec = shift;
    my $package = shift;

    my @deps = $package->get_array ("requires");
# FIXME: merge with prereq
    if (not @deps) {
	return "";
    }

    my $fhandle = "pkginfo" . ++$file_id;

    my $pkgdependdir = $spec->eval ("%_topdir") . "/PKGMAPS/depend";
    my $fname = $package . ".depend";
    open $fhandle, ">$pkgdependdir/$fname" or
	fatal ("failed to create file $pkgdependdir/$fname");

    foreach my $dep (@deps) {
	if (not defined ($dep)) {
	    next;
	}
	my $subpkg = $spec->find_package_by_name ($dep);
	if (defined ($subpkg)) {
	    print $fhandle "P $dep " . $subpkg->get_tag ("summary") . "\n";
	    next;
	}
	my $pkgname = `/usr/bin/pkginfo '$dep.*' 2>/dev/null | head -1`;
	$pkgname =~ s/^\S*\s*$dep\s*(\S.*)$/$1/;
	if ($? != 0) {
	    message ("warning: could not find out the description of "
		     . "package $dep", "omitting from depend file");
	    next;
	}
	chomp ($pkgname);
	print $fhandle "P $dep $pkgname\n"; 
    }

    close $fhandle;
    return "i depend=$pkgdependdir/$fname\n";
}

sub make_scripts ($$) {
    my $spec = shift;
    my $package = shift;

    my $retstr = "";
    my $scriptdir = $spec->eval ("%_topdir") . "/PKGMAPS/scripts";

    my $pre = $package->get_block ("pre");
    if (defined ($pre)) {
	my $fhandle = "script" . ++$file_id;
	my $fname = $package . ".preinstall";
	open $fhandle, ">$scriptdir/$fname" or
	    fatal ("failed to create file $scriptdir/$fname");
	print $fhandle "#!/bin/sh\n\n";
	print $fhandle "$pre\n";
	close $fhandle;
	$retstr = $retstr . "i preinstall=$scriptdir/$fname\n";
    }

    my $post = $package->get_block ("post");
    if (defined ($post)) {
	my $fhandle = "script" . ++$file_id;
	my $fname = $package . ".postinstall";
	open $fhandle, ">$scriptdir/$fname" or
	    fatal ("failed to create file $scriptdir/$fname");
	print $fhandle "#!/bin/sh\n\n";
	print $fhandle "$post\n";
	close $fhandle;
	$retstr = $retstr . "i postinstall=$scriptdir/$fname\n";
    }

    my $preun = $package->get_block ("preun");
    if (defined ($post)) {
	my $fhandle = "script" . ++$file_id;
	my $fname = $package . ".preremove";
	open $fhandle, ">$scriptdir/$fname" or
	    fatal ("failed to create file $scriptdir/$fname");
	print $fhandle "#!/bin/sh\n\n";
	print $fhandle "$preun\n";
	$retstr = $retstr . "i preremove=$scriptdir/$fname\n";
    }

    my $postun = $package->get_block ("postun");
    if (defined ($postun)) {
	my $fhandle = "script" . ++$file_id;
	my $fname = $package . ".postremove";
	open $fhandle, ">$scriptdir/$fname" or
	    fatal ("failed to create file $scriptdir/$fname");
	print $fhandle "#!/bin/sh\n\n";
	print $fhandle "$postun\n";
	$retstr = $retstr . "i postremove=$scriptdir/$fname\n";
    }

    return $retstr;
}

sub get_file_mode ($) {
    my $fname = shift;

    $mode = (stat($fname))[2];
    if (not defined ($mode)) {
        print "WARNING: could not stat() $fname\n";
	return "0644";
    }
    return sprintf("%04o", $mode & 07777);
}

sub get_file_type ($) {
    my $fname = shift;

    if (-d $fname) {
	return "d";
    } elsif (-l $fname) {
	return "s";
    } elsif (-p $fname) {
	return "p";
    } elsif (-b $fname) {
	return "b";
    } elsif (-c $fname) {
	return "c";
    } elsif (-f $fname) {
	return "f";
    } else {
	return "-";
    }
}

sub get_proto_line ($$$$$) {
    my $fname = shift;
    my $basedir = shift;
    my $def_mode = shift;
    my $def_user = shift;
    my $def_grp = shift;

    my $mode = $def_mode;
    my $user = $def_user;
    my $group = $def_grp;

    my $type = get_file_type ($fname);
    if ($type eq "-") {
	return undef;
    }

    $basedir = "$basedir/";
    $basedir =~ s/\/\/*/\//g;
    $basedir = substr ("$basedir", 1);

    if (index ($fname, $basedir) != 0) {
	fatal ("file $fname is not under basedir $basedir");
    }

    my $relpath = substr ($fname, length ($basedir));
    my $protoline;

    if ($def_mode eq "-" and $type ne 's') {
	$mode = get_file_mode ($fname);
    }
    if ($def_user eq "-") {
	$user = getpwuid ((stat($fname))[4]);
    }
    if ($def_grp eq "-") {
	$group = getgrgid ((stat($fname))[5]);
    }

    if ($type eq 'f') {
	$protoline = "$type none $relpath=$basedir$relpath $mode $user $group";
    } elsif ($type eq 'd') {
	$protoline = "$type none $relpath $mode $user $group";
    } elsif ($type eq 's') {
	my $linkpoint = readlink ($fname);
	$protoline = "$type none $relpath=$linkpoint";
    } elsif ($type =~ /(c|b)/) {
	fatal ('devices special files not implemented');
    }

    return $protoline;
}

sub list_all_files ($) {
    my $dirname = shift;

    my $find_output = `find $dirname -print | grep -v "^$dirname\$"`;
    my @file_list = split /\n/, $find_output;

    return @file_list;
}

sub get_proto_hash ($) {
    my $package = shift;

    my $has_errors = 0;

    my @files = $package->get_files ();
    my $error = $package->get_error ();
    if (defined ($error)) {
	print "ERROR: $error\n";
	return undef;
    }
    if (not @files) {
        my %empty_hash;
	return \%empty_hash;
    }

    my %file_info = ();

    my $cwd = `pwd`;
    chomp ($cwd);
    my $buildroot = $package->eval ("%buildroot");
    my $basedir = $package->get_tag ("sunw_basedir");
    if (not defined ($basedir) or ($basedir eq "")) {
	$basedir = "/";
    }

    chdir ($buildroot);

    foreach my $file (@files) {
	next if not $file;
	my $fn = "$file";
	$fn =~ s/^\/+//;
	my @file_list = glob ($fn);
	if (not @file_list) {
	    message ("File not found by glob: $buildroot$file");
	    $has_errors = 1;
	}
	my @attribs = $file->get_attributes ();
	my @rec_list = ();
	foreach my $fname (@file_list) {
	    if (-d $fname) {
		if ($file->is_recursive()) {
		    my @files_in_dir = list_all_files ($fname);
		    @rec_list = (@rec_list, @files_in_dir);
		}
	    }
	}
	@file_list = (@file_list, @rec_list);
	foreach my $fname (@file_list) {
	    if (defined ($file_info{$fname}) and not -d $fname) {
		message ("File listed twice: $fname");
		$has_errors = 1;
	    }
	    if (not defined ($file_info{$fname})) {
		my $pline = get_proto_line ($fname, 
					    $basedir,
					    $attribs[0],
					    $attribs[1],
					    $attribs[2]);
		if (not defined ($pline)) {
		    message ("File not found by glob: $buildroot/$fname");
		    $has_errors = 1;
		}
		$file_info{$fname} = $pline;
		if (defined ($all_files{$fname})) {
		    print "WARNING: $fname is included in both $package and $all_files{$fname}\n";
		}
	    }
	}
    }

    chdir ($cwd);

    if ($has_errors == 1) {
	return undef;
    } else {
	return \%file_info;
    }
}

my %all_files;

sub make_solaris_pkg ($$) {
    my $spec = shift;
    my $package = shift;

    my $pkginfo_proto = make_pkginfo ($spec, $package);
    my $dep_proto = make_depend ($spec, $package);
    my $scr_proto = make_scripts ($spec, $package);

    my $files_ref = get_proto_hash ($package);
    if (not defined ($files_ref)) {
	exit (1);
    }
    my %files = %$files_ref;
    foreach my $file (keys %files) {
	$all_files{$file} = "$package";
    }
    if (not %files) {
	print "WARNING: empty package: $package\n";
    }

    my $fhandle = "proto" . ++$file_id;

    my $protodir = $spec->eval ("%_topdir") . "/PKGMAPS/proto";
    my $fname = $package . ".proto";
    open $fhandle, ">$protodir/$fname" or
	fatal ("failed to create file $protodir/$fname");

    print $fhandle $pkginfo_proto;
    print $fhandle $dep_proto;
    print $fhandle $scr_proto;
    foreach my $fname (keys %files) {
	next if not $fname;
	print $fhandle $files{$fname};
	print $fhandle "\n";
    }
    close ($fhandle);

    my $pkgdir = $spec->eval ("%_topdir") . "/PKGS";
    my $buildroot = $package->eval ("%buildroot");
    system ("/usr/bin/pkgmk -o -r $buildroot -d $pkgdir -f $protodir/$fname");

    return (not $?);
}

sub make_packages ($) {
    my $spec = shift;

    if ($os ne 'solaris') {
#	return 1;
    }

    my @packages = $spec->get_packages ();

    foreach my $pkg (@packages) {
	make_solaris_pkg ($spec, $pkg) or return 0;
    }

    my $buildroot = $spec->eval ("%buildroot");
    my $old_cwd = `pwd`;
    chdir ($buildroot);
    my @all_fnames = list_all_files (".");
    my $unpackaged = 0;
    foreach my $fname (@all_fnames) {
	$fname = substr ($fname, 2);
	if (not defined ($all_files{$fname})) {
	    if (not $unpackaged) {
		$unpackaged = 1;
		print "WARNING: the following files are not included in any packages:\n"
	    }
	    print "        /$fname\n";
	}
    }
    chdir ($old_cwd);
    
    return 1;
}

sub main () {
    process_options ();
    init ();

    if (not @spec_names) {
	if (not defined $build_command and $version_printed) {
	    exit (0);
	}
	fatal ("no spec files given for build");
    }

    if (not defined $build_command) {
	usage ();
    }

    foreach my $spec_name (@spec_names) {
	my $spec = new rpm_spec ($spec_name, \@predefines);
	if (not defined $spec) {
	    fatal ("File is not a regular file: $spec_name");
	}
	my $name = $spec->get_value_of ("name");
	if (not defined($name)) {
	    if (defined ($spec->{error})) {
		fatal ($spec->{error});
	    } else {
		fatal ("The Name tag is not defined in " .
		       $spec->get_file_name());
	    }
	}
	if ($check_deps) {
	    check_build_requires ($spec) or exit (1);
	}
	if ($build_command =~ /p/) {
	    do_block ($spec, 'prep') or exit (1);
	}
	if ($build_command =~ /c/) {
	    do_block ($spec, 'build') or exit (1);
	}
	if ($build_command =~ /i/) {
	    do_block ($spec, 'install') or exit (1);
	}
	if ($build_command =~ /[ba]/) {
	    make_packages ($spec) or exit (1);
	    do_block ($spec, 'clean') or exit (1);
	}
    }
}

main();
