#!@PERL@

@WARNING_MESSAGE_L1@
@WARNING_MESSAGE_L2@
@WARNING_MESSAGE_L3@
@WARNING_MESSAGE_L4@
@WARNING_MESSAGE_L5@
@WARNING_MESSAGE_L6@
@WARNING_MESSAGE_L7@

#use strict;
use warnings;
use Getopt::Long qw(:config gnu_compat no_auto_abbrev bundling);
use rpm_spec;

my $myname = "pkgbuild";
my $myversion = "@PKGBUILD_VERSION@";
my $version_printed = 0;
my $debug_level = 0;
my $verbose = 1;
my $build_command;
my $build_skip = 0;
my $interactive_mode = 0;
my $check_deps = 1;

my $mydir;
my @spec_names = ();

my $arch;
my $os;
my $os_rel;

sub init () {
    $arch = `uname -p`;
    chomp ($arch);
    if ($arch eq "unknown") {
	$arch = `uname -m`;
	chomp ($arch);
	if ($arch eq 'i585') {
	    $arch = 'i386';
	} elsif ($arch eq 'i686') {
	    $arch = 'i386';
	}
    }

    $os = `uname -s`;
    chomp ($os);
    $os = lc($os);
    $os_rel = `uname -r`;
    chomp ($os_rel);
    if ($os eq 'sunos') {
	if ($os_rel >= 5) {
	    $os = 'solaris';
	}
    }
}

my @predefines = ();

sub add_define ($$) {
    shift;
    my $def = shift;

    push (@predefines, $def);
}

my %build_phases = ('p', 'p', 
		    'c', 'pc',
		    'i', 'pci',
		    'b', 'pcib',
		    'a', 'pciba',
		    's', 'pcis');

sub short_circuit_option {
    if (defined ($build_command)) {
	$build_command = substr($build_command, length($build_command)-1);
    } else {
	%build_phases = ('p', 'p',
			 'c', 'c',
			 'i', 'i',
			 'b', 'b',
			 's', 's',
			 'a', 'a');
    }
}

sub set_build_command ($$) {
    shift;
    my $key = shift;

    if (defined $build_command) {
	fatal ("only one major mode may be specified");
    }
    if ($key =~ /^[abicps]$/) {
	$build_command = $build_phases{$key};
    } elsif ($key eq 'l') {
	fatal ("-bl not implemented");
    } else {
	fatal ("--build (-b) requires one of a,b,i,c,p,l,s as its sole argument");
    }
}

sub set_rebuild ($) {
    shift;
    my $pkg = shift;

    if (defined $build_command) {
	fatal ("only one major mode may be specified");
    }
    if (not $pkg =~ /^\//) {
	$pkg = "$mydir/$pkg";
    }
    $build_command = $build_phases{'b'};
    my $main_spec = `grep '^1 s none .*/\.\.main\.spec=' $pkg/pkgmap 2>&1`;
    if ($? == 0) {
	chomp ($main_spec);
	$main_spec =~ s/^1 s none (.*\/)\.\.main\.spec=(.*)/$1$2/;
	$main_spec = "$pkg/reloc/$main_spec";
	my $src_topdir = $main_spec;
	$src_topdir =~ s/\/SPECS\/[^\/]*\.spec$//;
	add_define (0, "_sourcedir $src_topdir/SOURCES");
	add_define (0, "_specdir $src_topdir/SPECS");
	@spec_names = ($main_spec);
	return 1;
    }

    if (-l "$pkg/SPECS/..main.spec") {
	add_define (0, "_sourcedir $pkg/SOURCES");
	add_define (0, "_specdir $pkg/SPECS");
	$main_spec = readlink ("$pkg/SPECS/..main.spec");
	$main_spec = "$pkg/SPECS/$main_spec";
	@spec_names = ($main_spec);
	return 1;
    }

    fatal ("$pkg is not a source package");
}

sub process_options {
    GetOptions ('debug=n'   => \$debug_level,
		'help'      => \&usage,
		'version'   => \&print_version,
		'b=s'       => \&set_build_command,
		'v+'        => \$verbose,
		'define=s'  => \&add_define,
		'deps!'     => \$check_deps,
		'interactive!' => \$interactive_mode,
		'bp'        => sub { set_build_command (0, 'p'); },
		'bl'        => sub { fatal ("-bl not implemented\n") },
		'bc'        => sub { set_build_command (0, 'c'); },
		'bi'        => sub { set_build_command (0, 'i'); },
		'bb'        => sub { set_build_command (0, 'b'); },
		'ba'        => sub { set_build_command (0, 'a'); },
		'bs'        => sub { set_build_command (0, 's'); },
		'rebuild=s' => \&set_rebuild,
		'short-circuit' => \&short_circuit_option, 
		'build=s'   => \$build_command,
		'rcfile=s'  => sub { print "--rcfile option not implemented\n" },
		'<>' => \&process_args);
}

sub process_args () {
    my $arg = shift;

    if ($arg =~ /^-/) {
	print ("Unknown option: $arg\n");
	exit 1;
    }

    if (not defined $mydir) {
	$mydir = $arg;
	chdir ($arg);
    } else {
	push (@spec_names, $arg);
    }
}

sub print_version () {
    $version_printed = 1;
    print "$myname version $myversion\n";
}

sub usage () {
    print_version();
    print <<_EOF_;
Copyright (C) 2003 - Sun Microsystems, Inc.
This may be freely redistributed under the terms of the GNU GPL

* = the option is implemented 

 Usage:
*  --help                  - print this message
*  --version               - print the version of rpm being used
*  --interactive           - start a shell in the build directory if fails
                             and allow to continue after the shell terminates
   all modes support the following arguments:
      --rcfile <file>      - use <file> instead of /etc/rpmrc and \$HOME/.rpmrc
     -v                    - be a little more verbose
     -vv                   - be incredibly verbose (for debugging)
*   -b<stage> <spec>
    -t<stage> <tarball>    - build package, where <stage> is one of:
*         p                - prep (unpack sources and apply patches)
          l                - list check (do some cursory checks on %files)
*         c                - compile (prep and compile)
*         i                - install (prep, compile, install)
*         b                - binary package (prep, compile, install, package)
*         a                - bin/src package (prep, compile, install, package)
*     --short-circuit      - skip straight to specified stage (only for c,i)
      --clean              - remove build tree when done
      --rmsource           - remove sources and spec file when done
      --sign               - generate PGP/GPG signature
      --buildroot <dir>    - use <dir> as the build root
      --target=<platform>+ - build the packages for the build targets
                             platform1...platformN.
      --nobuild            - do not execute any stages
      --timecheck <secs>   - set the time check to <secs> seconds (0 disables)
*     --define "<name> <value>"
                           - define <name> as <value> as if you had
			     "%define <name> <value>" in the spec file 
 
*   --rebuild <src_pkg>    - install source package, build binary package and
                             remove spec file, sources, patches, and icons.
    --rmsource <spec>      - remove sources and spec file
    --recompile <src_pkg>  - like --rebuild, but don't build any package
_EOF_
# '
    exit(1);
}

sub message (@) {
    my @messages = @_;

    foreach my $msg (@messages) {
	print "$myname: $msg\n";
    }
}

sub fatal (@) {
    message (@_);
    exit 1;
}

sub get_versions_installed ($) {
    my $pkg = shift;

    my @retlist = ();
    if ($os eq "linux") {
	my $pkglist=`rpm -q --queryformat '%{VERSION}\t%{RELEASE}\t%{SERIAL}\n' $pkg 2>/dev/null`;
	if ($? != 0) {
	    return \@retlist;
	}
	my @pkginfos=split /\n/, $pkglist;
	foreach my $pkginfo (@pkginfos) {
	    next if not defined ($pkginfo);
	    if ($pkginfo =~ /^([^\t]*)\t([^\t]*)\t([^\t]*)$/) {
		push (@retlist, ($1, $2, $3));
	    } else {
		print "WARNING: couldn't parse version number of $pkg\n";
	    }
	}
	return \@retlist;
    } elsif ($os eq "solaris") {
	my $pkglist=`/usr/bin/pkginfo -l '$pkg.*' 2>&1 | grep VERSION: | cut -f2- -d:`;
	if ($? != 0) {
	    return \@retlist;
	}
	my @pkginfos=split /\n/, $pkglist;
	foreach my $pkginfo (@pkginfos) {
	    next if not defined ($pkginfo);
	    if ($pkginfo =~ /^\s*(.*),REV=(.*)\s*$/) {
		push (@retlist, ($1, $2, undef));
	    } else {
		$pkginfo =~ s/\s*//;
		push (@retlist, ($pkginfo, undef, undef));
	    }
	}
	return \@retlist;
    } else {
	return \@retlist;
    }   
}

sub compare_version ($$$$$$$) {
    my $vers1 = shift;
    my $rev1 = shift;
    my $serial1 = shift;
    my $op = shift;
    my $vers2 = shift;
    my $rev2 = shift;
    my $serial2 = shift;

    return 1;

# FIXME: this is unfinished!
    if ($op =~ /S$/) {
	if (not defined ($serial1) or not defined ($serial2)) {
	    return 0;
	}
	my $comp_res = compare_version_string ($serial1, $serial2);
	if ($op eq "=S") {
	    if ($serial1 = $serial2) {
		return 1;
	    }
	} elsif ($op eq "<=S" or $op eq "=<S") {
	} elsif ($op eq ">=S" or $op eq "=>S") {
	}
    } else {
	if (not defined ($version1) or not defined ($version2)) {
	    return 0;
	}
	my $version_comp_res = compare_version_string ($serial1, $serial2);
	my $rev_comp_res;
	if ($version_comp_res == 0) {
	    if (not defined ($version1) or not defined ($version2)) {
		return 0;
	    }
	    my $version_comp_res = compare_version_string ($serial1, $serial2);
	}
	if ($op eq "=") {
	} elsif ($op eq "<=" or $op eq "=<") {
	} elsif ($op eq ">=" or $op eq "=>") {
	}
    }
}

sub check_dep ($$) {
    my $spec = shift;
    my $dep = shift;

    if (not defined ($dep)) {
	return 1;
    }

    my $pkg = $dep;
    $pkg =~ s/\s+.*$//;
    if (not defined ($pkg)) {
	print "empty dependency: $dep\n";
	return 0;
    }
    my $ref_vers;
    my $ref_rev;
    my $ref_serial;
    my $rel_op;
    if ($dep =~ /^$pkg\s*(=|<=|=<|>=|=>)\s*(\S*),REV=(\S*)\s*$/) {
	if ($os eq "solaris") {
	    $rel_op = $1;
	    $ref_vers = $2;
	    $ref_rev = $3;
	} else {
	    $rel_op = $1;
	    $ref_vers = "$2,REV=$3";
	    if ($ref_vers =~ /^([^-]*)-([^-]*)$/) {
		$ref_vers = $1;
		$ref_rev = $2;
	    }
	}
    } elsif ($dep =~ /^$pkg\s*(=|<=|=<|>=|=>)\s*(\S*)\s*$/) {
	$rel_op = $1;
	$ref_vers = $2;
	if ($os eq "linux") {
	    if ($ref_vers =~ /^([^-]*)-([^-]*)$/) {
		$ref_vers = $1;
		$ref_rev = $2;
	    }
	}
    } elsif ($dep =~ /^$pkg\s*(=S|<=S|=<S|>=S|=>S)\s*(\S*)\s*$/) {
	$rel_op = $1;
	$ref_serial = $2;
	if ($os eq "solaris") {
	    print "WARNING: \"Serial\" dependency tests not " .
		"implemented on Solaris\n";
	    print "WARNING: ignoring dependency \"$dep\"\n";
	    return 1;
	}
    } elsif ($dep =~ /^$pkg\s*$/) {
	# no version to compare to, check existance of pkg only
    } else {
	print "WARNING: could not parse dependency: $dep\n";
	return 0;
    }

    my $subpkg = $spec->find_package_by_name ($pkg);
    if (not defined $subpkg) {
	if ($os eq "linux") {
	    `rpm -q $pkg`;
	    if ($? != 0) {
		`rpm -q --provides $pkg`;
		if ($? != 0) {
		    return 0;
		}
	    }
	} elsif ($os eq "solaris") {
	    `/usr/bin/pkginfo -q '$pkg.*'`;
	    if ($? != 0) {
		return 0;
	    }
	} else {
	    print "WARNING: I don't know how to verify dependency $pkg ".
		"on this OS.\n";
	    return 1;
	}
    }

    if (defined ($ref_vers)) {
	if (defined $subpkg) {
	    my $subpkg_version = $subpkg->get_tag ("version");
	    my $subpkg_release = $subpkg->get_tag ("release");
	    my $subpkg_serial = $subpkg->get_tag ("serial");
	    my $subpkg_rev = $subpkg->get_tag ("rev");

	    if (compare_version ($ref_vers, $ref_rev, $ref_serial,
				 $rel_op, 
				 $subpkg_version, $subpkg_rev, 
				 $subpkg_serial)) {
		return 1;
	    }
	}

	my $version_list_ref = get_versions_installed ($pkg);
	if (not @$version_list_ref) {
	    return 0;
	}

	if ($rel_op =~ /S$/) {
#FIXME	    
	}
	foreach $vers_ref (@$version_list_ref) {
	    my ($version, $rev, $serial) = @$vers_ref;
	    if (compare_version ($ref_vers, $ref_rev, $ref_serial,
				 $rel_op, 
				 $version, $rev, $serial)) {
		return 1;
	    }
	}
	return 0;
    }

    return 1;
}

sub check_build_requires ($) {
    my $spec = shift;

    my @packages = $spec->get_packages ();

    foreach my $pkg (@packages) {
	my @reqss = $pkg->get_array ("buildrequires");
	foreach my $reqstr (@reqss) {
	    next if not defined $reqstr;
	    my @reqs = split /\s*,\s*/, $reqstr;
	    foreach my $req (@reqs) {
		check_dep ($spec, $req) or
		    message ("error: $req is required to build " .
			     $spec), return 0;
	    }
	}
	@reqss = $pkg->get_array ("buildconflicts");
	foreach my $reqstr (@reqss) {
	    next if not defined $reqstr;
	    my @reqs = split /\s*,\s*/, $reqstr;
	    foreach my $req (@reqs) {
		check_dep ($spec, $req) and
		    message ("error: $req conflicts with " .
			     $spec), return 0;
	    }
	}
	@reqss = $pkg->get_array ("conflicts");
	foreach my $reqstr (@reqss) {
	    next if not defined $reqstr;
	    my @reqs = split /\s*,\s*/, $reqstr;
	    foreach my $req (@reqs) {
		check_dep ($spec, $req) and
		    message ("error: $req conflicts with " .
			     $spec), return 0;
	    }
	}
	@reqss = $pkg->get_array ("prereq");
	foreach my $reqstr (@reqss) {
	    next if not defined $reqstr;
	    my @reqs = split /\s*,\s*/, $reqstr;
	    foreach my $req (@reqs) {
		check_dep ($spec, $req) or
		    message ("error: $req is required to build " .
			     $spec), return 0;
	    }
	}
    }

    return 1;
}

sub get_script_header ($) {
    my $spec = shift;

    my $error_handler = "";
    if ($interactive_mode) {
	$error_handler = "pkgbuild_start_shell () {\n" .
	    "  set +x\n" .
	    "  export PS1='pkgbuild@\\H> '\n" .
	    "  echo '*** Command failed; entering interactive mode'\n" .
	    "  echo '*** starting shell'\n" .
	    "  echo '*** when finished'\n" .
	    "  echo '***     type   exit      to continue'\n" .
	    "  echo '***     type   exit 1    to abort'\n" .
	    "\n" .
	    "  /bin/bash -i +o monitor || exit 1\n" .
	    "\n" .
	    "  set -x\n" .
	    "}\n" .
	    "\n" .
	    "trap pkgbuild_start_shell ERR\n" .
	    "\n";
    } else {
	$error_handler = "set -e\n\n";
    }
    my $script = "#!/bin/bash\n\n" .
	$error_handler .
	$spec->eval ("RPM_SOURCE_DIR=\"%{_sourcedir}\"") . "\n" .
	$spec->eval ("RPM_BUILD_DIR=\"%{_builddir}\"") . "\n" .
	$spec->eval ("RPM_OPT_FLAGS=\"%{optflags}\"") . "\n" .
	"RPM_ARCH=\"$arch\"\n" .
	"RPM_OS=\"$os\"\n" .
	"RPM_OS_REL=\"$os_rel\"\n" .
	"export RPM_SOURCE_DIR RPM_BUILD_DIR RPM_OPT_FLAGS RPM_ARCH RPM_OS\n" .
	"RPM_DOC_DIR=\"/usr/share/doc/packages/" . $spec . "\"\n" .
        "export RPM_DOC_DIR\n" .
	"RPM_PACKAGE_NAME=\"" . $spec . "\"\n" .
	"RPM_PACKAGE_VERSION=\"" . $spec->eval ('%version') . "\"\n" .
	"RPM_PACKAGE_RELEASE=\"" . $spec->eval ('%release') . "\"\n" .
	"export RPM_PACKAGE_NAME RPM_PACKAGE_VERSION RPM_PACKAGE_RELEASE\n" .
	$spec->eval ("RPM_BUILD_ROOT=\"%buildroot\"") . "\n" .
	"export RPM_BUILD_ROOT\n\n" .
	"set -x\n" .
	"umask 022\n" .
	"uname -a\n\n";

    return $script;
}

my $file_id = 0;
sub open_tempfile ($) {
    my $spec = shift;

    my $tempdir = $spec->eval('%{_tmppath}');
    if (not defined $tempdir) {
	$tempdir = "/tmp";
    }
    my $the_file_id = ++$file_id;
    my $fhandle = "TEMP_FILE" . $the_file_id;
    my $fname = "pkgbuild-tmp-$the_file_id.$$";
    open $fhandle, ">$tempdir/$fname" or
	fatal ("failed to create temporary file $tempdir/$fname");
    return ($fhandle, "$tempdir/$fname");
}

sub do_block ($$) {
    my $spec = shift;
    my $block_name = shift;

    my $script = $spec->get_block ($block_name);
    if (not defined ($script)) {
	return 1;
    }
    my $fhandle;
    my $script_name;
    ($fhandle, $script_name) = open_tempfile ($spec);
    my $script_hdr = get_script_header ($spec);

    print $fhandle "$script_hdr";
    print $fhandle $spec->eval ("cd %{_builddir}\n\n");
    print $fhandle "$script\n" if $script;
    print $fhandle "exit 0\n";

    close $fhandle;
    my $retval;

    print "Executing(%$block_name): /bin/bash $script_name\n";
    if ($block_name eq 'build' or $block_name eq 'install') {
	my $bsdirname = $spec->eval ('%{_build_src_dir_name}');
	if ($bsdirname eq '%{_build_src_dir_name}') {
	    $bsdirname = $spec->eval ('%name-%version');
	}
	my $blddir = $spec->eval ("%{_builddir}");
	`cp $script_name $blddir/$bsdirname/.pkgbuild.$block_name.sh && chmod a+x $blddir/$bsdirname/.pkgbuild.$block_name.sh`;
    }
    system ("/bin/bash $script_name");
    $retval = $?;
    unlink $script_name;
    if ($retval) {
	print "Bad exit status from $script_name (%$block_name)\n";
    }

    return (not $retval);
}

sub make_pkginfo ($$) {
    my $spec = shift;
    my $package = shift;

    my $fhandle = "pkginfo" . ++$file_id;

    my $pkginfodir = $spec->eval ("%_topdir") . "/PKGMAPS/pkginfo";
    my $fname = $package . ".pkginfo";
    open $fhandle, ">$pkginfodir/$fname" or
	fatal ("failed to create file $pkginfodir/$fname");

    my $pkgname = $package->get_tag ('SUNW_Pkg');
    $pkgname = "$package" unless $pkgname;
    print $fhandle "PKG=" . $pkgname . "\n";
    my $summary = $package->get_tag ('summary');
    $summary = $pkgname unless defined ($summary);
    print $fhandle "NAME=$summary\n";
    print $fhandle "DESC=$summary\n";
    print $fhandle "ARCH=$arch\n";

    my $prodname = $package->get_tag ('SUNW_ProdName');
    print $fhandle "SUNW_PRODNAME=$prodname\n" if $prodname;

    my $prodvers = $package->get_tag ('SUNW_ProdVers');
    print $fhandle "SUNW_PRODVERS=$prodvers\n" if $prodvers;

    my $basedir = $package->get_tag ('SUNW_BaseDir');
    if (not defined ($basedir)) {
	$basedir = "/";
    }

    if ($basedir eq "/usr") {
	print $fhandle "SUNW_PKGTYPE=usr\n";
    } elsif ($basedir eq "/") {
	print $fhandle "SUNW_PKGTYPE=root\n";
    }

    my $pkgvers = $package->get_tag ('SUNW_PkgVers');
    $pkgvers = "1.0" unless $pkgvers;
    print $fhandle "SUNW_PKGVERS=$pkgvers\n";

    my $pkglist = $package->get_tag ('SUNW_PkgList');
    if (defined ($pkglist)) {
       print $fhandle "SUNW_PKGLIST=$pkglist\n";
    }

    my $loc = $package->get_tag ('SUNW_Loc');
    if (defined ($loc)) {
       print $fhandle "SUNW_LOC=$loc\n";
    }

    my $category = $package->get_tag ('SUNW_Category');
    if (not defined ($category)) {
	$category = "application";
    }
    print $fhandle "CATEGORY=$category\n";

    my $vendor = $package->get_tag ('Vendor');
    print $fhandle "VENDOR=$vendor\n" if $vendor;

    my $hotline = $package->get_tag ('SUNW_HotLine');
    print $fhandle "HOTLINE=$hotline\n" if $hotline;

    print $fhandle "EMAIL=\n";

    my $maxinst = $package->get_tag ('SUNW_MaxInst');
    print $fhandle "MAXINST=$maxinst\n" if $maxinst;

    my $version = $package->get_tag ('Version');
    my $rev = $package->get_tag ('SUNW_Rev');
    if (not defined $rev) {
	$rev = `date +%Y.%m.%d.%H.%M`;
    } else {
	$rev = "$rev." . `date +%Y.%m.%d.%H.%M`;
    }
    chomp ($rev);
    print $fhandle "VERSION=$version,REV=$rev\n";
    
    print $fhandle "BASEDIR=$basedir\n";

    my @classes = $package->get_classes ();
    print $fhandle "CLASSES=none";
    foreach my $class_name (@classes) {
	next if not defined $class_name;
	next if $class_name eq "none";
	print $fhandle " $class_name"
    }
    print $fhandle "\n";

    close $fhandle;
    return "i pkginfo=$pkginfodir/$fname\n";
}

sub make_copyright ($$;$) {
    my $spec = shift;
    my $package = shift;
    my $pkgname = shift;

    my $cr_file;
    if (defined $package) {
	$cr_file = $package->get_tag ('sunw_copyright');
    } else {
	$cr_file = $spec->get_value_of ('sunw_copyright');
    }
    return undef unless defined $cr_file;

    my $srcdir = $spec->eval ('%_sourcedir');
    if (not -f "$srcdir/$cr_file") {
	message ("warning: copyright file $srcdir/$cr_file not found");
	return undef;
    }

    my $copyrightdir = $spec->eval ("%_topdir") . "/PKGMAPS/copyright";
    if (defined $package) {
	$pkgname = "$package";
    }
    my $out=`cp "$srcdir/$cr_file" "$copyrightdir/${pkgname}.copyright" 2>&1`;

    if ($? != 0) {
	message ("warning: failed to copy copyright file $srcdir/$cr_file: $out");
	return undef;
    }

    return "i copyright=$copyrightdir/${pkgname}.copyright\n";
}

sub make_depend ($$) {
    my $spec = shift;
    my $package = shift;

    my @deps = $package->get_array ("requires");
# FIXME: merge with prereq
    if (not @deps) {
	return "";
    }

    my $fhandle = "pkginfo" . ++$file_id;

    my $pkgdependdir = $spec->eval ("%_topdir") . "/PKGMAPS/depend";
    my $fname = $package . ".depend";
    open $fhandle, ">$pkgdependdir/$fname" or
	fatal ("failed to create file $pkgdependdir/$fname");

    foreach my $dep (@deps) {
	if (not defined ($dep)) {
	    next;
	}
	my $subpkg = $spec->find_package_by_name ($dep);
	if (defined ($subpkg)) {
	    print $fhandle "P $dep " . $subpkg->get_tag ("summary") . "\n";
	    next;
	}
	my $pkgname = `/usr/bin/pkginfo '$dep.*' 2>/dev/null | head -1`;
	$pkgname =~ s/^\S*\s*$dep\s*(\S.*)$/$1/;
	if ($? != 0) {
	    message ("warning: could not find out the description of "
		     . "package $dep", "omitting from depend file");
	    next;
	}
	chomp ($pkgname);
	print $fhandle "P $dep $pkgname\n"; 
    }

    close $fhandle;
    return "i depend=$pkgdependdir/$fname\n";
}

sub make_scripts ($$) {
    my $spec = shift;
    my $package = shift;

    my $retstr = "";
    my $scriptdir = $spec->eval ("%_topdir") . "/PKGMAPS/scripts";

    my $pre = $package->get_block ("pre");
    if (defined ($pre)) {
	my $fhandle = "script" . ++$file_id;
	my $fname = $package . ".preinstall";
	open $fhandle, ">$scriptdir/$fname" or
	    fatal ("failed to create file $scriptdir/$fname");
	print $fhandle "#!/bin/sh\n\n";
	print $fhandle "$pre\n";
	close $fhandle;
	$retstr = $retstr . "i preinstall=$scriptdir/$fname\n";
    }

    my $post = $package->get_block ("post");
    if (defined ($post)) {
	my $fhandle = "script" . ++$file_id;
	my $fname = $package . ".postinstall";
	open $fhandle, ">$scriptdir/$fname" or
	    fatal ("failed to create file $scriptdir/$fname");
	print $fhandle "#!/bin/sh\n\n";
	print $fhandle "$post\n";
	close $fhandle;
	$retstr = $retstr . "i postinstall=$scriptdir/$fname\n";
    }

    my $preun = $package->get_block ("preun");
    if (defined ($preun)) {
	my $fhandle = "script" . ++$file_id;
	my $fname = $package . ".preremove";
	open $fhandle, ">$scriptdir/$fname" or
	    fatal ("failed to create file $scriptdir/$fname");
	print $fhandle "#!/bin/sh\n\n";
	print $fhandle "$preun\n";
	close $fhandle;
	$retstr = $retstr . "i preremove=$scriptdir/$fname\n";
    }

    my $postun = $package->get_block ("postun");
    if (defined ($postun)) {
	my $fhandle = "script" . ++$file_id;
	my $fname = $package . ".postremove";
	open $fhandle, ">$scriptdir/$fname" or
	    fatal ("failed to create file $scriptdir/$fname");
	print $fhandle "#!/bin/sh\n\n";
	print $fhandle "$postun\n";
	close $fhandle;
	$retstr = $retstr . "i postremove=$scriptdir/$fname\n";
    }

    my @classes = $package->get_classes ();
    foreach my $class_name (@classes) {
	next if not defined $class_name;
	next if $class_name eq "none";
	my $script = $package->get_class_script ($class_name, "iclass");
	if (not defined $script) {
	    my $err = $package->get_error ();
	    return undef if defined $err;
	} else {
	    open $fhandle, ">$scriptdir/i.$class_name" or
		fatal ("failed to create file $scriptdir/i.$class_name");
	    print $fhandle "$script";
	    close $fhandle;
	    $retstr = $retstr . "i i.$class_name=$scriptdir/i.$class_name\n";
	}
	$script = $package->get_class_script ($class_name, "rclass");
	if (not defined $script) {
	    my $err = $package->get_error ();
	    return undef if defined $err;
	} else {
	    open $fhandle, ">$scriptdir/r.$class_name" or
		fatal ("failed to create file $scriptdir/r.$class_name");
	    print $fhandle "$script";
	    close $fhandle;
	    $retstr = $retstr . "i r.$class_name=$scriptdir/r.$class_name\n";
	}
    }

    return $retstr;
}

sub get_file_mode ($) {
    my $fname = shift;

    $mode = (stat($fname))[2];
    if (not defined ($mode)) {
        print "WARNING: could not stat() $fname\n";
	return "0644";
    }
    return sprintf("%04o", $mode & 07777);
}

sub get_file_type ($) {
    my $fname = shift;

    if (-l $fname) {
	return "s";
    } elsif (-d $fname) {
	return "d";
    } elsif (-p $fname) {
	return "p";
    } elsif (-b $fname) {
	return "b";
    } elsif (-c $fname) {
	return "c";
    } elsif (-f $fname) {
	return "f";
    } else {
	return "-";
    }
}

sub get_proto_line ($$$$$$$) {
    my $file = shift;
    my $class_name = shift;
    my $fname = shift;
    my $basedir = shift;
    my $def_mode = shift;
    my $def_user = shift;
    my $def_grp = shift;

    my $mode = $def_mode;
    my $user = $def_user;
    my $group = $def_grp;

    my $type = get_file_type ($fname);
    if ($type eq "-") {
	return undef;
    }

    if ($class_name ne "none" and $type eq "f") {
	$type = "e";
    }

    if ($type eq 'f' and defined ($file)) {
	if ($file->is_config ()) {
	    $type = 'v';
	}
    }

    if (index ("/$fname", $basedir) != 0) {
	fatal ("file $fname is not under basedir $basedir");
    }

    $basedir = "$basedir/";
    $basedir =~ s/\/\/*/\//g;
    $basedir = substr ("$basedir", 1);

    my $relpath = substr ($fname, length ($basedir));
    my $protoline;

    if ($def_mode eq "-" and $type ne 's') {
	$mode = get_file_mode ($fname);
    }
    if ($def_user eq "-") {
	$user = getpwuid ((stat($fname))[4]);
    }
    if ($def_grp eq "-") {
	$group = getgrgid ((stat($fname))[5]);
    }

    if ($type eq 'f' or $type eq 'v' or $type eq 'e') {
	$protoline = "$type $class_name $relpath=$basedir$relpath $mode $user $group";
    } elsif ($type eq 'd') {
	$protoline = "$type $class_name $relpath $mode $user $group";
    } elsif ($type eq 's') {
	my $linkpoint = readlink ($fname);
	$protoline = "$type none $relpath=$linkpoint";
    } elsif ($type =~ /(c|b)/) {
	fatal ('device special files not implemented');
    }

    return $protoline;
}

sub list_all_files ($) {
    my $dirname = shift;

    my $find_output = `find $dirname -print | grep -v "^$dirname\$"`;
    my @file_list = split /\n/, $find_output;

    return @file_list;
}

sub get_proto_hash ($) {
    my $package = shift;

    my $has_errors = 0;

    my @files = $package->get_files ();
    my $error = $package->get_error ();
    my @defattr = $package->get_defattr ();
    if (defined ($error)) {
	print "ERROR: $error\n";
	return undef;
    }
    if (not @files) {
        my %empty_hash;
	return \%empty_hash;
    }

    my %file_info = ();
    my %default_dirs = ();

    my $cwd = `pwd`;
    chomp ($cwd);
    my $buildroot = $package->eval ("%buildroot");
    my $basedir = $package->get_tag ("sunw_basedir");
    if (not defined ($basedir) or ($basedir eq "")) {
	$basedir = "/";
    }

    chdir ($buildroot);

    foreach my $file (@files) {
	next if not $file;
	my $fn = "$file";
	$fn =~ s/^\/+//;
	my $class_name = $file->get_class ();
	my @file_list = glob ($fn);
	if (not @file_list) {
	    message ("File not found by glob: $buildroot$file");
	    $has_errors = 1;
	}
	my @attribs = $file->get_attributes ();
	my @rec_list = ();
	foreach my $fname (@file_list) {
	    if (-d $fname) {
		if ($file->is_recursive()) {
		    my @files_in_dir = list_all_files ($fname);
		    @rec_list = (@rec_list, @files_in_dir);
		}
	    }
	}
	@file_list = (@file_list, @rec_list);
	foreach my $fname (@file_list) {
	    if (defined ($file_info{$fname})) {
		message ("File listed twice: $fname");
		$has_errors = 1;
	    }
	    if (not defined ($file_info{$fname})) {
		my $pline = get_proto_line ($file,
					    $class_name,
					    $fname, 
					    $basedir,
					    $attribs[0],
					    $attribs[1],
					    $attribs[2]);
		if (not defined ($pline)) {
		    message ("File not found by glob: $buildroot/$fname");
		    $has_errors = 1;
		}
		$file_info{$fname} = $pline;
		if (defined ($all_files{$fname})) {
		    print "WARNING: $fname is included in both $package and $all_files{$fname}\n";
		}
	    }
	    my $parent_dir = $fname;
	    $parent_dir =~ s/\/[^\/]+$//;
	    while ($parent_dir ne "" and
		   "/$parent_dir" ne "$basedir" and
		   not defined ($file_info{$parent_dir}) and
		   not defined ($default_dirs{$parent_dir})) {
		my $pline = get_proto_line (undef,
					    "none",
					    $parent_dir,
					    $basedir,
					    $defattr[0],
					    $defattr[1],
					    $defattr[2]);
		if (defined ($pline)) {
		    $default_dirs{$parent_dir} = $pline;
		}
		$parent_dir =~ s/\/[^\/]+$//;
	    }
	}
    }

    chdir ($cwd);

    foreach my $dirname (keys %default_dirs) {
	if (not defined ($file_info{$dirname})) {
	    $file_info{$dirname} = $default_dirs{$dirname}
	}
    }

    if ($has_errors == 1) {
	return undef;
    } else {
	return \%file_info;
    }
}

my %all_files;

sub make_solaris_pkg ($$) {
    my $spec = shift;
    my $package = shift;

    my $pkginfo_proto = make_pkginfo ($spec, $package);
    my $dep_proto = make_depend ($spec, $package);
    my $scr_proto = make_scripts ($spec, $package);
    return 0 if not defined $scr_proto;
    my $copyright = make_copyright ($spec, $package);

    my $files_ref = get_proto_hash ($package);
    if (not defined ($files_ref)) {
	exit (1);
    }
    my %files = %$files_ref;
    foreach my $file (keys %files) {
	$all_files{$file} = "$package";
    }
    if (not %files) {
	print "WARNING: empty package: $package\n";
    }

    my $fhandle = "proto" . ++$file_id;

    my $protodir = $spec->eval ("%_topdir") . "/PKGMAPS/proto";
    my $fname = $package . ".proto";
    open $fhandle, ">$protodir/$fname" or
	fatal ("failed to create file $protodir/$fname");

    print $fhandle $pkginfo_proto;
    print $fhandle $dep_proto;
    print $fhandle $scr_proto;
    if (defined $copyright) {
	print $fhandle $copyright;
    }
    foreach my $fname (sort (keys %files)) {
	next if not $fname;
	print $fhandle $files{$fname};
	print $fhandle "\n";
    }
    close ($fhandle);

    my $pkgdir = $spec->eval ("%_topdir") . "/PKGS";
    my $buildroot = $package->eval ("%buildroot");
    system ("/usr/bin/pkgmk -o -r $buildroot -d $pkgdir -f $protodir/$fname");

    return (not $?);
}

sub make_packages ($) {
    my $spec = shift;

    if ($os ne 'solaris') {
#	return 1;
    }

    my @packages = $spec->get_packages ();

    foreach my $pkg (@packages) {
	make_solaris_pkg ($spec, $pkg) or return 0;
    }

    my $buildroot = $spec->eval ("%buildroot");
    my $old_cwd = `pwd`;
    chdir ($buildroot);
    my @all_fnames = list_all_files (".");
    my $unpackaged = 0;
    foreach my $fname (@all_fnames) {
	$fname = substr ($fname, 2);
	if (not defined ($all_files{$fname})) {
	    if (not $unpackaged) {
		$unpackaged = 1;
		print "WARNING: the following files are not included in any packages:\n"
	    }
	    print "        /$fname\n";
	}
    }
    chdir ($old_cwd);
    
    return 1;
}

sub make_src_pkginfo ($$) {
    my $spec = shift;
    my $pkgname = shift;

    my $fhandle = "pkginfo" . ++$file_id;

    my $pkginfodir = $spec->eval ("%_topdir") . "/PKGMAPS/pkginfo";
    my $fname = $pkgname . ".pkginfo";
    open $fhandle, ">$pkginfodir/$fname" or
	fatal ("failed to create file $pkginfodir/$fname");

    print $fhandle "PKG=" . $pkgname . "\n";
    my $summary = $spec->get_value_of ('summary');
    $summary = $pkgname unless defined ($summary);
    print $fhandle "NAME=$summary - sources\n";
    print $fhandle "DESC=$summary - sources\n";
    print $fhandle "ARCH=$arch\n";

    my $prodname = $spec->get_value_of ('sunw_prodname');
    print $fhandle "SUNW_PRODNAME=$prodname\n" if $prodname;

    my $prodvers = $spec->get_value_of ('sunw_prodvers');
    print $fhandle "SUNW_PRODVERS=$prodvers\n" if $prodvers;
    print $fhandle "SUNW_PKGTYPE=usr\n";

    my $pkgvers = $spec->get_value_of ('sunw_pkgvers');
    $pkgvers = "1.0" unless $pkgvers;
    print $fhandle "SUNW_PKGVERS=$pkgvers\n";

    my $category = $spec->get_value_of ('sunw_category');
    if (not defined ($category)) {
	$category = "application";
    }
    print $fhandle "CATEGORY=$category,SOURCE\n";

    my $vendor = $spec->get_value_of ('vendor');
    print $fhandle "VENDOR=$vendor\n" if $vendor;

    my $hotline = $spec->get_value_of ('sunw_hotline');
    print $fhandle "HOTLINE=$hotline\n" if $hotline;
    print $fhandle "EMAIL=\n";

    my $maxinst = $spec->get_value_of ('sunw_maxinst');
    print $fhandle "MAXINST=$maxinst\n" if $maxinst;

    my $version = $spec->eval ('%version');
    my $rev = $spec->get_value_of ('sunw_rev');
    if (not defined $rev) {
	$rev = `date +%Y.%m.%d.%H.%M`;
    } else {
	$rev = "$rev." . `date +%Y.%m.%d.%H.%M`;
    }
    chomp ($rev);
    print $fhandle "VERSION=$version,REV=$rev\n";
    print $fhandle "BASEDIR=/usr\n";
    print $fhandle "CLASSES=none\n";

    close $fhandle;
    return "i pkginfo=$pkginfodir/$fname\n";
}

# source package contents:
# SOURCES/
#    Source<1..n>
#    Patch<1..m>
#    SUNW_CopyRight
#    Class action script files
# SPECS/
#    $self->{file_name}
#    %use'd spec files (recursively)
#    %include'd files (recursively)
sub make_src_package ($) {
    my $spec = shift;

    if ($os ne 'solaris') {
#	return 1;
    }

    my $base_pkg_name = $spec->get_name ();
    my $base_pkg_version = $spec->eval ("%version");

    my $src_pkg_name = $spec->get_value_of ("sourcepackage");
    if (not defined $src_pkg_name) {
	$src_pkg_name = $base_pkg_name;
	$src_pkg_name .= "-src";
    }

    my @sources = $spec->get_sources ();

    my @patches = $spec->get_patches ();

    my $copyright = $spec->get_value_of ("sunw_copyright");

    my @script_files = $spec->get_class_script_names ();

    my @includes = $spec->get_included_files ();

    my $this_spec_file = $spec->get_file_name ();
    if (not $this_spec_file =~ /^\//) {
	$this_spec_file = "$mydir/$this_spec_file";
    }

    my @used_spec_files = $spec->get_used_spec_files ();

    my $pkginfo_line = make_src_pkginfo ($spec, $src_pkg_name);
    my $copyright_line = make_copyright ($spec, undef, $src_pkg_name);

    my $fhandle = "proto" . ++$file_id;

    my $protodir = $spec->eval ("%_topdir") . "/PKGMAPS/proto";
    my $fname = $src_pkg_name . ".proto";
    open $fhandle, ">$protodir/$fname" or
	fatal ("failed to create file $protodir/$fname");

    print $fhandle $pkginfo_line;
    if (defined $copyright_line) {
	print $fhandle $copyright_line;
    }

    my $srcdir = "share/src/${base_pkg_name}-${base_pkg_version}/SOURCES";
    my $specdir = "share/src/${base_pkg_name}-${base_pkg_version}/SPECS";
    print $fhandle "d none share 0755 root sys\n";
    print $fhandle "d none share/src 0755 root sys\n";
    print $fhandle "d none share/src/$srcdir 0755 root other\n";
    print $fhandle "d none $srcdir 0755 root other\n";
    print $fhandle "d none $specdir 0755 root other\n";

    my $topdir = $spec->eval ("%_topdir");
    foreach my $fname (@sources, @patches, $copyright, @script_files) {
	next if not $fname;
	$fname =~ s/^.*\/([^\/]+)/$1/;
	print $fhandle "f none $srcdir/$fname=$topdir/SOURCES/$fname 644 root other\n";
    }

    foreach my $fname (@includes, @used_spec_files) {
	next if not $fname;
	$fname =~ s/^.*\/([^\/]+)/$1/;
 	print $fhandle "f none $specdir/$fname=$topdir/SPECS/$fname 644 root other\n";
    }
    my $base_spec_name = $this_spec_file;
    $base_spec_name =~ s/^.*\/([^\/]*)$/$1/;
    print $fhandle "f none $specdir/$base_spec_name=$this_spec_file 644 root other\n";
    print $fhandle "s none $specdir/..main.spec=$base_spec_name\n";
    my $sourcedir = $spec->eval ("%_sourcedir");
    open VERSIONFILE, ">$sourcedir/..pkgbuild" or
	fatal ("failed to create file $sourcedir/..pkgbuild");
    print VERSIONFILE "pkgbuild_version=$myversion\n";
    close VERSIONFILE;

    print $fhandle "f none $specdir/..pkgbuild=$sourcedir/..pkgbuild 444 root other\n";

    close ($fhandle);

    system ("/usr/bin/pkgmk -o -r / -d $topdir/SPKGS -f $protodir/$fname");
    return (not $?);
}

sub main () {
    process_options ();
    init ();

    if (not @spec_names) {
	if (not defined $build_command and $version_printed) {
	    exit (0);
	}
	fatal ("no spec files given for build");
    }

    if (not defined $build_command) {
	usage ();
    }

    foreach my $spec_name (@spec_names) {
	my $spec = new rpm_spec ($spec_name, \@predefines);
	if (not defined $spec) {
	    fatal ("File is not a regular file: $spec_name");
	}
	my $name = $spec->get_value_of ("name");
	if (defined ($spec->{error})) {
	    fatal ($spec->{error});
	}
	if (not defined($name)) {
	    fatal ("The Name tag is not defined in " .
		   $spec->get_file_name());
	}
	if ($check_deps) {
	    check_build_requires ($spec) or exit (1);
	}
	if ($build_command =~ /p/) {
	    do_block ($spec, 'prep') or exit (1);
	}
	if ($build_command =~ /c/) {
	    do_block ($spec, 'build') or exit (1);
	}
	if ($build_command =~ /i/) {
	    do_block ($spec, 'install') or exit (1);
	}
	if ($build_command =~ /[ba]/) {
	    make_packages ($spec) or 
		fatal ($spec->get_error ());
	}
	if ($build_command =~ /[as]/) {
	    make_src_package ($spec) or
		fatal ($spec->get_error ());
	} 
	if ($build_command =~ /[bas]/) {
	    do_block ($spec, 'clean') or exit (1);
	}
   }
}

main();
