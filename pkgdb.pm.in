#
#  The pkgbuild build engine
#
#  This file Copyright (C) 2007 Mike Bristow <mike@urgle.com>
#  Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
#
#  pkgbuild is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License 
#  version 2 published by the Free Software Foundation.
#
#  pkgbuild is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#  General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
#  As a special exception to the GNU General Public License, if you
#  distribute this file as part of a program that contains a
#  configuration script generated by Autoconf, you may include it under
#  the same distribution terms that you use for the rest of that program.
#
#  Authors:  Mike Bristow <mike@urgle.com>  (most of this file)
#         :  Laszlo Peter  <laca@sun.com>   (most of pkgbuild)
#

package pkgdb;

use constant CONTENTS => '/var/sadm/install/contents';

sub new($;$) {
    my $ref = shift;
    my $is_ips = shift;

    my $self = {};

    $self->{_is_ips} = $is_ips;

    $self->{_topdir} = "/";

    bless ($self, $ref);
    $self->{contents} = "/dev/null";
    $self->{fname_cache} = {};
    $self->{ips_pkgname_cache} = {};
    $self->{svr4_pkgname_cache} = {};
    $self->{description_cache} = {};

    $self->set_contents(CONTENTS)
        or return undef;
    return $self;
}

sub set_verbosity($$) {
    my $self = shift;
    $self->{_verbose} = shift;
}

sub msg_info ($$$) {
    my $self = shift;
    my $min_verb = shift;
    my $msg = shift;
    if ($self->{_verbose} > $min_verb) {
	print "PKGDB: " . $msg . "\n";
    }
}

sub set_topdir($$) {
    my $self = shift;
    my $topdir = shift;

    $self->{_topdir} = $topdir;
}

sub set_contents($$) {
    my $self = shift;
    my $contents = shift;
    if (! -r $contents) {
        print "ERROR: Cannot open $contents: $!";
	return 0;
    }
    $self->{contents} = $contents;
    return 1;
}

# the argument may be a /file/path or an SVr4 pkg name or an IPS pkg name
# returns the one-line description of the package
sub get_description($$) {
    my $self = shift;
    my $pkg = shift;

    if (defined ($self->{description_cache}->{$pkg})) {
	if ($self->{description_cache}->{$pkg} eq "%UNDEF%") {
	    return undef;
	}
	return $self->{description_cache}->{$pkg};
    }

    $def_pkgname = $self->get_pkgname($pkg);
    if (defined ($self->{description_cache}->{$def_pkgname})) {
	if ($self->{description_cache}->{$def_pkgname} eq "%UNDEF%") {
	    return undef;
	}
	return $self->{description_cache}->{$def_pkgname};
    }

    # first try an SVr4 package or a legacy action
    my $pkgdesc = `/usr/bin/pkginfo '$pkg.*' 2>/dev/null | head -1`;
    chomp ($pkgdesc);
    if ($pkgdesc ne '') {
	$pkgdesc =~ s/^\S*\s*$pkg\s*(\S.*)$/$1/;
	$self->{description_cache}->{$def_pkgname} = $pkgdesc;
	return $pkgdesc;
    }

    # then look in list of packages built by pkgtool on this system
    my $topdir = $self->{_topdir};
    if (-e "$topdir/.pkgnames") {
	$pkgdesc = `grep "^${pkg}:" "$topdir/.pkgnames" | head -1`;
	chomp ($pkgdesc);
	if ($pkgdesc ne '') {
	    $pkgdesc =~ s/^${pkg}:(.*)/$1/;
	    $self->{description_cache}->{$def_pkgname} = $pkgdesc;
	    return $pkgdesc;
	} else {
	    # look in a predefined list of package names
	    $pkgdesc = `grep "^${pkg}:" "@PKGBUILD_LIBDIR@/pkgnames" | head -1`;
	    chomp ($pkgdesc);
	    if ($pkgdesc ne '') {
		$pkgdesc =~ s/^${pkg}:(.*)/$1/;
		$self->{description_cache}->{$def_pkgname} = $pkgdesc;
		return $pkgdesc;
	    }
	}
    }

    if ($self->{_is_ips}) {
	# if that doesn't work, look for a locally installed IPS package
	my $pkgdesc = `/usr/bin/pkg info -l '$def_pkgname' 2>/dev/null | grep '^ *Summary:' | head -1`;
	chomp ($pkgdesc);
	if ($pkgdesc eq "") {
	    # try harder: run a [slow] remote search
	    $self->msg_info(0, "Package $def_pkgname is not installed, running a remote search for a package description");
	    $pkgdesc = `/usr/bin/pkg info -r '$def_pkgname' 2>/dev/null | grep '^ *Summary:' | head -1`;
	    chomp ($pkgdesc);
	    if ($pkgdesc ne '') {
		$pkgdesc =~ s/^\s*Summary:\s(.*)$/$1/;
		$self->{description_cache}->{$def_pkgname} = $pkgdesc;
		return $pkgdesc;
	    }
	} else {
	    $pkgdesc =~ s/^\s*Summary:\s(.*)$/$1/;
	    $self->{description_cache}->{$def_pkgname} = $pkgdesc;
	    return $pkgdesc;
	}
    }

    $self->msg_info (0, "WARNING: could not find a package description for $pkg");
    $self->{description_cache}->{$def_pkgname} = "%UNDEF%";
    return undef;
}

# arguments:
#  $pkg - name of a preferred package or undef
#  @pkgnames - list of package names to choose from
sub _select_package($@) {
    my $pkg = shift;
    my @pkgnames = @_;

    my @favoured_packages = qw(system/locale/.* system/.* library/.*
                               runtime/.* desktop/.* gnome/.* text/.*
                               SUNWcs SUNWcsu SUNWcsr SUNWcsxu
                               SUNWcar SUNWcarx SUNWcsd
                               SUNWcsl SUNWcslx);
    my @blacklisted_packages = qw(consolidation/.*
                                  compatibility/packages/.*);
    if (defined($pkg)) {
	my $safepkg = $pkg;
	$safepkg =~ s/\+/\\+/g;
	$safepkg =~ s/\./\\./g;
	unshift @favoured_packages, "${safepkg}.*";
	unshift @favoured_packages, "${safepkg}-devel";
	unshift @favoured_packages, "${safepkg}-root";
	unshift @favoured_packages, "${safepkg}r";
	unshift @favoured_packages, "${safepkg}u";
	unshift @favoured_packages, "${safepkg}";
    }

    # filter out blacklisted pkgs
    foreach my $p (@blacklisted_packages) {
	my @pkgnames2 = grep !/(?:pkg:\/+)?${p}(@.*)?$/, @pkgnames;
	@pkgnames = @pkgnames2;
    }

    if (not @pkgnames) {
	return undef;
    }

    foreach my $p (@favoured_packages) {
	# if we find a favoured package, return it
	my @ps = grep /^(?:pkg:\/+)?${p}(@.*)?$/, @pkgnames;
	$pkg = $ps[0];
	return $pkg if defined ($pkg);
    }

    # If we have no better idea, prefer SUNW packages to others
    if (not defined ($pkg)) {
	my @sunpkgs = grep /^SUNW/, @pkgnames;
	if (@sunpkgs >= 1) { 
	    return $sunpkgs[0];
	}
    }

    # Oh, sod it.  return on the first one.  We could perhaps
    # do better.
    return $pkgnames[0];
}

# the argument may be a /file/path or an SVr4 pkg name or an IPS pkg name
# returns the SVr4 package name, if exists; undef otherwise
sub get_svr4_pkgname($$) {
    my $self = shift;
    my $pkg = shift;

    if (defined ($self->{svr4_pkgname_cache}->{$pkg})) {
	if ($self->{svr4_pkgname_cache}->{$pkg} eq "%UNDEF%") {
	    return undef;
	}
	return $self->{svr4_pkgname_cache}->{$pkg};
    }

    if ($pkg =~ /^\/./) {
	# the argument looks like a /path/to/a/file
	my @pkgnames = $self->file2pkgs($pkg);
	if (@pkgnames) {
	    my $spkg = _select_package($pkg, @pkgnames);
	    if ($self->{_is_ips}) {
		# we are on an IPS-based system, so the package names
		# returned by file2pkgs are IPS package names, need to
		# translate to SVr4
		$pkg = $spkg;
	    } else {
		$self->{svr4_pkgname_cache}->{$pkg} = $spkg;
		return $spkg;
	    }
	} else {
	    # no matching package found
	    $self->{svr4_pkgname_cache}->{$pkg} = "%UNDEF%";
	    return undef;
	}
    }

    # first check if it's a valid SVr4 package name
    `/usr/bin/pkginfo -q '$pkg.*'`;
    if ($? == 0) {
	$self->{svr4_pkgname_cache}->{$pkg} = $pkg;
	return $pkg;
    }    

    my $ips_pkg = $self->get_ips_pkgname ($pkg);

    if ($self->{_is_ips}) {
	# then look for a legacy action locally
	my @search_out = `pkg contents -Ho action.raw -t legacy '$ips_pkg' 2>/dev/null`;
	if (not @search_out) {
	    # try harder, do a remote search
	    $self->msg_info (0, "Package $pkg is not installed, running a remote search for legacy actions");
	    @search_out = `pkg contents -r -Ho action.raw -t legacy '$ips_pkg' 2>/dev/null`;
	}

	if (@search_out) {
	    my @s_o_copy = @search_out;
	    map $_ =~ s/.* pkg=([^ ]*) .*/$1/s, @search_out;
	    my $spkg = _select_package ($pkg, @search_out);
	    if (not defined($spkg)) {
		return undef;
	    }
	    $self->{svr4_pkgname_cache}->{$pkg} = $spkg;
	    my $legacy_line = grep / pkg=$spkg /, @s_o_copy;
	    if ($s_o_copy =~ / name="([^"]+)" /) {
		$self->{description_cache}->{$pkg} = $1;
		$self->{description_cache}->{$spkg} = $1;
	    }
	    return $spkg;
	}
    }

    $self->{description_cache}->{$pkg} = "%UNDEF%";
    return undef;
}

# the argument may be a /file/path or an SVr4 pkg name or an IPS pkg name
# returns the IPS package name, if exists; undef otherwise
sub get_ips_pkgname($$$) {
    my $self = shift;
    my $pkg = shift;
    my $search_remote = shift;

    if (defined ($self->{ips_pkgname_cache}->{$pkg})) {
	if ($self->{ips_pkgname_cache}->{$pkg} eq "%UNDEF%") {
	    return undef;
	}
	return $self->{ips_pkgname_cache}->{$pkg};
    }

    if ($search_remote) {
	$self->msg_info (1, "Resolving $pkg (remote search)");
    } else {
	$self->msg_info (1, "Resolving $pkg");
    }
    if ($pkg =~ /^\/./) {
	# the argument looks like a /path/to/a/file
	my $fname = $pkg;
	my @pkgnames = $self->file2pkgs($pkg);
	if (@pkgnames) {
	    $pkg = _select_package($pkg, @pkgnames);
	    return $pkg;
	} else {
	    # no matching package found
	    $self->{ips_pkgname_cache}->{$pkg} = "%UNDEF%";
	    return undef;
	}
    }

    my @search_out;
    if ($search_remote) {
	$self->msg_info (1, "Trying pkg info -r");
	@search_out = `/usr/bin/pkg info -r '$pkg' 2>/dev/null`;
    } else {
	$self->msg_info (1, "Trying pkg info -l");
	@search_out = `/usr/bin/pkg info -l '$pkg' 2>/dev/null`;
    }
    my @partial_matches;
    my $partial_selected = 0;
    my $partial_name;
    my $pkg_selected = 0;
    my $pkg_only = $pkg;
    $pkg_only =~ s/@.*//;
    while (@search_out) {
	my $s_o_line = shift (@search_out);
	chomp ($s_o_line);
	if ($s_o_line =~ /^\s*Name:\s*(.*)/) {
	    if ($1 eq $pkg_only) {
		$self->msg_info (2, "Exact match found for $pkg_only");
		# exact match
		$pkg_selected = 1;
	    } else {
		# not an exact match
		$partial_name = $1;
		$partial_selected = 1;
	    }
	    next;
	}
	if ($s_o_line =~ /\s*Renamed to:\s*(\S[^@]*)/) {
	    if ($pkg_selected) {
		# there may be multiple packages, get a list of them
		$self->msg_info (0, "Package $pkg_only was renamed to $1");
		my @pnames = ($1);
		my @s_o_copy = @search_out;
		foreach my $l (@s_o_copy) {
		    chomp ($l);
		    if ($l =~ /^\s+(\S+)\@[0-9]\S*$/) {
			$self->msg_info (0, "      ... and $1");
			push (@pnames, $1);
		    } elsif ($l =~ /^\s+([^:@]+)$/) {
			$self->msg_info (0, "      ... and $1");
			push (@pnames, $1);
		    } else {
			last;
		    }
		}
		my $sel_pname = _select_package ($pkg_only, @pnames);
		if (not defined($sel_pname)) {
		    return undef;
		}
		$self->msg_info (0, "Selected $sel_pname for $pkg_only");
		# look up the package that this package was renamed to
		$sel_pname = $self->get_ips_pkgname ($sel_pname);
		$self->{ips_pkgname_cache}->{$pkg} = "$sel_pname";
		$self->{ips_pkgname_cache}->{$pkg_only} = "$sel_pname";
		return $self->{ips_pkgname_cache}->{$pkg};
	    }
	    if ($partial_selected) {
		# a non-exact match was renamed to something else
		$partial_name = $self->get_ips_pkgname ($1);
		push (@partial_matches, $partial_name);
		$partial_selected = 0;
	    }
	}
	# parse the FMRI: line
	if ($pkg_selected and $s_o_line =~ /^\s*FMRI:\s[^@]+\@([^:]+):/) {
	    $self->{ips_pkgname_cache}->{$pkg} = "$pkg_only\@$1";
	    $self->{ips_pkgname_cache}->{$pkg_only} = "$pkg_only\@$1";
	    $self->msg_info(2, "Resolved to " . $self->{ips_pkgname_cache}->{$pkg});
	    return $self->{ips_pkgname_cache}->{$pkg};
	}
	if ($partial_selected and $s_o_line =~ /^\s*FMRI:\s[^@]+\@([^:]+):/) {
	    $partial_selected = 0;
	    push (@partial_matches, "$partial_name\@$1");
	}
    }
    # No exact match found, but pkg info did return a match, let's use it
    if (@partial_matches) {
	my $best_match = _select_package($pkg, @partial_matches);
	if (defined($best_match)) {
	    $self->msg_info (0, "Selected \"$best_match\" for $pkg");
	    # look up the selected package name again for version info
	    $best_match = $self->get_ips_pkgname ($best_match);
	    $self->{ips_pkgname_cache}->{$pkg} = "$best_match";
	    $self->{ips_pkgname_cache}->{$pkg_only} = "$best_match";
	    return $self->{ips_pkgname_cache}->{$pkg};
	}
    }

    # search for local or remote matches using pkg search

    # file2pkgs works for package names, too
    my @pkgnames = $self->file2pkgs($pkg, 1);
    if (@pkgnames) {
	my $spkg = _select_package($pkg, @pkgnames);
	if (not defined ($spkg)) {
	    $self->{ips_pkgname_cache}->{$pkg} = "%UNDEF%";
	    $self->{ips_pkgname_cache}->{$pkg_only} = "%UNDEF%";
	    return undef;
	}
	# look up package again, in case it was renamed
	my $pkg_info = `/usr/bin/pkg info -r '$spkg' 2>/dev/null`;
	if ($pkg_info =~ /\n\s*Renamed to:\s([^\n]+)\n/) {
	    $spkg = $self->get_ips_pkgname ($spkg, 1);
	}
	$self->{ips_pkgname_cache}->{$pkg} = "$spkg";
	$self->{ips_pkgname_cache}->{$pkg_only} = "$spkg";
	return $self->{ips_pkgname_cache}->{$pkg};
    }

    # No local package found, search remote repos
    if (not $search_remote) {
	$self->msg_info (0, "No local match found for $pkg, searching remote repos");
	return $self->get_ips_pkgname ($pkg, 1);
    }
    
    # No match found
    $self->{ips_pkgname_cache}->{$pkg} = "%UNDEF%";
    return undef;
}

# the argument may be a /file/path or an SVr4 pkg name or an IPS pkg name
# returns a packages from the default packaging system (i.e. an SVr4 package
# name on an SVr4 system and an IPS package name on an IPS-based system
sub get_pkgname ($$) {
    my $self = shift;
    my $pkg = shift;

    if ($self->{_is_ips}) {
	return $self->get_ips_pkgname($pkg);
    } else {
	return $self->get_svr4_pkgname($pkg);
    }
}

sub file2pkgs($$;$) {
    my $self = shift;
    my $file = shift;
    # [ab]using this function for searching for packages
    my $is_pkg = shift;

    if (defined $self->{fname_cache}->{$file}) {
	my $result_ref = $self->{fname_cache}->{$file};
	return @$result_ref;
    }

    my $result;

    if ($self->{_is_ips}) {
	my @ips_lines;
	if (-e $file) {
	    $self->msg_info (1, "Trying pkg search -Il");
	    @ips_lines = `/usr/bin/pkg search -Il '${file}' | grep '^path'`;
	} else {
	    # file does not exist locally, but try searching the remote repos
	    if (defined ($is_pkg)) {
		$self->msg_info (1, "Trying pkg search -Il");
		# searching for a package name
		@ips_lines = `/usr/bin/pkg search -Il '${file}' | egrep '^(legacy_pkg|pkg.fmri|require|incorporate)'`;
		if (not @ips_lines) {
		    $self->msg_info (1, "Trying pkg search -Ir");
		    @ips_lines = `/usr/bin/pkg search -Ir '${file}' | egrep '^(legacy_pkg|pkg.fmri|require|incorporate)'`;
		}
	    } else {
		# really search for a file
		@ips_lines = `/usr/bin/pkg search -Ir '${file}' | grep '^path'`;
	    }
	}
	my @pkglist = ();
	my $branch = `uname -v`;
	chomp($branch);
	$branch =~ s/^[^0-9]*([0-9]+).*/$1/;
	my $highest_branch;
	my $ptype_h_b;
	my $pname_h_b;
	foreach my $ips_line (@ips_lines) {
	    my $pname;
	    my $ptype;
	    if ($ips_line =~ /^(path|legacy_pkg|pkg.fmri)\s.*pkg:\/(.+)/) {
		$ptype = $1;
		$pname = $2;
	    } elsif ($ips_line =~ /^(incorporate|require)\s+depend\s+([^\s]+)/) {
		$ptype = $1;
		$pname = $2;
	    } else {
		next;
	    }
	    if ($pname =~ /.*@.*-0.([0-9]+)/) {
		if ($branch eq $1) {
		    push (@pkglist, $pname);
		} else {
		    if (defined ($highest_branch)) {
			if ($highest_branch < $1) {
			    $pname_h_b = $pname;
			    $highest_branch = $1;
			    $ptype_h_b = $ptype;
			} elsif ($highest_branch == $1) {
			    if ($ptype_h_b =~ /(incorporate|require)/) {
				# prefer any action to incorporate or require
				$pname_h_b = $pname;
				$highest_branch = $1;
				$ptype_h_b = $ptype;
			    } elsif ($ptype_h_b eq "legacy_pkg" and
				     not $ptype =~ /(incorporate|require)/) {
				# prefer legacy to incorporate or require
				# but not other types of references
				$pname_h_b = $pname;
				$highest_branch = $1;
				$ptype_h_b = $ptype;
			    }
			}
		    } else {
			$pname_h_b = $pname;
			$ptype_h_b = $ptype;
			$highest_branch = $1;
		    }
		}
	    } else {
		# no branch in version string
		push (@pkglist, $pname);
	    }
# Disable for now -- it's currently slow and we don't use the extra info anyway
#	        $result = $self->_parse_ips_line($pname, $file, $ips_lines[0]);
#	        $self->{fname_cache}->{$file} = \@{$result->{packages}};
#	        return @{$result->{packages}};
# Instead: make a list of all package names that match the given file.
	}
	if (not @pkglist and defined($highest_branch)) {
	    push (@pkglist, $pname_h_b);
	}
	$self->{fname_cache}->{$file} = \@pkglist;
	return @pkglist;
    }

    # SVr4 code

    my $command = "@PKGBUILD_LIBDIR@/pkgdbgrep -c '$self->{contents}' '${file}'";
    my @grepped_lines = `$command`;
    foreach my $line (@grepped_lines) {
	chomp ($line);
        my $rtmp = $self->_parse_line($line);
        next unless $rtmp->{path} eq $file;
        die "Two entries for $file" if defined $result;
        $result = $rtmp;
    }
    $self->{fname_cache}->{$file} = \@{$result->{packages}};
    return @{$result->{packages}};
}

sub _parse_ips_line($$$$) {
    my $self = shift;
    my $pkg = shift;
    my $file = shift;
    my $line = shift;

    my $file =~ s/^\/*//;
    my %result;
    my $output = `/usr/bin/pkg contents -m '$pkg' | /usr/bin/grep 'path=${file} '`;
    $output=" $output ";
    if ($line =~ /^path\s+dir\s/) {
	$result{type} = 'd';
    } elsif ($line =~ /^path\s+link\s/) {
	$result{type} = 's';
    } elsif ($line =~ /^path\s+hardlink\s/) {
	$result{type} = 'l';
    } elsif ($line =~ /^path\s+file\s/) {
	$result{type} = 'f';
    }

    $result{class} = 'none';

    if ($output =~ /\sgroup=(\S+)\s/) {
	$result{group} = $1;
    }

    if ($output =~ /\sowner=(\S+)\s/) {
	$result{owner} = $1;
    }

    if ($output =~ /\smode=(\S+)\s/) {
	$result{mode} = $1;
    }

    if ($output =~ /\spkg\.size=(\S+)\s/) {
	$result{size} = $1;
    }

    my @pkgs = ($pkg);
    $result{packages} = \@pkgs;
    return \%result;
}

sub _parse_line($$) {
    my $self = shift;
    my $line = shift;

    my %result;
    my @fields = split / +/, $line;
    
    my $type = $fields[1];
    return if $type eq '?'; # No idea what a filetype of '?' is, except
                                 # 'broken db'
    unless ($type =~ /^[sldbcfxve]$/) {
        die "Unrecognized file type in $line\n";
    }

    # symlinks are a little different in the way fields[0] is treated
    if ($type eq 's' or $type eq 'l') {
        $fields[0] =~ m~^(/[^=]*)=([^=]+)$~ 
		or die "Unexpected path=rpath in $line";
        $result{path} = $1;
        $result{rpath} = $2;
    } else {
        $fields[0] =~ m~=~ and die "Unexpected rpath for non-link in $line";
        $result{path} = $fields[0];
    }

    shift @fields; # lose the path/rpath
    $result{type} = shift @fields;
    $result{class} = shift @fields;

    if ($type eq 'b' or $type eq 'c') { 
        $result{major} = shift @fields;
        $result{minor} = shift @fields;
        $result{mode} = shift @fields;
        $result{owner} = shift @fields;
        $result{group} = shift @fields;
    } elsif ($type eq 'd' or $type eq 'x') {
        $result{mode} = shift @fields;
        $result{owner} = shift @fields;
        $result{group} = shift @fields;
    } elsif ($type eq 'f' or $type eq 'v' or $type eq 'e') {
        $result{mode} = shift @fields;
        $result{owner} = shift @fields;
        $result{group} = shift @fields;
        $result{size} = shift @fields;
        $result{cksum} = shift @fields;
        $result{modtime} = shift @fields;
    }

    # everything else is package or packages(s)
    $result{packages} = \@fields;

    return \%result;
}

1;
