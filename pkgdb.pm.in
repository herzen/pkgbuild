#
#  The pkgbuild build engine
#
#  This file Copyright (C) 2007 Mike Bristow <mike@urgle.com>
#            Copyright 2008 Sun Microsystems, Inc.
#
#  pkgbuild is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License 
#  version 2 published by the Free Software Foundation.
#
#  pkgbuild is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#  General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
#  As a special exception to the GNU General Public License, if you
#  distribute this file as part of a program that contains a
#  configuration script generated by Autoconf, you may include it under
#  the same distribution terms that you use for the rest of that program.
#
#  Authors:  Mike Bristow <mike@urgle.com>  (most of this file)
#         :  Laszlo Peter  <laca@sun.com>   (most of pkgbuild)
#

package pkgdb;

use constant CONTENTS => '/var/sadm/install/contents';

sub new {
    my $ref = shift;
    my %args = ( contents => CONTENTS, @_ );
    my $self = {};
    bless ($self, $ref);
    $self->{contents} = "/dev/null";
    $self->{cache} = {};

    $self->set_contents($args{contents})
        or return undef;
    return $self;
}

sub set_contents($$) {
    my $self = shift;
    my $contents = shift;
    if (! -r $contents) {
        die "Cannot open $contents: $!";
    }
    $self->{contents} = $contents;
    return 1;
}

sub file2pkgs($$) {
    my $self = shift;
    my $file = shift;

    if (defined $self->{cache}->{$file}) {
	my $result_ref = $self->{cache}->{$file};
	return @$result_ref;
    }
    my $result;
    my $command = "@PKGBUILD_LIBDIR@/pkgdbgrep -c '$self->{contents}' '${file}'";
    my @grepped_lines = `$command`;
    foreach my $line (@grepped_lines) {
	chomp ($line);
        my $rtmp = $self->_parse_line($line);
        next unless $rtmp->{path} eq $file;
        die "Two entries for $file" if defined $result;
        $result = $rtmp;
    }
    $self->{cache}->{$file} = \@{$result->{packages}};
    return @{$result->{packages}};
}

sub _parse_line($$) {
    my $self = shift;
    my $line = shift;

    my %result;
    my @fields = split / +/, $line;
    
    my $type = $fields[1];
    return if $type eq '?'; # No idea what a filetype of '?' is, except
                                 # 'broken db'
    unless ($type =~ /^[sldbcfxve]$/) {
        die "Unrecognized file type in $line\n";
    }

    # symlinks are a little different in the way fields[0] is treated
    if ($type eq 's' or $type eq 'l') {
        $fields[0] =~ m~^(/[^=]*)=([^=]+)$~ 
		or die "Unexpected path=rpath in $line";
        $result{path} = $1;
        $result{rpath} = $2;
    } else {
        $fields[0] =~ m~=~ and die "Unexpected rpath for non-link in $line";
        $result{path} = $fields[0];
    }

    shift @fields; # lose the path/rpath
    $result{type} = shift @fields;
    $result{class} = shift @fields;

    if ($type eq 'b' or $type eq 'c') { 
        $result{major} = shift @fields;
        $result{minor} = shift @fields;
        $result{mode} = shift @fields;
        $result{owner} = shift @fields;
        $result{group} = shift @fields;
    } elsif ($type eq 'd' or $type eq 'x') {
        $result{mode} = shift @fields;
        $result{owner} = shift @fields;
        $result{group} = shift @fields;
    } elsif ($type eq 'f' or $type eq 'v' or $type eq 'e') {
        $result{mode} = shift @fields;
        $result{owner} = shift @fields;
        $result{group} = shift @fields;
        $result{size} = shift @fields;
        $result{cksum} = shift @fields;
        $result{modtime} = shift @fields;
    }

    # everything else is package or packages(s)
    $result{packages} = \@fields;

    return \%result;
}

1;
